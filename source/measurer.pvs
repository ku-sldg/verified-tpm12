%%
%%
%% Measurer Theory
%%
%% 
measurer [ B:TYPE+, % BLOB
           HV:TYPE+,% Hash value
	   empty:HV, % Empty or initial hash value
	   hash:[B->HV], % Hash function
	   append:[HV, HV -> B] % Append function
	  ] : THEORY

  BEGIN

  ASSUMING
    % Assume that different blobs always have different hashes
    unique_hash: ASSUMPTION
      FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
    
    % Assume that append is antisymmetric unless the hashes are equal   
    append_antisym: ASSUMPTION
      FORALL (h1,h2:HV) :
        append(h1,h2)=append(h2,h1) iff h1=h2;

    % Assume that if the results of two append applications are the same
    % the corresponding arguments to append are the same.

    % See if this is used in any proofs
    append_lemma_2: ASSUMPTION
      FORALL (h1,h2,h3,h4:HV) :
        (append(h1,h2)=append(h3,h4)) iff (h1=h3 and h2=h4);
  ENDASSUMING

  %% State monad input type - currently unused
  inputValue : DATATYPE
  BEGIN
    inputError : inputError?
    inputNat(n:nat) : inputNat?
    inputHV(h:HV) : inputHV?
  END inputValue;

  %% State monad output type - currently unused
  outputValue : DATATYPE
  BEGIN
    outputError(s:string) : outputError?
    outputNat(n:nat) : outputNat?
    outputQuote : outputQuote?
  END outputValue;

  IMPORTING pcr[HV];
  IMPORTING StateMonad[nat,PCR];

  % Domain type
  D:TYPE+;

  % ASPs generate measurement blobs from domains
  ASP:TYPE+ = [D->B]; % ASP type

  % PCR extension is appending pcr value to hash and hashing the result
  % extend(pcr,hv:HV) : HV = hash(append(pcr,hv));

  % Actual value stored in a PCR in terms of hash values.
  % resetOne case should be updated before use
  value(p:PCR):RECURSIVE HV =
    CASES p OF
      reset : empty,
      resetOne : empty,
      extend(p1,h1) : hash(append(value(p1),h1))
    ENDCASES
    MEASURE p BY <<

  % Lemmas and what not

  % Lemma used to be an assumption, replaced by a stronger assumption.
  append_lemma_1: LEMMA
     FORALL (h1,h2,h3:HV) : append(h1,h2)=append(h1,h3) iff h2=h3;

  % Extension is antisymmetric unless the hashes are equal
  extend_antisym: LEMMA forall (p:PCR,hv1,hv2:HV) :
    extend(p,hv2) = extend(p,hv1) IFF hv1=hv2;

  % The value resulting from extension is antisymmetric unless hashes are
  % equal
  extend_antisym_value: LEMMA forall (p:PCR,hv1,hv2:HV) :
    value(extend(p,hv2)) = value(extend(p,hv1)) iff hv1=hv2;

  % Last theorem, the other way around.
  extend_antisym2: LEMMA forall (p1,p2:PCR, hv:HV) :
    (extend(p1,hv)=extend(p2,hv)) iff p1=p2;

  extend_antisym2_value: LEMMA forall (p1,p2:PCR, hv:HV) :
    (value(extend(p1,hv)) = value(extend(p2,hv))) iff (p1=p2)

  % Major Theorems

  % ASP execution is independent of sequential order

  % Replay is detectable via the evidence composite.  Proof by induction
  % and simplification.  Must also have unique_hash assumption.
  replay_detection: THEOREM forall (p:PCR, asp:B, n0,n1:B) :
    n0/=n1 =>
    extend(extend(p,hash(asp)),hash(n0))
    /=
    extend(extend(p,hash(asp)),hash(n1));

  % Bad ASP is detectable via the evidence composite.  Same proof as above
  % with the same lemma needed.
  bad_asp: THEOREM forall (p:PCR, asp1,asp2:B, n0:B) :
    asp1/=asp2 =>
    extend(extend(p,hash(asp1)),hash(n0))
    /=
    extend(extend(p,hash(asp2)),hash(n0));

  % Violation of measurement data integrity is detectable via the evidence
  % composite.  This theorem should likely be restated and is proving to be
  % painful to prove.
  % Can't quite get this one to pop out right now.
  data_integrity: THEOREM forall (p1,p2:PCR, asp:B, n0:B) :
    p1/=p2 =>
    extend(extend(p1,hash(asp)),hash(n0))
    /=
    extend(extend(p2,hash(asp)),hash(n0));

  % Improper protocol execution will be detected
  % protocol_execution: THEOREM forall (a:set[ASP],p:set[HV]):
  %  look at induction on sets.  Can tell if proper asp was executed by building
  %  expected hash.

  % Out of order ASP execution will be detected
    
  % ASP execution cannot alter the measurement target.  Really need the
  % concept of order and state here.
  %asp_interference: THEOREM forall (asp:ASP,d:D) :
  %  asp(d) = asp(d)

  %% Regression theorems for testing only

  test1a: THEOREM (unit(3)) = (state(LAMBDA (s:PCR) : (3,s)))
  test1b: THEOREM (runState(unit(3))) =
           (runState(state(LAMBDA (s:PCR) : (3,s))))
  test1c: THEOREM (runState(unit(3)))(reset) =
           (runState(state(LAMBDA (s:PCR) : (3,s))))(reset)

  test2:  THEOREM (runState(unit(3)))(reset) = (3,reset)

  % Random hash values
  hv0, hv1, hv2 : HV

  % reset followed by a copy
  test3: THEOREM
    runState(modify(0,(LAMBDA (pcr:PCR):pcr)) >>= unit)(reset)=(0,reset)

  % reset followed by two copies
  test4: THEOREM
    runState(
       modify(0,(LAMBDA (pcr:PCR):pcr)) >>=
       (LAMBDA (x:nat):
         modify(1,(LAMBDA (pcr:PCR):pcr)) >>= unit))(reset)
     =
    (1,reset)

  % reset followed by two extensions.  Note the sequentiality.  The extension
  % by hv1 occurs first, then the extension by hv0.  This is our friend bind
  % at work!
  test5: THEOREM
    runState(
       modify(0,(LAMBDA (pcr:PCR):extend(pcr,hv1))) >>=
       (LAMBDA (x:nat):
          modify(1,(LAMBDA (pcr:PCR):extend(pcr,hv0))) >>= unit))(reset)
     =
    (1,extend(extend(reset,hv1),hv0))

  test6: THEOREM
    LET f1:State = modify(1,(LAMBDA (pcr:PCR): extend(pcr,hv0))),
      	f2:State = modify(0,(LAMBDA (pcr:PCR): extend(pcr,hv1))) IN
      runState(
        f2 >>= (LAMBDA (x:nat): f1 >>= unit))(reset)
      =
      (1,extend(extend(reset,hv1),hv0))

  %% Extend is antisymmetric - theorem from above performed on monadic
  %% calculation rather than nested functions
  antisymmetryMonad: THEOREM
    LET f1:State = modify(1,(LAMBDA (pcr:PCR): extend(pcr,hv0))),
      	f2:State = modify(0,(LAMBDA (pcr:PCR): extend(pcr,hv1))) IN
      hv0/=hv1 =>
      runState(
        f2 >>= (LAMBDA (x:nat): f1 >>= unit))(reset)
      /=
      runState(
        f1 >>= (LAMBDA (x:nat): f2 >>= unit))(reset)

  extendPCR(h:HV):State = modify(1,(LAMBDA (pcr:PCR): extend(pcr,h)))
  resetPCR : State = put(1,reset)
  %% quotePCR :State 

  %% Same proof as above using commands to clean up notation
  antisymmetryMonad2: THEOREM
    LET 
        f1:State = extendPCR(hv0),
      	f2:State = extendPCR(hv1) IN
      hv0/=hv1 =>
      runState(f2 >> f1 >>= unit)(reset) /= runState(f1 >> f2 >>= unit)(reset)

  %% Same proof as above using replaceing let form
  antisymmetryMonad3: THEOREM
    hv0/=hv1 =>
       runState(extendPCR(hv1) >> extendPCR(hv0) >>= unit)(reset) /=
       runState(extendPCR(hv0) >> extendPCR(hv1) >>= unit)(reset)

  %% Prove that reset results in reset
  resetMonad: THEOREM
    LET 
        f1:State = extendPCR(hv0),
      	f2:State = resetPCR IN
      runState(f1 >> f2 >>= unit)(reset) = (1,reset)


  END measurer


