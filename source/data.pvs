%% ----
%%
%% Data Theory
%%
%% Author: Brigid Halling
%% Date: Fri Jan 11 11:11:11 CST 2013
%%
%% Description: 
%% 
%% Dependencies:
%%  pcr.pvs
%%  authdata.pvs
%%  keyData.pvs
%%
%% Todo: (key - => pending, + => done)
%%
%% ----
data [DVAL,HVAL:TYPE+] : THEORY

  BEGIN

  IMPORTING pcr[HVAL];
  IMPORTING authdata;
  IMPORTING keydata;
  IMPORTING types;

  RNG : TYPE = int;

  
  %% Data items that the TPM is aware of
  tpmData : DATATYPE
  BEGIN
    %% Identifyier for naming things
    tpmID(id:string,crs:CRYPTOSTATUS) : tpmID?
    
    %% Stub for migrateScheme so can take digest - createMigBlob	(4.4)
    tpmMigScheme(migScheme:migrateScheme) : tpmMigScheme?

    %% EK type- indicates what type of information the EK's dealing with(4.11)
    tpmEKBlobActivate(sessK:(tpmSessKey?),
	idDigest:(tpmDigest?),
	pcrInfo:(tpmPCRInfoShort?)) : tpmEKBlobActivate?

    %% EK type- indicates what type of information the EK's dealing with(4.11)
    tpmEKBlobAuth(authValue:(tpmSecret?)) : tpmEKBlobAuth?
    
    %% Abitrarily long digest of arbitrary TPM data			(5.4)
    tpmDigest(digest:list[tpmData],crs:CRYPTOSTATUS) : tpmDigest?
    %  tpmDigest is the list of things concatenated and hashed to create the
    %  digest value - #(d0++d1++...++dn).  
    %  Note that this digest does not contain PCRs 

    % TPM_COMPOSITE_HASH should be element of tpmDigest,
    % PCR_COMPOSITE : [#select:PCR_SELECTION,pcrValue:PCRVALUES#]
    tpmCompositeHash(dig:PCR_COMPOSITE) : tpmCompositeHash?

    %% Random value that provides protection from replay.		(5.5)
    tpmNonce(i:int) : tpmNonce?

    %% Authdata - don't know what it is yet				(5.6)
    tpmEncAuth(authData:int,crs:CRYPTOSTATUS) : tpmEncAuth?

    %% Authdata - don't know what it is yet				(5.6)
    tpmSecret(i:int) : tpmSecret?

    %% Provides proof that the associated public key has		(5.12)
    %% TPM Owner AuthData to be a migration key
    tpmMigKeyAuth(key:(tpmKey?),
	scheme:(tpmMigScheme?),
	digest:(tpmDigest?),
	crs:CRYPTOSTATUS) : tpmMigKeyAuth?

    %% Structure signed for certain commands (TPM_ReleaseTransportSigned)(5.14)
%     tpmSignInfo(replay:(tpmNonce?),data:tpmData,crs:CRYPTOSTATUS) : tpmSignInfo?
    %% crs should be signed? %%TODO

    %% Contains an arbitrary number of digests of public keys belonging (5.15)
    %%  to Migration Authorities. An instance is incorporated into the 
    %%  migrationAuth value of a CMK, and any of the Mig Auths specified in 
    %%  that instance is able to approve the migration of that CMK.
    tpmMSAComposite(MSAlist:int,
        migAuthDigest:list[(tpmDigest?)]) : tpmMSAComposite?

    %% Ticket to prove that an entity with pub key "migAuth" has	(5.16)
    %%  has apporved the public key "destination key" as a mig destination
    %%  for the key with pub key "source key". Usu signed by priv "migAuth"
    tpmCMKAuth(migAuth:(tpmDigest?),
        destKey:(tpmDigest?),
        sourceKey:(tpmDigest?),
	crs:CRYPTOSTATUS) : tpmCMKAuth?

    %% Flags that determine how TPM responds to delegated requests	(5.17)
    %%  to manipulate a certified-migration-key...
    tpmCMKDelegate(delegateSigning:bool,
        delegateStorage:bool,
        delegateBind:bool,
        delegateLegacy:bool,
        delegateMigrate:bool) : tpmCMKDelegate?
    
    %% Structure to keep track of CMK migration authorization		(5.19)
    tpmCMKMigAuth(msaDigest:(tpmDigest?),
        pubKeyDigest:(tpmDigest?)) : tpmCMKMigAuth?

    %% Structure to keep track of the CMK migraiton authorization	(5.20)
    tpmCMKSigTicket(verKeyDigest:(tpmDigest?),
        signedData:(tpmDigest?)) : tpmCMKSigTicket?

    %% Structure to keep track of CMK migration authorization		(5.21)
    tpmCMKMAApproval(migAuthDig:(tpmDigest?)) : tpmCMKMAApproval?

    %% PCR Info								(8.4)
    %% TODO: This is only a stub.
    tpmPCRInfoLong(
	  locAtCreation : LOCALITY %loc modifier when blob is created
    	% Loc modifier req to reveal sealed data or use a key wrapped to PCRs
	% Value must not be zero (0)
	, locAtRelease  : LOCALITY
	% Selection of PCRs active when blob is created
	, creationPCRSelect : PCR_SELECTION
	% Selection of PCRs to which the key or data is bound
	, releasePCRSelect  : PCR_SELECTION
	% Composite digest value of the PCR values, when the blob is created
  	, digAtCreation : (tpmCompositeHash?)
	% Digest of PCR indices and values to verify when revealing sealed data 
	% or using a key that was wrapped to PCRs
	, digAtRelease  : (tpmCompositeHash?)
	) : tpmPCRInfoLong?
% TODO: locAtRelease = locality or selection for infoLong and infoShort
  tpmPCRInfoShort(
	  pcrSelect : PCR_SELECTION 
	% Selection of PCRs that specifies the digestAtRelease
	, locAtRelease : LOCALITY_SELECTION    
	% Locality modifier required to release information
	% must not be zero (0)
	, digAtRelease : (tpmCompositeHash?)
	% Digest of PCR indices and PCR values to verify when revealing auth data
	) : tpmPCRInfoShort?


    %% Stored Data - necessary to ensure the enforcement of security
    %% properties (9.2) Used by seal and unseal commands to identify
    %% pcr index and values that must be present to properly unseal
    %% data.
    tpmStoredData(sealInfo:(tpmPCRInfoLong?),
	encData:(tpmSealedData?),
	crs:CRYPTOSTATUS) : tpmStoredData?
		  %% encData is the piece encrypted by the crs.
		  
    %% Sealed Data - contains confidential info related to sealed data	(9.3)
    tpmSealedData(authData:(tpmSecret?),
	tpmProof:(tpmSecret?),
	storedDigest:(tpmDigest?), %TPM_COMPOSITE_HASH?
	data:tpmData,
	crs:CRYPTOSTATUS) : tpmSealedData?
    
    %% Session keys are simply symetric keys				(9.4)
    tpmSessKey(skey:KVAL,crs:CRYPTOSTATUS) : tpmSessKey?
    
    %% Bound data							(9.5)
    tpmBoundData(payloadData:tpmData,crs:CRYPTOSTATUS) : tpmBoundData?

    %% Assymetric keys used by the TPM - wrapped, signed, encrypted	(10.3)
    tpmKey(key:KVAL,
	keyUsage:KEY_USAGE,
	keyFlags:KEY_FLAGS,
	authDataUsage:AUTH_DATA_USAGE,
	algoParms:KEY_PARMS,
	PCRInfo:(tpmPCRInfoLong?),
	wrappingKey:KVAL,
	encDat:(tpmStoreAsymkey?),
	crs:CRYPTOSTATUS) : tpmKey?
    %  tpmKey subsumes all asymmetric keys used by the TPM
    %  encrypted key: tpmKey(k,...,encrypted(public(j),clear))
    %  clear key encrypted with public j
    %  signed/certified key: tpmKey(k,...,signed(private(j),clear))
    %  clear key signed by private j

    %% Pub Key (used for ek, srk?)					(10.5)
    tpmPubkey(pubKey:KVAL):tpmPubkey?
    %TODO IS THIS COMPLETE

    %% Store Asym Key [private key]					(10.6)
    tpmStoreAsymkey(usageAuth:(tpmSecret?),
	migrationAuth:(tpmSecret?),
	pubDataDigest:(tpmDigest?),
	privKey:KVAL,
	crs:CRYPTOSTATUS) : tpmStoreAsymkey?

    %% Migrate Asym Key							(10.8)
    tpmMigrateAsymkey(usageAuth:(tpmSecret?),
	pubDataDigest:(tpmDigest?),
	partPrivKey:KVAL) : tpmMigrateAsymkey?

    %% Certified Key							(11.1)
    tpmCertifyInfo(keyUsage:KEY_USAGE,
	keyFlags:KEY_FLAGS,
	authDataUsage:AUTH_DATA_USAGE,
	algoParms:KEY_PARMS,
	pubkeyDigest:(tpmDigest?),
	data:(tpmNonce?),
	parentPCRStatus:bool,
	PCRInfo:(tpmPCRInfoLong?),
	crs:CRYPTOSTATUS) : tpmCertifyInfo?
    
    %% Certified Key2							(11.2)
    tpmCertifyInfo2(keyUsage:KEY_USAGE,
	keyFlags:KEY_FLAGS,
	authDataUsage:AUTH_DATA_USAGE,
	algoParms:KEY_PARMS,
	pubkeyDigest:(tpmDigest?),
	data:(tpmNonce?),
	parentPCRStatus:bool,
	PCRInfo:(tpmPCRInfoLong?),
	migAuth:(tpmDigest?),
	crs:CRYPTOSTATUS) : tpmCertifyInfo2?

    %% Quote including a PCR digest and nonce.				(11.3)
    tpmQuote(digest:(tpmCompositeHash?),
	externalData:(tpmNonce?),
	crs:CRYPTOSTATUS) : tpmQuote?
    %  PCRs are not current TPM data, so the digest is over PCR values.
    
    %% Quote the current values of a list of PCRs			(11.4)
    tpmQuote2(infoShort:(tpmPCRInfoShort?),
	externalData:(tpmNonce?),
	crs:CRYPTOSTATUS) : tpmQuote2?
    
    %% Provides wrapper to each type of structure that will be in use when(12.1)
    %% EK is in use
    tpmEKBlob(blob:tpmData,crs:CRYPTOSTATUS) : tpmEKBlob?
    %% blob must be tpmEKBlobAuth or tpmEKBlobActivate

    %% Certification request sent to Privacy CA				(12.5)
    tpmIdContents(digest:(tpmDigest?),
	aik:(tpmKey?),
	crs:CRYPTOSTATUS) : tpmIdContents?
    %  digest should contain CA public key, name, and AIK
    
    %% Contains symmetric key to encrypt the identity credential	(12.8)
    tpmAsymCAContents(sessK:(tpmSessKey?),
	idDigest:(tpmDigest?),
	crs:CRYPTOSTATUS) : tpmAsymCAContents?

    %% tpmFullQuote(cert:(tpmCertKey?),sml:list[HVAL],quote:(tpmQuote?)):tpmFullQuote?
    %  Implement as tpmAbsOutput
    %  cert is a certified key and should be checked with certKey?
    %  SML is the stored measurement list
    %  Quote is the signed quote generated by the TPM
    %  This is simply a triple represented below    

    tpmXOR(a:tpmData,b:RNG,crs:CRYPTOSTATUS) : tpmXOR?
    OAEP(m:(tpmMigrateAsymkey?),pHash:tpmData,seed:KVAL) : OAEP?
    concat(f:tpmData,s:tpmData) : concat?


  END tpmData;

  
  activateIdentityBlob?(blob:tpmData) : bool =
  CASES blob OF
    tpmEKBlob(b,c) : TRUE,
    tpmAsymCAContents(k,d,c) : TRUE
    ELSE FALSE
  ENDCASES

  tpmAuthData?(blob:tpmData) : bool =
  CASES blob OF
    tpmSecret(i) : TRUE,
    tpmEncAuth(i,c) : TRUE
    ELSE FALSE
  ENDCASES
  
  authIn:TYPE = [# authHandle : (tpmAuthData?)
  	      	 , authLastNonceEven : (tpmNonce?)
	      	 , nonceOdd : (tpmNonce?)
	      	 , contAuthSess : bool
	      	 , ownerAuth : (tpmAuthData?)%parentAuth
	      	#];

  authOut:TYPE = [# nonceEven : (tpmNonce?)
	      	  , nonceOdd : (tpmNonce?)
	      	  , contAuthSess : bool
	      	  , resAuth : (tpmAuthData?)
	      	 #];

  tpmNull : (tpmSealedData?)
  tpmNonceZero : (tpmNonce?)
  EVEN:(tpmNonce?)
  ODD:(tpmNonce?)
  pcrInfoLongDefault : (tpmPCRInfoLong?)
  pcrInfoNull : (tpmPCRInfoLong?)
  storeAsymkeyDefault : (tpmStoreAsymkey?)
  tpmCMKDelegateDefault  : (tpmCMKDelegate?) = 
    tpmCMKDelegate(false,false,false,false,false);
  %PermData
  nonceInit:(tpmNonce?)
  INVALIDPROOF:nat
  INVALIDAUTH:nat
  invalidAuth?(s:(tpmSecret?)) : bool = 
    i(s)=INVALIDAUTH
  
  % Decrypting encAuth according to the ADIP indicated by authHandle
  % TODO: where is ADIP indicated by authHandle?
  % TPM_AUTHHANDLE is handle to an authorization session 4.1? 4.3? 5.6, 5.9, 
  % Read Ryan's paper
  % has session type. hmac?
  decryptADIP(enc:(tpmEncAuth?),authHand:(tpmAuthData?)) : (tpmSecret?) =
    tpmSecret(authData(enc));
	
  encryptADIP(auth:(tpmAuthData?)) : (tpmEncAuth?) = 
    LET i=CASES auth OF
    		tpmSecret(a) : a,
		tpmEncAuth(a,c) : a 
	  ENDCASES IN
    tpmEncAuth(i,clear);

END data
