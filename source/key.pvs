%% ----
%%
%% Key Theory
%%
%% Author: Perry Alexander
%% Date: Mon Jan 16 15:26:29 CST 2012
%%
%% Description: Basic model of keys, encryption, decryption, and signing
%% 
%% Dependencies:
%%  None
%%
%% Todo: (key - => pending, + => done)
%%  + Add key sets
%%  + Add key installation and revocation from sets
%%  - Add regression tests for key installation and revocation functions
%% ----
key [DVAL,KVAL,HVAL:TYPE+] : THEORY

  BEGIN

  IMPORTING pcr[HVAL];
  IMPORTING ReturnCodes;
  
  KEY_USAGE : DATATYPE
  BEGIN
    signing : signing?
    storage : storage?
    identity : identity?
    authChange : authChange?
    bind : bind?
    legacy : legacy?
    migrate : migrate?
  END KEY_USAGE;

  KEY_FLAGS : TYPE = [#
  	      	     redirection : bool,
		     migratable : bool,
		     isVolatile : bool,
		     pcrIgnoredOnRead : bool,
		     migrateAuthority : bool
  	      	     #];
  keyFlagsF : KEY_FLAGS = (#
  	     redirection:= false,
     	     migratable := false,
	     isVolatile := false,
	     pcrIgnoredOnRead := false,
	     migrateAuthority := false #)
  	     

  migrateScheme : DATATYPE
  BEGIN 
    migrate : migrate?
    rewrap : rewrap?
  END migrateScheme;

  KEY : DATATYPE
  BEGIN
    invalidKey : invalidKey?
    symKey(skey:KVAL) : symKey?
    asymKey(askey:KVAL,keyUsage:KEY_USAGE,keyFlags:KEY_FLAGS) : asymKey?
  END KEY;		

  % This is odd, but it seems to work out okay.
  private(k:(asymKey?)):(asymKey?)
  public(k:(asymKey?)):(asymKey?)
  
  CRYPTOSTATUS : DATATYPE
  BEGIN
    clear : clear?
    encrypted(key:(asymKey?),crstat:CRYPTOSTATUS) : encrypted?
    signed(key:(asymKey?),crstat:CRYPTOSTATUS) : signed?
    wrapped(key:(asymKey?),crstat:CRYPTOSTATUS,pcrs:PCRS) : wrapped?
    sealed(key:(asymKey?),crstat:CRYPTOSTATUS,pcrs:PCRS) : sealed?
  END CRYPTOSTATUS;

  tpmData : DATATYPE
  BEGIN
    outNothing(m:ReturnCode) : outNothing?
    tpmQuote(nonce:nat,pcrs:list[PCR],crs:CRYPTOSTATUS,m:ReturnCode) : tpmQuote?
    %% tpmBlob - Is gone
    tpmSymKey(key:(symKey?),crs:CRYPTOSTATUS,m:ReturnCode) : tpmSymKey?
    %% tpmKey subsumes all key outputs
    tpmKey(key:(asymKey?),crs:CRYPTOSTATUS,m:ReturnCode) : tpmKey?
    %  wrapped key: tpmKey(child,wrapped(public(parent),clear,pcrs))
    %  clear child wrapped by parent bound to PCRs
    %  unwrapped key: tpmKey(k,clear)
    %  clear key
    %  encrypted key: tpmKey(k,encrypted(public(j),clear))
    %  clear key encrypted with public j
    %  signed key: tpmKey(k,signed(private(j),clear))
    %  clear key signed by private j
    %% tpmCertKey(aik:(tpmKey?),crs:CRYPTOSTATUS,m:ReturnCode):tpmCertKey?
    %  tpmCertKey is simply a signed key.  In this case, signed by SRK as in
    %  tpmKey(aik,signed(private(srk(s)),clear))
    %  tpmCertKey is gone
%     tpmChosenIdHash(label:):tpmChosenIdHash?
%     tpmIdentityContents(labelPrivCAdigest:(tpmChosenIdHash?),identityPubKey:tpmKey):tpmIdentity?
%     tpmIdentity(identityBinding:(tpmIdentityContents?),idKey:tpmKey,crs:CRYPTOSTATUS,m:ReturnCode):tpmIdentity?

    %  certAIK is a cert req and should be checked with certKey?
    %  certEK is the signed public ek
    %  This is simply a pair represented below
    %% tpmFullQuote(cert:(tpmCertKey?),sml:list[HVAL],quote:(tpmQuote?)):tpmFullQuote?
    %  cert is a certified key and should be checked with certKey?
    %  SML is the stored measurement list
    %  Quote is the signed quote generated by the TPM
    %  This is simply a triple represented below
    tpmSealedData(data:tpmData,crs:CRYPTOSTATUS,m:ReturnCode) : tpmSealedData?
    tpmBoundData(data:tpmData,crs:CRYPTOSTATUS,m:ReturnCode) : tpmBoundData?
    tpmChosenIDHash(idLabel:string,privacyCA:(asymKey?)) : tpmChosenIDHash?
    tpmIdentityContents(labelPrivCADigest:(tpmChosenIDHash?),idPubKey:(tpmKey?),crs:CRYPTOSTATUS) : tpmIdentityContents?
    tpmIdentity(idKey:(tpmKey?),idBinding:(tpmIdentityContents?),crs:CRYPTOSTATUS,m:ReturnCode) : tpmIdentity?
  END tpmData;

  %% Basic crypto functions.  xStatus functions operate on status
  %% indicators while x functions operate on tpmData.  Need to account
  %% for private and public keys in this, but the basic process seems to be
  %% there.
  encryptStatus(k:(asymKey?),c:CRYPTOSTATUS) : (encrypted?) =
    encrypted(k,c);

  encrypt(k:(asymKey?),d:tpmData) : tpmData =
    CASES d OF 
      tpmQuote(n0,p0,crs0,m0) : tpmQuote(n0,p0,encryptStatus(k,crs0),m0),
      tpmKey(k0,crs0,m0) : tpmKey(k0,encryptStatus(k,crs0),m0),
      tpmSymKey(k0,crs0,m0) : tpmSymKey(k0,encryptStatus(k,crs0),m0)
    ENDCASES;

  decryptStatus(k:(asymKey?),c:(encrypted?)) : CRYPTOSTATUS =
    IF key(c) = k THEN crstat(c) ELSE c ENDIF;

  decrypt(k:(asymKey?),d:tpmData) : tpmData =
    CASES d OF
      tpmQuote(n0,p0,crs0,m0) : IF encrypted?(crs0)
      			        THEN tpmQuote(n0,p0,decryptStatus(k,crs0),m0)
				ELSE d
				ENDIF,
      tpmKey(k0,crs0,m0) : IF encrypted?(crs0)
                           THEN tpmKey(k0,decryptStatus(k,crs0),m0)
			   ELSE d
			   ENDIF,
      tpmSymKey(k0,crs0,m0) : IF encrypted?(crs0)
      			      THEN tpmSymKey(k0,decryptStatus(k,crs0),m0)
			      ELSE d
			      ENDIF
    ENDCASES;

  decrypt_encrypt : THEOREM FORALL (k:(asymKey?),c:CRYPTOSTATUS) : 
    decryptStatus(k,encryptStatus(k,c)) = c;

  signStatus(k:(asymKey?),c:CRYPTOSTATUS) : (signed?) =
    signed(k,c);

  sign(k:(asymKey?),d:tpmData) : tpmData =
    CASES d OF 
      tpmQuote(n0,p0,crs0,m0) : tpmQuote(n0,p0,signStatus(k,crs0),m0),
      tpmKey(k0,crs0,m0) : tpmKey(k0,signStatus(k,crs0),m0),
      tpmSymKey(k0,crs0,m0) : tpmSymKey(k0,signStatus(k,crs0),m0)
    ENDCASES;


  checkSigStatus(k:(asymKey?),c:CRYPTOSTATUS) : bool =
    CASES c OF
      signed(kq,cq) : k = kq
      ELSE FALSE
    ENDCASES;

  checkSig(k:(asymKey?),d:tpmData) : bool =
    CASES d OF
      tpmQuote(n0,p0,crs0,m0) : IF signed?(crs0)
      			        THEN checkSigStatus(k,crs0)
				ELSE FALSE
				ENDIF,
      tpmKey(k0,crs0,m0) : IF signed?(crs0)
                           THEN checkSigStatus(k,crs0)
			   ELSE FALSE
			   ENDIF,
      tpmSymKey(k0,crs0,m0) : IF signed?(crs0)
                              THEN checkSigStatus(k,crs0)
			      ELSE FALSE
			      ENDIF
    ENDCASES;

  check_sign : THEOREM FORALL (k:(asymKey?),c:CRYPTOSTATUS) : 
    checkSigStatus(k,signStatus(k,c));

  % Predicate subtype for a certified key.  Key may be clear or wrapped.
  certKey?(r:tpmData):bool =
  CASES r OF
    tpmKey(k0,crs0,m0) : CASES crs0 OF
                           signed(k1,csr1) : clear?(csr1) OR wrapped?(csr1)
			   ELSE FALSE
			 ENDCASES
    ELSE FALSE
  ENDCASES;

  % Predicate subtype for a wrapped key.  Wrapped key must be clear
  wrapKey?(k:tpmData):bool =
  CASES k OF
    tpmKey(k0,crs0,m0) : CASES crs0 OF 
                           wrapped(k1,csr1,p1) : clear?(csr1)
			   ELSE FALSE
			 ENDCASES
    ELSE FALSE
  ENDCASES;

  %% Accessors for wrapped key elements
  childKey(k:(wrapKey?)):(asymKey?) = key(k)

  parentKey(k:(wrapKey?)):(asymKey?) = key(crs(k))

  %% Data structures used in identity establishment.
  %% An identity is a pair of keys signed by the same k.  First key is
  %% the certified AIK and the second is the EK
  identity?(id:[(certKey?),(certKey?)]):bool = 
    LET (aik,ek) = id IN
      EXISTS (k:(asymKey?)) : checkSig(k,aik) AND checkSig(k,ek)

  %% A full quote is a pair one key and a TPM quote both signed by the
  %% same k.
  fullQuote?(q:[(certKey?),(tpmQuote?)]):bool =
    LET (ck,tpmq) = q IN
      EXISTS (k:(asymKey?)) : checkSig(k,ck) AND checkSig(k,tpmq)
        
  %% Check a TPM quote
  checkQuote(q:(tpmQuote?),k:(asymKey?),p:list[PCR],n:nat):bool =
    checkSig(k,q) AND nonce(q)=n AND pcrs(q)=p;

  %% Check a Full Quote using signed AIK. Check AIK against known
  %% public(CA) and check the TPM quote against AIK and expected values
  checkFullQuote(q:(fullQuote?),ca:(asymKey?),p:list[PCR],n:nat):bool =
    LET (aik,tpmq) = q IN
      checkSig(ca,aik) AND checkQuote(tpmq,key(aik),p,n);

  %% Removed the wrapKey type in favor of the (wrapKey?) subtype that can
  %% be applied to tpmKey.
  % wrapKey : TYPE = [#
  % 	    	   parentKey:(asymKey?),
  % 		   childKey:(asymKey?)
  % 		   #]; 


  %% This theorem does NOT say that the private key of a private key is
  %% a key.  It says that everything - signing and encrypting - can be done
  %% in reverse if you swap the keys around.

  double_private: AXIOM FORALL (k:(asymKey?)) : private(private(k))=k;

  %% Basic blob types - data, keys, hashs, encrypted blobs, signed blobs
  %% Blobs in this context are things that can be encrypted or signed
  %% Note that encrypted and signed things can be encrypted and signed

  BLOB : DATATYPE
  BEGIN
    nothing : nothing?
    keyBlob(key:KEY) : keyBlob?
    hashBlob(h:HVAL) : hashBlob?
    encryptBlob(key:KEY,blob:BLOB) : encryptBlob?
    signBlob(key:KEY,blob:BLOB) : signBlob?
    sealBlob(key:KEY,pcrs:PCRS,blob:BLOB) : sealBlob?
    certBlob(encrKey:KEY,digest:(asymKey?),symK:(symKey?)) : certBlob?
%     certBlob(key:KEY,wkey:wrapKey) : certBlob?
    pairBlob(left,right : BLOB) : pairBlob?
    migrationBlob(rand:int,outData:(encryptBlob?)):migrationBlob?%%TODO: types may not be correct
  END BLOB;

  %% Decryption for specific key types.  Key types not matching automatically
  %% is a failure
  decryptSym(b:(encryptBlob?),k:(symKey?)):BLOB =
    IF symKey?(key(b)) AND symKey?(k) AND key(b) = k
       THEN blob(b)
       ELSE nothing
    ENDIF;

  decryptAsym(b:(encryptBlob?),k:(asymKey?)):BLOB =
    IF asymKey?(key(b)) AND asymKey?(k) AND key(b) = private(k)
       THEN blob(b)
       ELSE nothing
    ENDIF;

  
  %% Decryption for all key types
  decrypt(b:(encryptBlob?),k:KEY):BLOB = 
    CASES k OF 
      invalidKey : nothing,
      symKey(k0) : decryptSym(b,k),
      asymKey(k0,u,f) : decryptAsym(b,k)
  ENDCASES;

  %% Unseal for aysmetric keys
  unseal(b:(sealBlob?),pcrs:PCRS,k:(asymKey?)):BLOB =
    IF pcrs(b) = pcrs AND key(b)=private(k)
       THEN blob(b)
       ELSE nothing
    ENDIF;

  %% Signature check for specific key types
  %% This could (and should) be implemented with decryption function
  sigCheckSym(b:(signBlob?),k:(symKey?)):boolean =
    symKey?(key(b)) AND symKey?(k) AND key(b) = k;

  sigCheckAsym(b:(signBlob?),k:(asymKey?)):boolean =
    asymKey?(key(b)) AND asymKey?(k) AND key(b) = private(k);


  %% Signature checking for all keys
  sigCheck(b:(signBlob?),k:KEY):boolean =
    CASES k OF
      invalidKey : FALSE,
      symKey(k0) : sigCheckSym(b,k),
      asymKey(k0,u,f) : sigCheckAsym(b,k)
    ENDCASES;

  %% A keyset is simply a set of asymmetric keys
  KEYSET : TYPE = set[(asymKey?)];

  %% Check against the root key passed in as rk
  checkKeyRoot(k:(wrapKey?),rk:(asymKey?)):bool =
    parentKey(k)=rk;

  %% Check against the set of installed keys and the root key
  checkKey(k:(asymKey?),rk:(asymKey?),ks:KEYSET):bool =
    member(k,ks) OR k=rk;

  %% Add a key to a set of it checks out
  addKey(k:(wrapKey?),rk:(asymKey?),ks:KEYSET):KEYSET =
    IF checkKey(parentKey(k),rk,ks)
    THEN add(childKey(k),ks)
    ELSE ks
    ENDIF;

  %% Remove a key - this is not currently used
  removeKey(k:(wrapKey?),ks:KEYSET):KEYSET =
    remove(childKey(k),ks);

  %% Lemmas

  %% Regression Theorems

  %% Signature checks
  
  test0: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0=k1 IFF sigCheck(signBlob(k0,b),k1);

  test1: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    private(k0)=k1 IFF sigCheck(signBlob(k0,b),k1);

  %% Decryption

  test2: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0=k1 IMPLIES decrypt(encryptBlob(k0,b),k1) = b;

  test3: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    k0=k1 IMPLIES decrypt(encryptBlob(k0,b),private(k1)) = b;

  test4: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0/=k1 IMPLIES decrypt(encryptBlob(k0,b),k1) = nothing;

  test5: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    k0/=k1 IMPLIES decrypt(encryptBlob(k0,b),private(k1)) = nothing;

  %% Key installation

  test6: THEOREM FORALL (k:(wrapKey?),rk:(asymKey?),ks:KEYSET) : 
    IF member(parentKey(k),ks) OR parentKey(k)=rk
       THEN member(childKey(k),addKey(k,rk,ks))
       ELSE ks=addKey(k,rk,ks)
    ENDIF;

  test7: THEOREM FORALL (k:(wrapKey?),rk:(asymKey?),ks:KEYSET) :
    NOT(member(childKey(k),removeKey(k,ks)));

END key
