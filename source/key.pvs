%% ----
%%
%% Key Theory
%%
%% Author: Perry Alexander
%% Date: Mon Jan 16 15:26:29 CST 2012
%%
%% Description: Basic model of keys, encryption, decryption, and signing
%% 
%% Dependencies:
%%  None
%%
%% Todo: (key - => pending, + => done)
%%  + Add key sets
%%  + Add key installation and revocation from sets
%%  - Add regression tests for key installation and revocation functions
%% ----
key [DVAL,KVAL,HVAL:TYPE+] : THEORY

  BEGIN

  %%ASSUMING
  %%ENDASSUMING

  %% Basic key types - symmetric, assymetric, wrapped - built with key values
  %% Note that KVAL is completely uninterpretted at this point
  IMPORTING pcr[HVAL];
  
  AUTHDATA : TYPE = string
  
  KEY : DATATYPE
  BEGIN
    invalidKey : invalidKey?
    symKey(skey:KVAL) : symKey?
    asymKey(askey:KVAL) : asymKey?
  END KEY;		

  private(k:(asymKey?)):(asymKey?)

  wrapKey : TYPE = [#
  	    	   parentKey:(asymKey?),
		   childKey:(asymKey?)
  		   #]; 


  %% This theorem does NOT say that the private key of a private key is
  %% a key.  It says that everything - signing and encrypting - can be done
  %% in reverse if you swap the keys around.

  double_private: AXIOM FORALL (k:(asymKey?)) : private(private(k))=k;

  %% Basic blob types - data, keys, hashs, encrypted blobs, signed blobs
  %% Blobs in this context are things that can be encrypted or signed
  %% Note that encrypted and signed things can be encrypted and signed

  BLOB : DATATYPE
  BEGIN
    nothing : nothing?
    keyBlob(key:KEY) : keyBlob?
    hashBlob(h:HVAL) : hashBlob?
    encryptBlob(key:KEY,blob:BLOB) : encryptBlob?
    signBlob(key:KEY,blob:BLOB) : signBlob?
    sealBlob(key:KEY,pcrs:PCRS,blob:BLOB) : sealBlob?
    certBlob(key:KEY,wkey:wrapKey) : certBlob?
    %certBlob(key:KEY,blob:BLOB) : certBlob?
    pairBlob(left,right : BLOB) : pairBlob?
  END BLOB;

  %% Decryption for specific key types.  Key types not matching automatically
  %% is a failure
  decryptSym(b:(encryptBlob?),k:(symKey?)):BLOB =
    IF symKey?(key(b)) AND symKey?(k) AND key(b) = k
       THEN blob(b)
       ELSE nothing
    ENDIF;

  decryptAsym(b:(encryptBlob?),k:(asymKey?)):BLOB =
    IF asymKey?(key(b)) AND asymKey?(k) AND key(b) = private(k)
       THEN blob(b)
       ELSE nothing
    ENDIF;

  
  %% Decryption for all key types
  decrypt(b:(encryptBlob?),k:KEY):BLOB = 
    CASES k OF 
      invalidKey : nothing,
      symKey(k0) : decryptSym(b,k),
      asymKey(k0) : decryptAsym(b,k)
  ENDCASES;

  %% Unseal for aysmetric keys
  unseal(b:(sealBlob?),pcrs:PCRS,k:(asymKey?)):BLOB =
    IF pcrs(b) = pcrs AND key(b)=private(k)
       THEN blob(b)
       ELSE nothing
    ENDIF;

  %% Signature check for specific key types
  %% This could (and should) be implemented with decryption function
  sigCheckSym(b:(signBlob?),k:(symKey?)):boolean =
    symKey?(key(b)) AND symKey?(k) AND key(b) = k;

  sigCheckAsym(b:(signBlob?),k:(asymKey?)):boolean =
    asymKey?(key(b)) AND asymKey?(k) AND key(b) = private(k);


  %% Signature checking for all keys
  sigCheck(b:(signBlob?),k:KEY):boolean =
    CASES k OF
      invalidKey : FALSE,
      symKey(k0) : sigCheckSym(b,k),
      asymKey(k0) : sigCheckAsym(b,k)
    ENDCASES;

  %% A keyset is simply a set of asymetric keys
  KEYSET : TYPE = set[(asymKey?)];

  %% Check against the root key passed in as rk
  checkKeyRoot(k:wrapKey,rk:(asymKey?)):bool =
    parentKey(k)=rk;

  %% Check against the set of installed keys and the root key
  checkKey(k:(asymKey?),rk:(asymKey?),ks:KEYSET):bool =
    member(k,ks) OR k=rk;

  %% Add a key to a set of it checks out
  addKey(k:wrapKey,rk:(asymKey?),ks:KEYSET):KEYSET =
    IF checkKey(parentKey(k),rk,ks)
    THEN add(childKey(k),ks)
    ELSE ks
    ENDIF;

  %% Remove a key - this is not currently used
  removeKey(k:wrapKey,ks:KEYSET):KEYSET =
    remove(childKey(k),ks);

  %% Lemmas

  %% Regression Theorems

  %% Signature checks
  
  test0: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0=k1 IFF sigCheck(signBlob(k0,b),k1);

  test1: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    private(k0)=k1 IFF sigCheck(signBlob(k0,b),k1);

  %% Decryption

  test2: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0=k1 IMPLIES decrypt(encryptBlob(k0,b),k1) = b;

  test3: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    k0=k1 IMPLIES decrypt(encryptBlob(k0,b),private(k1)) = b;

  test4: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0/=k1 IMPLIES decrypt(encryptBlob(k0,b),k1) = nothing;

  test5: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    k0/=k1 IMPLIES decrypt(encryptBlob(k0,b),private(k1)) = nothing;

  %% Key installation

  test6: THEOREM FORALL (k:wrapKey,rk:(asymKey?),ks:KEYSET) : 
    IF member(parentKey(k),ks) OR parentKey(k)=rk
       THEN member(childKey(k),addKey(k,rk,ks))
       ELSE ks=addKey(k,rk,ks)
    ENDIF;

  test7: THEOREM FORALL (k:wrapKey,rk:(asymKey?),ks:KEYSET) :
    NOT(member(childKey(k),removeKey(k,ks)));

END key
