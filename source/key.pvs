%% ----
%%
%% Key Theory
%%
%% Author: Perry Alexander
%% Date: Mon Jan 16 15:26:29 CST 2012
%%
%% Description: Basic model of keys, encryption, decryption, and signing
%% 
%% Dependencies:
%%  None
%%
%% Todo: (key - => pending, + => done)
%%
%% ----
key [DVAL,HVAL:TYPE+] : THEORY

  BEGIN

  IMPORTING pcr[HVAL];
  IMPORTING ReturnCodes;
  
  AUTHDATA : TYPE = string;
  KEYDATA : TYPE;
  
  %% Keys are integers.
  KVAL : TYPE = integer;

  %% The inverse of a key its negation
  inverse(k:KVAL):KVAL = -k;

  %% The bad key value is 0
  badkey:KVAL = 0;

  %% Purpose for key
  KEY_USAGE : DATATYPE
  BEGIN
    signing : signing?
    storage : storage?
    identity : identity?
    authChange : authChange?
    bind : bind?
    legacy : legacy?
    migrate : migrate?
  END KEY_USAGE;

  %% Flags for defining key properties
  KEY_FLAGS : TYPE = [#
  	      	     redirection : bool, 
		     migratable : bool,
		     isVolatile : bool,
		     pcrIgnoredOnRead : bool,
		     migrateAuthority : bool
  	      	     #];

  %% All key flags false
  keyFlagsF : KEY_FLAGS = (#
  	     redirection:= false,
     	     migratable := false,
	     isVolatile := false,
	     pcrIgnoredOnRead := false,
	     migrateAuthority := false #)
  	     

  %% Migragion scheme indicator
  migrateScheme : DATATYPE
  BEGIN 
    migrate : migrate?
    rewrap : rewrap?
  END migrateScheme;

  %% Base key type for symmetric and asymmetric keys
  KEY : DATATYPE
  BEGIN
    symKey(skey:KVAL) : symKey?
    asymKey(askey:KVAL) : asymKey?
  END KEY;		

  %% Any key with key value 0 is invalid.
  invalidKey?(k:KEY):bool =
    CASES k OF
      symKey(k0) : k0=0,
      asymKey(k0) : k0=0
    ENDCASES;

  %% Define private and public key accessors for asymKey?. The publid
  %% key is askey while the private key is -askey.  Note that private
  %% is no longer closed under (asymKey?)
  private(k:(asymKey?)):KVAL = inverse(askey(k))
  public(k:(asymKey?)):KVAL = askey(k)

  %% Some theorems about key inverse, private and public.

  %% The inverse key of the inverse key is the original key
  double_inverse: THEOREM FORALL (k:KVAL) : inverse(inverse(k))=k;

  %% the inverse of a private key is the public key for the same
  %% asymmetric key.
  inverse_private: THEOREM FORALL (k:(asymKey?)) :
    inverse(private(k))=public(k);

  %% visa versa                                                         
  inverse_public: THEOREM FORALL (k:(asymKey?)) :
    inverse(public(k))=private(k);

  %% If private keys are equal, asymmetric keys are equal
  equal_private: THEOREM FORALL (k0,k1:(asymKey?)) :
    private(k0) = private(k1) <=> k0=k1;

  %% if public keys are equal, asymmetric keys are equal
  equal_public: THEOREM FORALL (k0,k1:(asymKey?)) :
    public(k0) = public(k1) <=> k0=k1;


  %% Type indicating crypographic status - clear, encrypted, signed, wrapped,
  %% sealed.  Type is recursive allowing multiple operations on the same
  %% element.
  CRYPTOSTATUS : DATATYPE
  BEGIN
    clear : clear?
    encrypted(key:KVAL,crstat:CRYPTOSTATUS) : encrypted?
    signed(key:KVAL,crstat:CRYPTOSTATUS) : signed?
    wrapped(key:KVAL,crstat:CRYPTOSTATUS,digest:PCRS) : wrapped?
    sealed(key:KVAL,crstat:CRYPTOSTATUS,digest:PCRS) : sealed?
  END CRYPTOSTATUS;

  %% Data items that the TPM is aware of
  tpmData : DATATYPE
  BEGIN
    %% Identifyier for naming things
    tpmID(id:string,crs:CRYPTOSTATUS) : tpmID?

    %% Authdata - don't know what it is yet
    tpmAuthData(authdata:AUTHDATA,crs:CRYPTOSTATUS) : tpmAuthData?

    %% Nonce value.
    tpmNonce : tpmNonce?

    %% Session keys are simply symetric keys
    tpmSessKey(skey:(symKey?),crs:CRYPTOSTATUS) : tpmSessKey?

    %% Assymetric keys used by the TPM - wrapped, signed, encrypted
    tpmKey(key:(asymKey?),
	   keyUsage:KEY_USAGE,
	   keyFlags:KEY_FLAGS,
	   PCRInfo:PCRS,
	   crs:CRYPTOSTATUS) : tpmKey?
    %  tpmKey subsumes all asymmetric keys used by the TPM
    %  wrapped key: tpmKey(child,wrapped(public(parent),clear,pcrs))
    %  clear child wrapped by parent bound to PCRs
    %  unwrapped asymmetric key: tpmKey(k,clear)
    %  clear key
    %  encrypted key: tpmKey(k,encrypted(public(j),clear))
    %  clear key encrypted with public j
    %  signed/certified key: tpmKey(k,signed(private(j),clear))
    %  clear key signed by private j

    %% Abitrarily long digest of arbitrary TPM data
    tpmDigest(digest:list[tpmData],crs:CRYPTOSTATUS) : tpmDigest?
    %  tpmDigest is the list of things concatenated and hashed to create the
    %  digest value - #(d0++d1++...++dn).  Note that this digest does not
    %  contain PCRs

    %%  Quote including a PCR digest and nonce.
    tpmQuote(digest:list[PCR],nonce:(tpmNonce?),crs:CRYPTOSTATUS) : tpmQuote?
    %  PCRs are not current TPM data, so the digest is over PCR values.

    %% Certification request sent to Privacy CA
    tpmIdContents(digest:(tpmDigest?),aik:(tpmKey?),crs:CRYPTOSTATUS) : tpmIdContents?
    %  digest should contain CA public key, name, and AIK
    
    %% Migration authorization data
    tpmMigKeyAuth(key:(tpmKey?),scheme:migrateScheme,digest:(tpmDigest?),
                  crs:CRYPTOSTATUS) : tpmMigKeyAuth?
  END tpmData;
  
  %% Basic crypto functions.  xStatus functions operate on status
  %% indicators while x functions operate on tpmData.  Users need only
  %% call encrypt, decrypt, sign, checkSig and friends

  % Data Encryption

  encryptStatus(k:KVAL,c:CRYPTOSTATUS) : (encrypted?) =
    encrypted(k,c);

  encrypt(k:KVAL,d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,encryptStatus(k,crs0)),
      tpmAuthData(authdata0,crs0) :
        tpmAuthData(authdata0,encryptStatus(k,crs0)),
      tpmSessKey(k0,crs0) :
        tpmSessKey(k0,encryptStatus(k,crs0)),
      tpmKey(k0,u0,f0,p0,crs0) :
        tpmKey(k0,u0,f0,p0,encryptStatus(k,crs0)),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,encryptStatus(k,crs0)),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,encryptStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,encryptStatus(k,crs0)),
      tpmNonce : tpmNonce,
      tpmMigKeyAuth(k0,s0,d0,crs0) : 
        tpmMigKeyAuth(k0,s0,d0,encryptStatus(k,crs0))
    ENDCASES;

  % Data decryption

  decryptStatus(k:KVAL,c:(encrypted?)) : CRYPTOSTATUS =
    IF k = inverse(key(c)) THEN crstat(c) ELSE c ENDIF;

  decrypt(k:KVAL,d:tpmData) : tpmData =
    CASES d OF
      tpmID(id0,crs0) : IF encrypted?(crs0)
                           THEN tpmID(id0,decryptStatus(k,crs0))
			   ELSE d	
			   ENDIF,
      tpmAuthData(authdata0,crs0) :
        IF encrypted?(crs0)
        THEN tpmAuthData(authdata0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmSessKey(k0,crs0) : IF encrypted?(crs0)
                           THEN tpmSessKey(k0,decryptStatus(k,crs0))
			   ELSE d
			   ENDIF,
      tpmKey(k0,u0,f0,p0,crs0) : 
      	IF encrypted?(crs0)
      	THEN tpmKey(k0,u0,f0,p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmDigest(digest0,crs0) :
        IF encrypted?(crs0)
        THEN tpmDigest(digest0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmQuote(n0,p0,crs0) :
        IF encrypted?(crs0)
        THEN tpmQuote(n0,p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmIdContents(digest0,aik0,crs0) :
        IF encrypted?(crs0)
        THEN tpmIdContents(digest0,aik0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF,
      tpmNonce : tpmNonce,
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        IF encrypted?(crs0)
        THEN tpmMigKeyAuth(k0,s0,d0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF
    ENDCASES;

  % Lemmas on decryption and encryption

  decrypt_encrypt : THEOREM FORALL (k:KVAL,c:CRYPTOSTATUS) : 
    decryptStatus(inverse(k),encryptStatus(k,c)) = c;

  decrypt_equal_keys: THEOREM FORALL (k0,k1:KVAL,b:CRYPTOSTATUS) :
    k0=k1 IMPLIES decryptStatus(inverse(k1),encryptStatus(k0,b)) = b;

  no_decrypt_unequal_keys: THEOREM FORALL (k0,k1:KVAL,b:CRYPTOSTATUS) :
    k0/=k1 IMPLIES decryptStatus(inverse(k1),encryptStatus(k0,b)) = encryptStatus(k0,b)

  % Data signing

  signStatus(k:KVAL,c:CRYPTOSTATUS) : (signed?) =
    signed(k,c);

  sign(k:KVAL,d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,signStatus(k,crs0)),
      tpmAuthData(authdata0,crs0) :
        tpmAuthData(authdata0,signStatus(k,crs0)),
      tpmSessKey(k0,crs0) :
        tpmSessKey(k0,signStatus(k,crs0)),
      tpmKey(k0,u0,f0,p0,crs0) :
        tpmKey(k0,u0,f0,p0,signStatus(k,crs0)),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,signStatus(k,crs0)),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,signStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,signStatus(k,crs0)),
      tpmNonce : tpmNonce,
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        tpmMigKeyAuth(k0,s0,d0,signStatus(k,crs0))
    ENDCASES;

  % Data signature checking

  checkSigStatus(k:(asymKey?),c:CRYPTOSTATUS) : bool =
    CASES c OF
      signed(kq,cq) : private(k) = kq
      ELSE FALSE
    ENDCASES;

  checkSig(k:(asymKey?),d:tpmData) : bool =
    CASES d OF
      tpmID(id0,crs0) : IF signed?(crs0) 
                           THEN checkSigStatus(k,crs0)
			   ELSE FALSE
			   ENDIF,
      tpmAuthData(authdata0,crs0) : IF signed?(crs0) 
                           THEN checkSigStatus(k,crs0)
			   ELSE FALSE
			   ENDIF,
      tpmSessKey(k0,crs0) : IF signed?(crs0)
                           THEN checkSigStatus(k,crs0)
			   ELSE FALSE
			   ENDIF,
      tpmKey(k0,u0,f0,p0,crs0) : IF signed?(crs0)
                           THEN checkSigStatus(k,crs0)
			   ELSE FALSE
			   ENDIF,
      tpmDigest(digest0,crs0) : IF signed?(crs0)
      			           THEN checkSigStatus(k,crs0)
				   ELSE FALSE
				   ENDIF,
      tpmQuote(n0,p0,crs0) : IF signed?(crs0)
				THEN checkSigStatus(k,crs0)
				ELSE FALSE
				ENDIF,
      tpmIdContents(digest0,aik0,crs0) : IF signed?(crs0)
      			                 THEN checkSigStatus(k,crs0)
					 ELSE FALSE
					 ENDIF,
      tpmNonce : FALSE,
      tpmMigKeyAuth(k0,s0,d0,crs0) : IF signed?(crs0)
      				     THEN checkSigStatus(k,crs0)
				     ELSE FALSE
				     ENDIF

   ENDCASES;

  % Lemmas on data signing and signature checking

  check_sign : THEOREM FORALL (k:(asymKey?),c:CRYPTOSTATUS) : 
    checkSigStatus(k,signStatus(private(k),c));
  
  check_sign_keys: THEOREM FORALL (k0,k1:(asymKey?),crs:CRYPTOSTATUS) :
    k0=k1 IFF checkSigStatus(k1,signStatus(private(k0),crs));


  % Predicate subtype for a certified key.  Signed key may be clear or
  % wrapped only.
  certKey?(r:tpmData):bool =
  CASES r OF
    tpmKey(k0,u0,f0,p0,crs0) : CASES crs0 OF
                           signed(k1,csr1) : clear?(csr1) OR wrapped?(csr1)
			   ELSE FALSE
			 ENDCASES
    ELSE FALSE
  ENDCASES;

  %% Predicate subtype for a wrapped key.  Wrapped key must be clear by
  %% definition of wrapping
  wrapKey?(k:tpmData):bool =
  CASES k OF
    tpmKey(k0,u0,f0,p0,crs0) : CASES crs0 OF
    		        wrapped(k1,csr1,p1) : clear?(csr1)
		      	ELSE FALSE
		      ENDCASES
    ELSE FALSE
  ENDCASES;

  %% Accessors for wrapped key elements
  childKey(k:(wrapKey?)):(asymKey?) = key(k)

  parentKey(k:(wrapKey?)):KVAL = key(crs(k))

  %% Key sets and installation - This needs to be completely rethought

  %% A keyset is a set of wrapKeys
  KEYSET : TYPE = set[(wrapKey?)];
 
  %% Check against the root key passed in as rk
  checkKeyRoot(k:(wrapKey?),rk:KVAL):bool = parentKey(k)=rk;
 
  %% Check against the set of installed keys and the root key
  checkKey(k:KVAL,pubsrk:KVAL,ks:KEYSET):bool =
    some((LAMBDA (k0:(wrapKey?)): askey(key(k0)) = k),ks) OR (k=pubsrk);
 
  %% Add a key to a set of it checks out
  addKey(k:(wrapKey?),srk:(asymKey?),ks:KEYSET,d:PCRS):KEYSET =
    IF checkKey(parentKey(k),askey(srk),ks) AND d=PCRInfo(k) AND d=digest(crs(k))
    THEN add(k,ks)
    ELSE ks
    ENDIF;
 
  %% Remove a key - this is not currently used
  revokeKey(k:(wrapKey?),ks:KEYSET):KEYSET =
    remove(k,ks);

  child_if_parent: THEOREM FORALL (k:(wrapKey?),srk:(asymKey?),ks:KEYSET,d:PCRS) : 
    IF d=PCRInfo(k) AND checkKey(parentKey(k),askey(srk),ks) AND d=digest(crs(k))
       THEN member(k,addKey(k,srk,ks,d))
       ELSE ks=addKey(k,srk,ks,d)
    ENDIF;

  no_child_if_no_parent: THEOREM FORALL (k:(wrapKey?),rk:(asymKey?),ks:KEYSET) :
    NOT(member(k,revokeKey(k,ks)));

END key
