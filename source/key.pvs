%% ----
%%
%% Key Theory
%%
%% Author: Perry Alexander
%% Date: Mon Jan 16 15:26:29 CST 2012
%%
%% Description: Basic model of keys, encryption, decryption, and signing
%% 
%% Dependencies:
%%  None
%%
%% Todo: (key - => pending, + => done)
%%
%% ----
key [DVAL,HVAL:TYPE+] : THEORY

  BEGIN

  IMPORTING pcr[HVAL];
  IMPORTING ReturnCodes;
  
  KEYDATA : TYPE;
  
  %% Keys are integers.
  KVAL : TYPE = integer;


  %%									(5.6)
  AUTHDATA : DATATYPE
  BEGIN
    tpmSecret(i:nat) : tpmSecret?
    tpmEncAuth(i:nat) : tpmEncAuth?
  END AUTHDATA;

  %% The inverse of a key its negation
  inverse(k:KVAL):KVAL = -k;

  %% The bad key value is 0
  badkey:KVAL = 0;

  goodkey?(key:KVAL) : bool =
    key/=badkey

  %% Purpose for key

  %%									(5.8)
  KEY_USAGE : DATATYPE
  BEGIN
    signing : signing?
    storage : storage?
    identity : identity?
    authChange : authChange?
    bind : bind?
    legacy : legacy?
    migrate : migrate?
  END KEY_USAGE;

  %% Flags for defining key properties					(5.10)
  KEY_FLAGS : TYPE = [#
  	      	     redirection : bool, 
		     migratable : bool,
		     isVolatile : bool,
		     pcrIgnoredOnRead : bool,
		     migrateAuthority : bool
  	      	     #];

  %% All key flags false
  keyFlagsF : KEY_FLAGS = (#
  	     redirection:= false,
     	     migratable := false,
	     isVolatile := false,
	     pcrIgnoredOnRead := false,
	     migrateAuthority := false #)
  	     
  %% Migragion scheme indicator						(4.10)
  migrateScheme : DATATYPE
  BEGIN 
    migrate : migrate?
    rewrap : rewrap?
  END migrateScheme;

  %% Type indicating crypographic status - clear, encrypted, signed, wrapped,
  %% sealed.  Type is recursive allowing multiple operations on the same
  %% element.
  CRYPTOSTATUS : DATATYPE
  BEGIN
    clear : clear?
    encrypted(key:KVAL,crstat:CRYPTOSTATUS) : encrypted?
    signed(key:KVAL,crstat:CRYPTOSTATUS) : signed?
    sealed(key:KVAL,crstat:CRYPTOSTATUS) : sealed?
  END CRYPTOSTATUS;

  %% Data items that the TPM is aware of
  tpmData : DATATYPE
  BEGIN
    %% Identifyier for naming things
    tpmID(id:string,crs:CRYPTOSTATUS) : tpmID?
    
    %% Stub for migrateScheme so can take digest - createMigBlob	(4.4)
    tpmMigScheme(migScheme:migrateScheme) : tpmMigScheme?

    %% EK type - indicates what type of information the EK is dealing with(4.11)
    tpmEKBlobActivate(sessK:(tpmSessKey?),idDigest:(tpmDigest?),
	pcrInfo:(tpmPCRInfoShort?)) : tpmEKBlobActivate?

    %%			
    tpmEKBlobAuth(authValue:(tpmSecret?)) : tpmEKBlobAuth?
    
    %% Abitrarily long digest of arbitrary TPM data			(5.4)
    tpmDigest(digest:list[tpmData],crs:CRYPTOSTATUS) : tpmDigest?
    %  tpmDigest is the list of things concatenated and hashed to create the
    %  digest value - #(d0++d1++...++dn).  
    %  Note that this digest does not contain PCRs 

    % TPM_COMPOSITE_HASH should be element of tpmDigest,
    % PCR_COMPOSITE : [#select:PCR_SELECTION,pcrValue:PCRVALUES#]
    tpmCompositeHash(digest:PCR_COMPOSITE) : tpmCompositeHash?

    %% Random value that provides protection from replay.		(5.5)
    tpmNonce : tpmNonce?

    %% Authdata - don't know what it is yet				(5.6)
    tpmAuthData(authData:AUTHDATA,crs:CRYPTOSTATUS) : tpmAuthData?
    %% cases authData of
    %% secret : crs = clear
    %% encauth : crs = encrypted depending on context   

    %% Provides proof that the associated public key has		(5.12)
    %% TPM Owner AuthData to be a migration key
    tpmMigKeyAuth(key:(tpmKey?),scheme:(tpmMigScheme?),digest:(tpmDigest?),
	crs:CRYPTOSTATUS) : tpmMigKeyAuth?

    %% Structure signed for certain commands (TPM_ReleaseTransportSigned)(5.14)
%     tpmSignInfo(replay:(tpmNonce?),data:tpmData,crs:CRYPTOSTATUS) : tpmSignInfo?
    %% crs should be signed? %%TODO
    
    %% PCR Info								(8.4)
    %% TODO: This is only a stub.
    tpmPCRInfoLong(
	  localityAtCreation : LOCALITY %loc modifier when blob is created
    	% Locality modifier required to reveal sealed data or use a key that was wrapped to PCRs
	% Value must not be zero (0)
	, localityAtRelease  : LOCALITY
	% Selection of PCRs active when blob is created
	, creationPCRSelection : PCR_SELECTION
	% Selection of PCRs to which the key or data is bound
	, releasePCRSelection  : PCR_SELECTION
	% Composite digest value of the PCR values, when the blob is created
  	, digestAtCreation : (tpmCompositeHash?)
	% Digest of PCR indices and PCR values to verify when revealing sealed data 
	% or using a key that was wrapped to PCRs
	, digestAtRelease  : (tpmCompositeHash?)
	) : tpmPCRInfoLong?

  tpmPCRInfoShort(
	  pcrSelection : PCR_SELECTION 
	% Selection of PCRs that specifies the digestAtRelease
	, localityAtRelease : LOCALITY_SELECTION
	% Locality modifier required to release information
	% must not be zero (0)
	, digestAtRelease : (tpmCompositeHash?)
	% Digest of PCR indices and PCR values to verify when revealing auth data
	) : tpmPCRInfoShort?


    %% Stored Data - necessary to ensure the enforcement of security
    %% properties (9.2) Used by seal and unseal commands to identify
    %% pcr index and values that must be present to properly unseal
    %% data.
    tpmStoredData(sealInfo:(tpmPCRInfoLong?),
		  encData:(tpmSealedData?),
		  crs:CRYPTOSTATUS) : tpmStoredData?
		  %% encData is the piece encrypted by the crs.
		  
    %% Sealed Data - contains confidential info related to sealed data	(9.3)
    tpmSealedData(authData:(tpmAuthData?),
		  tpmProof:(tpmSecret?),
		  storedDigest:(tpmDigest?), %TPM_COMPOSITE_HASH?
		  data:tpmData) : tpmSealedData?
    
    %% Session keys are simply symetric keys				(9.4)
    tpmSessKey(skey:KVAL,crs:CRYPTOSTATUS) : tpmSessKey?
    
    %% Bound data							(9.5)
    tpmBoundData(payloadData:tpmData,crs:CRYPTOSTATUS) : tpmBoundData?

    %% Assymetric keys used by the TPM - wrapped, signed, encrypted	(10.3)
    tpmKey(key:KVAL,
	   keyUsage:KEY_USAGE,
	   keyFlags:KEY_FLAGS,
	   PCRInfo:(tpmPCRInfoLong?),
	   wrappingKey:KVAL,
	   crs:CRYPTOSTATUS) : tpmKey?
    %  tpmKey subsumes all asymmetric keys used by the TPM
    %  encrypted key: tpmKey(k,...,encrypted(public(j),clear))
    %  clear key encrypted with public j
    %  signed/certified key: tpmKey(k,...,signed(private(j),clear))
    %  clear key signed by private j

    %% Pub Key (used for ek, srk?)					(10.5)
    tpmPubkey(pubKey:KVAL):tpmPubkey?

    %% Store Asym Key [private key]					(10.6)
    tpmStoreAsymkey(usageAuth:(tpmSecret?),
		    migrationAuth:(tpmSecret?),
		    pubDataDigest:(tpmDigest?),
		    privKey:KVAL,
		    crs:CRYPTOSTATUS) : tpmStoreAsymkey?

    %% Migrate Asym Key							(10.8)
    tpmMigrateAsymkey(usageAuth:(tpmSecret?),
		      pubDataDigest:(tpmDigest?),
		      partPrivKey:(tpmKey?)) : tpmMigrateAsymkey?

    %%  Quote including a PCR digest and nonce.				(11.3)
    tpmQuote(digest:(tpmCompositeHash?),
	externalData:(tpmNonce?),
	crs:CRYPTOSTATUS) : tpmQuote?
    %  PCRs are not current TPM data, so the digest is over PCR values.
    
    %% Quote the current values of a list of PCRs			(11.4)
    tpmQuote2(infoShort:(tpmPCRInfoShort?),externalData:(tpmNonce?),crs:CRYPTOSTATUS) :
    	tpmQuote2?
    
    %% Provides wrapper to each type of structure that will be in use when(12.1)
    %% EK is in use
    tpmEKBlob(blob:tpmData,crs:CRYPTOSTATUS) : tpmEKBlob?
    %% blob must be tpmEKBlobAuth or tpmEKBlobActivate

    %% Certification request sent to Privacy CA				(12.5)
    tpmIdContents(digest:(tpmDigest?),aik:(tpmKey?),crs:CRYPTOSTATUS) : tpmIdContents?
    %  digest should contain CA public key, name, and AIK
    
    %% Contains symmetric key to encrypt the identity credential	(12.8)
    tpmAsymCAContents(sessK:(tpmSessKey?),idDigest:(tpmDigest?),crs:CRYPTOSTATUS) : 
    	tpmAsymCAContents?

    %% tpmFullQuote(cert:(tpmCertKey?),sml:list[HVAL],quote:(tpmQuote?)):tpmFullQuote?
    %  Implement as tpmAbsOutput
    %  cert is a certified key and should be checked with certKey?
    %  SML is the stored measurement list
    %  Quote is the signed quote generated by the TPM
    %  This is simply a triple represented below    
  END tpmData;
  
  activateIdentityBlob?(blob:tpmData) : bool =
  CASES blob OF
    tpmEKBlob(b,c) : TRUE,
    tpmAsymCAContents(k,d,c) : TRUE
    ELSE FALSE
  ENDCASES

  tpmNull : (tpmSealedData?)
  tpmNonceZero : (tpmNonce?)
  pcrInfoLongDefault : (tpmPCRInfoLong?)

  %% Reserved Key Handles - Should be moved to tpm.pvs
  TPM_KH_SRK : (tpmKey?) = tpmKey(2,storage,keyFlagsF,pcrInfoLongDefault,1,clear)
  TPM_KH_OWNER : (tpmKey?)
  TPM_KH_REVOKE : (tpmKey?)
  TPM_KH_TRANSPORT : (tpmKey?)
  TPM_KH_OPERATOR : (tpmKey?)
  TPM_KH_ADMIN : (tpmKey?)
  %% Not sure if EK is an indentity key or not
  TPM_KH_EK : (tpmKey?) = tpmKey(1,identity,keyFlagsF,pcrInfoLongDefault,1,clear)


  %% Any tpmKey? with key value 0 is invalid.
  invalidKey?(k:(tpmKey?)):bool = key(k)=0;

  %% Define private and public key accessors for tpmKey?. The public
  %% key is the key value while the private key is -key.
  private(k:(tpmKey?)):KVAL = inverse(key(k))
  public(k:(tpmKey?)):KVAL = key(k)

  privateKey(k:(tpmKey?)):(tpmKey?) = tpmKey(inverse(key(k)),
					     keyUsage(k),
					     keyFlags(k),
					     PCRInfo(k),
					     wrappingKey(k),
					     crs(k))
  publicKey(k:(tpmKey?)):(tpmKey?) = k

  %% Some theorems about key inverse, private and public.

  %% The inverse key of the inverse key is the original key
  double_inverse: THEOREM FORALL (k:KVAL) : inverse(inverse(k))=k;

  %% the inverse of a private key is the public key for the same
  %% asymmetric key.
  inverse_private: THEOREM FORALL (k:(tpmKey?)) :
    inverse(private(k))=public(k);

  %% visa versa                                                         
  inverse_public: THEOREM FORALL (k:(tpmKey?)) :
    inverse(public(k))=private(k);

  %% If inverse keys are equal, key values are equal
  equal_inverse: THEOREM FORALL (k0,k1:KVAL) :
     inverse(k0) = inverse(k1) <=> k0=k1;

  %% Basic crypto functions operating on KVAL xStatus functions
  %% operate on status indicators while x functions operate on
  %% tpmData.  Users need only call encrypt, decrypt, sign, checkSig
  %% and friends.

  % Data Encryption

  encryptStatus(k:KVAL,c:CRYPTOSTATUS) : (encrypted?) =
    encrypted(k,c);

  encrypt(k:KVAL,d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,encryptStatus(k,crs0)),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,encryptStatus(k,crs0)),
      tpmAuthData(authdata0,crs0) :
        tpmAuthData(authdata0,encryptStatus(k,crs0)),
      tpmMigKeyAuth(k0,s0,d0,crs0) : 
        tpmMigKeyAuth(k0,s0,d0,encryptStatus(k,crs0)),
      tpmStoredData(s0,e0,crs0) : tpmStoredData(s0,e0,encryptStatus(k,crs0)),
      tpmSessKey(k0,crs0) : tpmSessKey(k0,encryptStatus(k,crs0)),
      tpmBoundData(p0,crs0) : tpmBoundData(p0,encryptStatus(k,crs0)),
      tpmKey(k0,u0,f0,p0,wk0,crs0) :
        tpmKey(k0,u0,f0,p0,wk0,encryptStatus(k,crs0)),
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) : 
      	tpmStoreAsymkey(u0,m0,p0,k0,encryptStatus(k,crs0)),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,encryptStatus(k,crs0)),
      tpmEKBlob(b0,crs0) : tpmEKBlob(b0,encryptStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,encryptStatus(k,crs0)),
      tpmAsymCAContents(s0,i0,crs0) : 
      	tpmAsymCAContents(s0,i0,encryptStatus(k,crs0))
      ELSE d
    ENDCASES;

  noCrypto?(d:tpmData) : bool =
    CASES d OF
      tpmMigScheme(m0) : TRUE,
      tpmEKBlobActivate(k0,i0,p0) : TRUE,
      tpmEKBlobAuth(a0) : TRUE,
      tpmNonce : TRUE,
      tpmPCRInfoLong(lc0,lr0,sc0,sr0,dc0,dr0) : TRUE,
      tpmSealedData(a0,p0,s0,d0) : TRUE,
      tpmPubkey(k0) : TRUE,
      tpmMigrateAsymkey(u0,d0,p0) : TRUE
      ELSE FALSE
    ENDCASES;

  % Data decryption
  decryptStatus(k:KVAL,c:(encrypted?)) : CRYPTOSTATUS =
    IF k = inverse(key(c)) THEN crstat(c) ELSE c ENDIF;

  decrypt(k:KVAL,d:tpmData) : tpmData =
    CASES d OF
      tpmID(id0,crs0) : 
        IF encrypted?(crs0)
        THEN tpmID(id0,decryptStatus(k,crs0))
	ELSE d	
	ENDIF,
      tpmDigest(digest0,crs0) :
        IF encrypted?(crs0)
        THEN tpmDigest(digest0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmAuthData(authdata0,crs0) :
        IF encrypted?(crs0)
        THEN tpmAuthData(authdata0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        IF encrypted?(crs0)
        THEN tpmMigKeyAuth(k0,s0,d0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF,
      tpmStoredData(s0,e0,crs0) : 
        IF encrypted?(crs0)
        THEN tpmStoredData(s0,e0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmSessKey(k0,crs0) : 
      	IF encrypted?(crs0)
        THEN tpmSessKey(k0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmBoundData(p0,crs0) : 
      	IF encrypted?(crs0)
      	THEN tpmBoundData(p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmKey(k0,u0,f0,p0,wk0,crs0) : 
      	IF encrypted?(crs0)
      	THEN tpmKey(k0,u0,f0,p0,wk0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) :
        IF encrypted?(crs0)
        THEN tpmStoreAsymkey(u0,m0,p0,k0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmQuote(n0,p0,crs0) :
        IF encrypted?(crs0)
        THEN tpmQuote(n0,p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmEKBlob(b0,crs0) : 
        IF encrypted?(crs0)
	THEN tpmEKBlob(b0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmIdContents(digest0,aik0,crs0) :
        IF encrypted?(crs0)
        THEN tpmIdContents(digest0,aik0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF,
      tpmAsymCAContents(k0,d0,crs0) :
        IF encrypted?(crs0)
	THEN tpmAsymCAContents(k0,d0,decryptStatus(k,crs0))
	ELSE d
	ENDIF
      ELSE d
    ENDCASES;
 
  % Lemmas on decryption and encryption

  decrypt_encrypt : THEOREM FORALL (k:KVAL,c:CRYPTOSTATUS) : 
    decryptStatus(inverse(k),encryptStatus(k,c)) = c;

  decrypt_equal_keys: THEOREM FORALL (k0,k1:KVAL,b:CRYPTOSTATUS) :
    k0=k1 IMPLIES decryptStatus(inverse(k1),encryptStatus(k0,b)) = b;

  no_decrypt_unequal_keys: THEOREM FORALL (k0,k1:KVAL,b:CRYPTOSTATUS) :
    k0/=k1 IMPLIES decryptStatus(inverse(k1),encryptStatus(k0,b)) = encryptStatus(k0,b)

  % Data signing

  signStatus(k:KVAL,c:CRYPTOSTATUS) : (signed?) =
    signed(k,c);

  sign(k:KVAL,d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,signStatus(k,crs0)),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,signStatus(k,crs0)),
      tpmAuthData(authdata0,crs0) :
        tpmAuthData(authdata0,signStatus(k,crs0)),
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        tpmMigKeyAuth(k0,s0,d0,signStatus(k,crs0)),
      tpmStoredData(s0,e0,crs0) : 
      	tpmStoredData(s0,e0,signStatus(k,crs0)),
      tpmSessKey(k0,crs0) :
        tpmSessKey(k0,signStatus(k,crs0)),
      tpmBoundData(p0,crs0) : 
        tpmBoundData(p0,signStatus(k,crs0)),
      tpmKey(k0,u0,f0,p0,wk0,crs0) :
        tpmKey(k0,u0,f0,p0,wk0,signStatus(k,crs0)),
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) :
        tpmStoreAsymkey(u0,m0,p0,k0,signStatus(k,crs0)),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,signStatus(k,crs0)),
      tpmEKBlob(b0,crs0) : tpmEKBlob(b0,signStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,signStatus(k,crs0)),
      tpmAsymCAContents(k0,d0,crs0) :
        tpmAsymCAContents(k0,d0,signStatus(k,crs0))
      ELSE d
    ENDCASES;

  % Data signature checking

  checkSigStatus(k:KVAL,c:CRYPTOSTATUS) : bool =
    CASES c OF
      signed(kq,cq) : k = kq
      ELSE FALSE
    ENDCASES;

  checkSig(k:KVAL,d:tpmData) : bool =
    CASES d OF    
      tpmMigScheme(m0) : FALSE,
      tpmEKBlobActivate(k0,i0,p0) : FALSE,
      tpmEKBlobAuth(a0) : FALSE,
      tpmNonce : FALSE,
      tpmPCRInfoLong(lc0,lr0,sc0,sr0,dc0,dr0) : FALSE,
      tpmSealedData(a0,p0,s0,d0) : FALSE,
      tpmPubkey(k0) : FALSE,
      tpmMigrateAsymkey(u0,d0,p0) : FALSE
      ELSE 
        IF signed?(crs(d))
      	THEN checkSigStatus(k,crs(d))
	ELSE FALSE
	ENDIF
   ENDCASES;

  % Lemmas on data signing and signature checking

  check_sign : THEOREM FORALL (k:KVAL,c:CRYPTOSTATUS) : 
    checkSigStatus(k,signStatus(k,c));
  
  %%%% Key sets, installation, and use

  %% A keyset is a set of key values
  KEYSET : TYPE = set[KVAL];
  	 
  %% Is a key installed or the SRK?
  installedOrSRK?(k:(tpmKey?),ks:KEYSET):bool =
    member(key(k),ks) OR key(k)=key(TPM_KH_SRK); 

  %% There is no magic for SRK - use the TPM_KH_SRK handle if the wrapping
  %% key is the SRK.
  addKey(k:(tpmKey?),ks:KEYSET):KEYSET = add(key(k),ks);
    % IF (wrappingKey(k)=TPM_KH OR member(wrappingKey(k),ks)) AND d=PCRInfo(k)
    % THEN add(key(k),ks)
    % ELSE ks
    % ENDIF;

  loadKey(k:(tpmKey?),wk:(tpmKey?),ks:KEYSET,d:PCRVALUES):KEYSET =  %d:list[PCR]
    IF storage?(keyUsage(wk)) AND wrappingKey(k)=key(wk) 
%        AND 
%        getPCRs(d,releasePCRSelection(PCRInfo(k)))=digestAtRelease(PCRInfo(k)) AND 
%        getPCRs(d,creationPCRSelection(k))=digestAtCreation(PCRInfo(k))
       AND installedOrSRK?(wk,ks)
    THEN addKey(k,ks)
    ELSE ks
    ENDIF
 
  %% Remove a key - this is not currently
  revokeKey(k:(tpmKey?),ks:KEYSET):KEYSET = remove(key(k),ks);

  child_if_parent: THEOREM FORALL (k,wk:(tpmKey?),srk:KVAL,ks:KEYSET,d:PCRVALUES) : %d:list[PCR]
    wrappingKey(k)=key(wk) AND storage?(keyUsage(wk)) 
    % AND d=PCRInfo(k)
    AND (member(wrappingKey(k),ks) OR wrappingKey(k)=key(TPM_KH_SRK))
       => member(key(k),loadKey(k,wk,ks,d))


  no_child_if_no_parent: THEOREM FORALL (k:(tpmKey?),ks:KEYSET) :
    NOT(member(key(k),revokeKey(k,ks)));

  %% Crypto functions using TPM keys.  Public keys from TPM keys are
  %% public knowledge and require nothing for use - encrypt and
  %% checkSig do not require a key set.  Private keys must be
  %% installed in the key set ks passed to each function - decrypt and
  %% sign require a key set.

  encryptWrapped(k:(tpmKey?),d:tpmData):tpmData = encrypt(key(k),d)

  decryptWrapped(k:(tpmKey?),d:tpmData,ks:KEYSET):tpmData =
    IF installedOrSRK?(k,ks) THEN decrypt(key(k),d) ELSE d ENDIF

  signWrapped(k:(tpmKey?),d:tpmData,ks:KEYSET):tpmData =
    IF installedOrSRK?(k,ks) THEN sign(key(k),d) ELSE d ENDIF

  checkSigWrapped(k:(tpmKey?),d:tpmData):bool = checkSig(key(k),d)

END key
