%% ----
%%
%% Key Theory
%%
%% Author: Perry Alexander
%% Date: Mon Jan 16 15:26:29 CST 2012
%%
%% Description: Basic model of keys, encryption, decryption, and signing
%% 
%% Dependencies:
%%  data.pvs
%%  pcr.pvs
%%  keyData.pvs
%%  authdata.pvs
%%
%% Todo: (key - => pending, + => done)
%%
%% ----
key[HV:TYPE+] : THEORY

  BEGIN

  IMPORTING data[HV];

  %% Reserved Key Handles - Should be moved to tpm.pvs
  TPM_KH_SRK : (tpmKey?) = tpmKey(2,storage,keyFlagsF,
				  always,keyParmsDef,
				  pcrInfoLongDefault,1,
				  storeAsymkeyDefault,clear)
  TPM_KH_OWNER : (tpmKey?)
  TPM_KH_REVOKE : (tpmKey?)
  TPM_KH_TRANSPORT : (tpmKey?)
  TPM_KH_OPERATOR : (tpmKey?)
  TPM_KH_ADMIN : (tpmKey?)
  %% Not sure if EK is an indentity key or not
  TPM_KH_EK : (tpmKey?) = tpmKey(1,identity,keyFlagsF,
				 always,keyParmsDef,
				 pcrInfoLongDefault,1,
				 storeAsymkeyDefault,clear)


  %% Any tpmKey? with key value 0 is invalid.
  invalidKey?(k:(tpmKey?)):bool = key(k)=0;

  %% Define private and public key accessors for tpmKey?. The public
  %% key is the key value while the private key is -key.
  private(k:(tpmKey?)):KVAL = inverse(key(k))
  public(k:(tpmKey?)):KVAL = key(k)

  privateKey(k:(tpmKey?)):(tpmKey?) = tpmKey(inverse(key(k)),
					     keyUsage(k),
					     keyFlags(k),
					     authDataUsage(k),
					     algoParms(k),
					     PCRInfo(k),
					     wrappingKey(k),
					     encDat(k),
					     crs(k))
  publicKey(k:(tpmKey?)):(tpmKey?) = k

  %% Some theorems about key inverse, private and public.

  %% The inverse key of the inverse key is the original key
  double_inverse: THEOREM FORALL (k:KVAL) : inverse(inverse(k))=k;

  %% the inverse of a private key is the public key for the same
  %% asymmetric key.
  inverse_private: THEOREM FORALL (k:(tpmKey?)) :
    inverse(private(k))=public(k);

  %% visa versa                                                         
  inverse_public: THEOREM FORALL (k:(tpmKey?)) :
    inverse(public(k))=private(k);

  %% If inverse keys are equal, key values are equal
  equal_inverse: THEOREM FORALL (k0,k1:KVAL) :
     inverse(k0) = inverse(k1) <=> k0=k1;

  %% Basic crypto functions operating on KVAL xStatus functions
  %% operate on status indicators while x functions operate on
  %% tpmData.  Users need only call encrypt, decrypt, sign, checkSig
  %% and friends.

  % Data Encryption

  encryptStatus(k:KVAL,c:CRYPTOSTATUS) : (encrypted?) =
    encrypted(k,c);

  encrypt(k:KVAL,d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,encryptStatus(k,crs0)),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,encryptStatus(k,crs0)),
      tpmEncAuth(authdata0,crs0) :
        tpmEncAuth(authdata0,encryptStatus(k,crs0)),
      tpmMigKeyAuth(k0,s0,d0,crs0) : 
        tpmMigKeyAuth(k0,s0,d0,encryptStatus(k,crs0)),
      tpmStoredData(s0,e0,crs0) : tpmStoredData(s0,e0,encryptStatus(k,crs0)),
      tpmSealedData(a0,p0,s0,d0,crs0) : 
      	tpmSealedData(a0,p0,s0,d0,encryptStatus(k,crs0)),
      tpmSessKey(k0,crs0) : tpmSessKey(k0,encryptStatus(k,crs0)),
      tpmBoundData(p0,crs0) : tpmBoundData(p0,encryptStatus(k,crs0)),
      tpmKey(k0,u0,f0,a0,ap0,p0,wk0,e0,crs0) :
        tpmKey(k0,u0,f0,a0,ap0,p0,wk0,e0,encryptStatus(k,crs0)),
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) : 
      	tpmStoreAsymkey(u0,m0,p0,k0,encryptStatus(k,crs0)),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,encryptStatus(k,crs0)),
      tpmEKBlob(b0,crs0) : tpmEKBlob(b0,encryptStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,encryptStatus(k,crs0)),
      tpmAsymCAContents(s0,i0,crs0) : 
      	tpmAsymCAContents(s0,i0,encryptStatus(k,crs0))
      ELSE d
    ENDCASES;

  noCrypto?(d:tpmData) : bool =
    CASES d OF
      tpmMigScheme(m0) : TRUE,
      tpmEKBlobActivate(k0,i0,p0) : TRUE,
      tpmEKBlobAuth(a0) : TRUE,
      tpmNonce(i0) : TRUE,
      tpmSecret(i0) : TRUE,
      tpmMSAComposite(i0,m0) : TRUE,
      tpmCMKDelegate(s0,s1,b0,l0,m0) : TRUE,
      tpmCMKMigAuth(m0,p0) : TRUE,
      tpmCMKSigTicket(v0,s0) : TRUE,
      tpmCMKMAApproval(m0) : TRUE,
      tpmPCRInfoLong(lc0,lr0,sc0,sr0,dc0,dr0) : TRUE,
      tpmPubkey(a0,k0) : TRUE,
      tpmMigrateAsymkey(u0,d0,p0) : TRUE,
      OAEP(m0,p0,s0) : TRUE,
      concat(f0,s0) : TRUE
      ELSE FALSE
    ENDCASES;

  % Data decryption
  decryptStatus(k:KVAL,c:(encrypted?)) : CRYPTOSTATUS =
    IF k = inverse(key(c)) THEN crstat(c) ELSE c ENDIF;

  decrypt(k:KVAL,d:tpmData) : tpmData =
    CASES d OF
      tpmID(id0,crs0) : 
        IF encrypted?(crs0)
        THEN tpmID(id0,decryptStatus(k,crs0))
	ELSE d	
	ENDIF,
      tpmDigest(digest0,crs0) :
        IF encrypted?(crs0)
        THEN tpmDigest(digest0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmEncAuth(authdata0,crs0) :
        IF encrypted?(crs0)
        THEN tpmSecret(authdata0)%,decryptStatus(k,crs0)) TODO?
	ELSE d
	ENDIF,
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        IF encrypted?(crs0)
        THEN tpmMigKeyAuth(k0,s0,d0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF,
      tpmStoredData(s0,e0,crs0) : 
        IF encrypted?(crs0)
        THEN tpmStoredData(s0,e0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmSealedData(a0,p0,s0,d0,crs0) :
        IF encrypted?(crs0)
        THEN tpmSealedData(a0,p0,s0,d0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmSessKey(k0,crs0) : 
      	IF encrypted?(crs0)
        THEN tpmSessKey(k0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmBoundData(p0,crs0) : 
      	IF encrypted?(crs0)
      	THEN tpmBoundData(p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmKey(k0,u0,f0,a0,ap0,p0,wk0,e0,crs0) : 
      	IF encrypted?(crs0)
      	THEN tpmKey(k0,u0,f0,a0,ap0,p0,wk0,e0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) :
        IF encrypted?(crs0)
        THEN tpmStoreAsymkey(u0,m0,p0,k0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmQuote(n0,p0,crs0) :
        IF encrypted?(crs0)
        THEN tpmQuote(n0,p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmEKBlob(b0,crs0) : 
        IF encrypted?(crs0)
	THEN tpmEKBlob(b0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmIdContents(digest0,aik0,crs0) :
        IF encrypted?(crs0)
        THEN tpmIdContents(digest0,aik0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF,
      tpmAsymCAContents(k0,d0,crs0) :
        IF encrypted?(crs0)
	THEN tpmAsymCAContents(k0,d0,decryptStatus(k,crs0))
	ELSE d
	ENDIF
      ELSE d
    ENDCASES;
 
  % Lemmas on decryption and encryption

  decrypt_encrypt : THEOREM FORALL (k:KVAL,c:CRYPTOSTATUS) : 
    decryptStatus(inverse(k),encryptStatus(k,c)) = c;

  decrypt_equal_keys: THEOREM FORALL (k0,k1:KVAL,b:CRYPTOSTATUS) :
    k0=k1 IMPLIES decryptStatus(inverse(k1),encryptStatus(k0,b)) = b;

  no_decrypt_unequal_keys: THEOREM FORALL (k0,k1:KVAL,b:CRYPTOSTATUS) :
    k0/=k1 IMPLIES decryptStatus(inverse(k1),encryptStatus(k0,b)) = encryptStatus(k0,b)

  % Data signing

  signStatus(k:KVAL,c:CRYPTOSTATUS) : (signed?) =
    signed(k,c);

  sign(k:KVAL,d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,signStatus(k,crs0)),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,signStatus(k,crs0)),
      tpmEncAuth(authdata0,crs0) :
        tpmEncAuth(authdata0,signStatus(k,crs0)),
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        tpmMigKeyAuth(k0,s0,d0,signStatus(k,crs0)),
      tpmStoredData(s0,e0,crs0) : 
      	tpmStoredData(s0,e0,signStatus(k,crs0)),
      tpmSealedData(a0,p0,s0,d0,crs0) :
      	tpmSealedData(a0,p0,s0,d0,signStatus(k,crs0)),
      tpmSessKey(k0,crs0) :
        tpmSessKey(k0,signStatus(k,crs0)),
      tpmBoundData(p0,crs0) : 
        tpmBoundData(p0,signStatus(k,crs0)),
      tpmKey(k0,u0,f0,a0,ap0,p0,wk0,e0,crs0) :
        tpmKey(k0,u0,f0,a0,ap0,p0,wk0,e0,signStatus(k,crs0)),
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) :
        tpmStoreAsymkey(u0,m0,p0,k0,signStatus(k,crs0)),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,signStatus(k,crs0)),
      tpmEKBlob(b0,crs0) : tpmEKBlob(b0,signStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,signStatus(k,crs0)),
      tpmAsymCAContents(k0,d0,crs0) :
        tpmAsymCAContents(k0,d0,signStatus(k,crs0))
      ELSE d
    ENDCASES;

  % Data signature checking

  checkSigStatus(k:KVAL,c:CRYPTOSTATUS) : bool =
    CASES c OF
      signed(kq,cq) : k = kq
      ELSE FALSE
    ENDCASES;

  checkSig(k:KVAL,d:tpmData) : bool =
    CASES d OF    
      tpmMigScheme(m0) : FALSE,
      tpmEKBlobActivate(k0,i0,p0) : FALSE,
      tpmEKBlobAuth(a0) : FALSE,
      tpmCompositeHash(d0) : FALSE,
      tpmNonce(i0) : FALSE,
      tpmSecret(i0) : FALSE,
      tpmMSAComposite(i0,m0) : FALSE,
      tpmCMKDelegate(s0,s1,b0,l0,m0) : FALSE,
      tpmCMKMigAuth(m0,p0) : FALSE,
      tpmCMKSigTicket(v0,s0) : FALSE,
      tpmCMKMAApproval(m0) : FALSE,
      tpmPCRInfoLong(lc0,lr0,sc0,sr0,dc0,dr0) : FALSE,
      tpmPCRInfoShort(ps0,l0,d0) : FALSE,
      tpmPubkey(a0,k0) : FALSE,
      tpmMigrateAsymkey(u0,d0,p0) : FALSE,
      OAEP(m0,p0,s0) : FALSE,
      concat(f0,s0) : FALSE
      ELSE 
        IF signed?(crs(d))
      	THEN checkSigStatus(k,crs(d))
	ELSE FALSE
	ENDIF
   ENDCASES;

  % Lemmas on data signing and signature checking

  check_sign : THEOREM FORALL (k:KVAL,c:CRYPTOSTATUS) : 
    checkSigStatus(k,signStatus(k,c));
  
  %%%% Key sets, installation, and use

  %% A keyset is a set of key values
  KEYSET : TYPE = set[KVAL];
  	 
  %% Is a key installed or the SRK?
  installedOrSRK?(k:(tpmKey?),ks:KEYSET):bool =
    member(key(k),ks) OR key(k)=key(TPM_KH_SRK); 


  %% There is no magic for SRK - use the TPM_KH_SRK handle if the wrapping
  %% key is the SRK.
  addKey(k:(tpmKey?),ks:KEYSET):KEYSET = add(key(k),ks);
    % IF (wrappingKey(k)=TPM_KH OR member(wrappingKey(k),ks)) AND d=PCRInfo(k)
    % THEN add(key(k),ks)
    % ELSE ks
    % ENDIF;

  loadKey(k:(tpmKey?),wk:(tpmKey?),ks:KEYSET,d:PCRVALUES):KEYSET =  %d:list[PCR]
    IF 
%        getPCRs(d,releasePCRSelect(PCRInfo(k)))=digAtRelease(PCRInfo(k)) AND 
%        getPCRs(d,creationPCRSelect(k))=digAtCreation(PCRInfo(k)) AND 
       installedOrSRK?(wk,ks) %todo: should this be not?
    THEN addKey(k,ks)
    ELSE ks
    ENDIF

  load_key :THEOREM FORALL(k,w:(tpmKey?),ks:KEYSET,d:PCRVALUES) :
    loadKey(k,w,ks,d)=
    IF member(key(w),ks)
    THEN add(key(k),ks)
    ELSIF key(w)=key(TPM_KH_SRK)
    THEN add(key(k),ks)
    ELSE ks
    ENDIF

  %% Remove a key - this is not currently
  revokeKey(k:(tpmKey?),ks:KEYSET):KEYSET = remove(key(k),ks);

  child_if_parent: THEOREM FORALL (k,wk:(tpmKey?),srk:KVAL,ks:KEYSET,d:PCRVALUES) : %d:list[PCR]
    wrappingKey(k)=key(wk) AND storage?(keyUsage(wk)) 
    % AND d=PCRInfo(k)
    AND (member(wrappingKey(k),ks) OR wrappingKey(k)=key(TPM_KH_SRK))
       => member(key(k),loadKey(k,wk,ks,d))


  no_child_if_no_parent: THEOREM FORALL (k:(tpmKey?),ks:KEYSET) :
    NOT(member(key(k),revokeKey(k,ks)));

  %% Crypto functions using TPM keys.  Public keys from TPM keys are
  %% public knowledge and require nothing for use - encrypt and
  %% checkSig do not require a key set.  Private keys must be
  %% installed in the key set ks passed to each function - decrypt and
  %% sign require a key set.

  encryptWrapped(k:(tpmKey?),d:tpmData):tpmData = encrypt(key(k),d)

  decryptWrapped(k:(tpmKey?),d:tpmData,ks:KEYSET):tpmData =
    IF installedOrSRK?(k,ks) THEN decrypt(key(k),d) ELSE d ENDIF

  signWrapped(k:(tpmKey?),d:tpmData,ks:KEYSET):tpmData =
    IF installedOrSRK?(k,ks) THEN sign(key(k),d) ELSE d ENDIF

  checkSigWrapped(k:(tpmKey?),d:tpmData):bool = checkSig(key(k),d)

END key
