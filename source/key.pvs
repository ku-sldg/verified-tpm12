%% ----
%%
%% Key Theory
%%
%% Author: Perry Alexander
%% Date: Mon Jan 16 15:26:29 CST 2012
%%
%% Description: Basic model of keys, encryption, decryption, and signing
%% 
%% Dependencies:
%%  None
%%
%% Todo: (key - => pending, + => done)
%%
%% ----
key [DVAL,KVAL,HVAL:TYPE+] : THEORY

  BEGIN

  IMPORTING pcr[HVAL];
  IMPORTING ReturnCodes;
  
  %%										(5.6)
  AUTHDATA : DATATYPE
  BEGIN
    tpmSecret(i:nat) : tpmSecret?
    tpmEncAuth(i:nat) : tpmEncAuth?
  END AUTHDATA;


  %%										(5.8)
  KEY_USAGE : DATATYPE
  BEGIN
    signing : signing?
    storage : storage?
    identity : identity?
    authChange : authChange?
    bind : bind?
    legacy : legacy?
    migrate : migrate?
  END KEY_USAGE;

  %%										(5.10)
  KEY_FLAGS : TYPE = [#
  	      	     redirection : bool, 
		     migratable : bool,
		     isVolatile : bool,
		     pcrIgnoredOnRead : bool,
		     migrateAuthority : bool
  	      	     #];

  keyFlagsF : KEY_FLAGS = (#
  	     redirection:= false,
     	     migratable := false,
	     isVolatile := false,
	     pcrIgnoredOnRead := false,
	     migrateAuthority := false #)
  	     
  %%										(4.10)
  migrateScheme : DATATYPE
  BEGIN 
    migrate : migrate?
    rewrap : rewrap?
  END migrateScheme;

  KEY : DATATYPE
  BEGIN
    invalidKey : invalidKey?
    symKey(skey:KVAL) : symKey?
    asymKey(askey:KVAL) : asymKey?
  END KEY;		

  % This is odd, but it seems to work out okay.
  private(k:(asymKey?)):(asymKey?)

  %% This theorem does NOT say that the private key of a private key is
  %% a key.  It says that everything - signing and encrypting - can be done
  %% in reverse if you swap the keys around.

  double_private: AXIOM FORALL (k:(asymKey?)) : private(private(k))=k;

  equal_private_equal_key: AXIOM FORALL (k0,k1:(asymKey?)) :
    private(k0) = private(k1) <=> k0 = k1;

  %% Lemmas

  CRYPTOSTATUS : DATATYPE
  BEGIN
    clear : clear?
    encrypted(key:(asymKey?),crstat:CRYPTOSTATUS) : encrypted?
    signed(key:(asymKey?),crstat:CRYPTOSTATUS) : signed?
    wrapped(key:(asymKey?),crstat:CRYPTOSTATUS) : wrapped?
    sealed(key:(asymKey?),crstat:CRYPTOSTATUS) : sealed?
  END CRYPTOSTATUS;

  tpmData : DATATYPE
  BEGIN
    %% Identifyier for naming things
    tpmID(id:string,crs:CRYPTOSTATUS) : tpmID?
    
    %% Stub for migrateScheme so can take digest - createMigBlob		(4.4)
    tpmMigScheme(migScheme:migrateScheme) : tpmMigScheme?

    %% EK type - indicates what type of information the EK is dealing with	(4.11)
    tpmEKBlobActivate(sessK:(tpmSessKey?),idDigest:(tpmDigest?),pcrInfo:(tpmPCRInfo?)) 
    	: tpmEKBlobActivate?

    %%			
    tpmEKBlobAuth(authValue:(tpmSecret?)) : tpmEKBlobAuth?
    
    %% Abitrarily long digest of arbitrary TPM data				(5.4)
    tpmDigest(digest:list[tpmData],crs:CRYPTOSTATUS) : tpmDigest?
    %  tpmDigest is the list of things concatenated and hashed to create the
    %  digest value - #(d0++d1++...++dn).  Note that this digest does not
    %  contain PCRs

    %% Random value that provides protection from replay.			(5.5)
    tpmNonce : tpmNonce?

    %% Authdata - don't know what it is yet					(5.6)
    tpmAuthData(authData:AUTHDATA,crs:CRYPTOSTATUS) : tpmAuthData?
    %% cases authData of
    %% secret : crs = clear
    %% encauth : crs = encrypted depending on context   

    %% Provides proof that the associated public key has TPM Owner AuthData	(5.12)
    %% to be a migration key
    tpmMigKeyAuth(key:(tpmKey?),scheme:(tpmMigScheme?),digest:(tpmDigest?),
	crs:CRYPTOSTATUS) 
    		: tpmMigKeyAuth?

    %% Structure signed for certain commands (TPM_ReleaseTransportSigned)	(5.14)
%     tpmSignInfo(replay:(tpmNonce?),data:tpmData,crs:CRYPTOSTATUS) : tpmSignInfo?
    %% crs should be signed? %%TODO
    
    %% PCR Info									(8.4)
    %% TODO: This is only a stub.
    tpmPCRInfo(pcrs:PCRS) : tpmPCRInfo?
    
    %% Stored Data - necessary to ensure the enforcement of security properties (9.2)
    %% Used by seal and unseal commands to identify pcr index and values that must 
    %% be present to properly unseal data.
    tpmStoredData(sealInfo:(tpmPCRInfo?),
		  encData:(tpmSealedData?),
		  crs:CRYPTOSTATUS) : tpmStoredData?
		  %% encData is the piece encrypted by the crs.
		  
    %% Sealed Data - contains confidential info related to sealed data		(9.3)
    tpmSealedData(authData:(tpmAuthData?),
		  tpmProof:(tpmSecret?),
		  storedDigest:(tpmDigest?),
		  data:tpmData) : tpmSealedData?
    
    %% Session keys are simply symetric keys					(9.4)
    tpmSessKey(skey:(symKey?),crs:CRYPTOSTATUS) : tpmSessKey?
    
    %% Bound data								(9.5)
    tpmBoundData(payloadData:tpmData,crs:CRYPTOSTATUS) : tpmBoundData?

    %% Assymetric keys used by the TPM - wrapped, signed, encrypted		(10.3)
    tpmKey(key:(asymKey?),
	   keyUsage:KEY_USAGE,
	   keyFlags:KEY_FLAGS,
	   PCRInfo:PCRS,
	   crs:CRYPTOSTATUS) : tpmKey?
    %  tpmKey subsumes all asymmetric keys used by the TPM
    %  wrapped key: tpmKey(child,wrapped(public(parent),clear,pcrs))
    %  clear child wrapped by parent bound to PCRs
    %  unwrapped asymmetric key: tpmKey(k,clear)
    %  clear key
    %  encrypted key: tpmKey(k,encrypted(public(j),clear))
    %  clear key encrypted with public j
    %  signed/certified key: tpmKey(k,signed(private(j),clear))
    %  clear key signed by private j

    %% Store Pub Key								(10.4)
    tpmStorePubkey(key:(asymKey?)):tpmStorePubkey?

    %% Pub Key (used for ek, srk?)						(10.5)
    tpmPubkey(pubKey:(tpmStorePubkey?)):tpmPubkey?

    %% Store Asym Key								(10.6)
    tpmStoreAsymkey(usageAuth:(tpmSecret?),migrationAuth:(tpmSecret?),
	pubDataDigest:(tpmDigest?),privKey:(tpmStorePrivkey?),crs:CRYPTOSTATUS)
	: tpmStoreAsymkey?

    %% Store Priv Key								(10.7)
    tpmStorePrivkey(key:(asymKey?)):tpmStorePrivkey?

    %% Migrate Asym Key								(10.8)
    tpmMigrateAsymkey(usageAuth:(tpmSecret?),pubDataDigest:(tpmDigest?),
		partPrivKey:(tpmKey?)):tpmMigrateAsymkey?

    %%  Quote including a PCR digest and nonce.					(11.3)
    tpmQuote(digest:list[PCR],nonce:(tpmNonce?),crs:CRYPTOSTATUS) : tpmQuote?
    %  PCRs are not current TPM data, so the digest is over PCR values.
    
    %% Provides wrapper to each type of structure that will be in use when	(12.1)
    %% EK is in use
    tpmEKBlob(blob:tpmData,crs:CRYPTOSTATUS) : tpmEKBlob?
    %% blob must be tpmEKBlobAuth or tpmEKBlobActivate

    %% Certification request sent to Privacy CA					(12.5)
    tpmIdContents(digest:(tpmDigest?),aik:(tpmKey?),crs:CRYPTOSTATUS) : tpmIdContents?
    %  digest should contain CA public key, name, and AIK
    
    %% Contains symmetric key to encrypt the identity credential		(12.8)
    tpmAsymCAContents(sessK:(tpmSessKey?),idDigest:(tpmDigest?),crs:CRYPTOSTATUS) : 
    	tpmAsymCAContents?

    %% tpmFullQuote(cert:(tpmCertKey?),sml:list[HVAL],quote:(tpmQuote?)):tpmFullQuote?
    %  Implement as tpmAbsOutput
    %  cert is a certified key and should be checked with certKey?
    %  SML is the stored measurement list
    %  Quote is the signed quote generated by the TPM
    %  This is simply a triple represented below    
  END tpmData;
  
  activateIdentityBlob?(blob:tpmData) : bool =
  CASES blob OF
    tpmEKBlob(b,c) : TRUE,
    tpmAsymCAContents(k,d,c) : TRUE
    ELSE FALSE
  ENDCASES

  %% Basic crypto functions.  xStatus functions operate on status
  %% indicators while x functions operate on tpmData.  Need to account
  %% for private and public keys in this, but the basic process seems to be
  %% there.
  encryptStatus(k:(asymKey?),c:CRYPTOSTATUS) : (encrypted?) =
    encrypted(k,c);

  encrypt(k:(asymKey?),d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,encryptStatus(k,crs0)),
      tpmMigScheme(m) : tpmMigScheme(m),
      tpmEKBlobActivate(s0,d0,p0) : tpmEKBlobActivate(s0,d0,p0),
      tpmEKBlobAuth(a0) : tpmEKBlobAuth(a0),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,encryptStatus(k,crs0)),
      tpmNonce : tpmNonce,
      tpmAuthData(authdata0,crs0) :
        tpmAuthData(authdata0,encryptStatus(k,crs0)),
      tpmMigKeyAuth(k0,s0,d0,crs0) : 
        tpmMigKeyAuth(k0,s0,d0,encryptStatus(k,crs0)),
      tpmPCRInfo(p0) : tpmPCRInfo(p0),
      tpmStoredData(s0,e0,crs0) : tpmStoredData(s0,e0,encryptStatus(k,crs0)),
      tpmSealedData(a0,t0,s0,d0) : tpmSealedData(a0,t0,s0,d0),
      tpmSessKey(k0,crs0) :
        tpmSessKey(k0,encryptStatus(k,crs0)),
      tpmBoundData(p0,crs0) : tpmBoundData(p0,encryptStatus(k,crs0)),
      tpmKey(k0,u0,f0,p0,crs0) :
        tpmKey(k0,u0,f0,p0,encryptStatus(k,crs0)),
      tpmStorePubkey(k0) : tpmStorePubkey(k0),
      tpmPubkey(p0) : tpmPubkey(p0),
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) : 
      	tpmStoreAsymkey(u0,m0,p0,k0,encryptStatus(k,crs0)),
      tpmStorePrivkey(k0) : tpmStorePrivkey(k0),
      tpmMigrateAsymkey(u0,p0,k0) : tpmMigrateAsymkey(u0,p0,k0),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,encryptStatus(k,crs0)),
      tpmEKBlob(b0,crs0) : tpmEKBlob(b0,encryptStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,encryptStatus(k,crs0)),
      tpmAsymCAContents(s0,i0,crs0) : 
      	tpmAsymCAContents(s0,i0,encryptStatus(k,crs0))
    ENDCASES;

  noCrypto?(d:tpmData) : bool =
    CASES d OF
      tpmMigScheme(m0) : TRUE,
      tpmEKBlobActivate(k0,i0,p0) : TRUE,
      tpmEKBlobAuth(a0) : TRUE,
      tpmNonce : TRUE,
      tpmPCRInfo(p0) : TRUE,
      tpmSealedData(a0,p0,s0,d0) : TRUE,
      tpmStorePubkey(k0) : TRUE,
      tpmPubkey(k0) : TRUE,
      tpmStorePrivkey(k0) : TRUE,
      tpmMigrateAsymkey(u0,d0,p0) : TRUE
      ELSE FALSE
    ENDCASES;

%   encrypt(k:(asymKey?),d:tpmData) : tpmData =
%     IF noCrypto?(d)
%     THEN d
%     ELSE d WITH [`crs := encryptStatus(k,crs(d))]
%     ENDIF;

  decryptStatus(k:(asymKey?),c:(encrypted?)) : CRYPTOSTATUS =
    IF private(key(c)) = k THEN crstat(c) ELSE c ENDIF;

  decrypt(k:(asymKey?),d:tpmData) : tpmData =
    CASES d OF
      tpmID(id0,crs0) : 
        IF encrypted?(crs0)
        THEN tpmID(id0,decryptStatus(k,crs0))
	ELSE d	
	ENDIF,
      tpmDigest(digest0,crs0) :
        IF encrypted?(crs0)
        THEN tpmDigest(digest0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmAuthData(authdata0,crs0) :
        IF encrypted?(crs0)
        THEN tpmAuthData(authdata0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        IF encrypted?(crs0)
        THEN tpmMigKeyAuth(k0,s0,d0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF,
      tpmStoredData(s0,e0,crs0) : 
        IF encrypted?(crs0)
        THEN tpmStoredData(s0,e0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmSessKey(k0,crs0) : 
      	IF encrypted?(crs0)
        THEN tpmSessKey(k0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmBoundData(p0,crs0) : 
      	IF encrypted?(crs0)
      	THEN tpmBoundData(p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmKey(k0,u0,f0,p0,crs0) : 
      	IF encrypted?(crs0)
      	THEN tpmKey(k0,u0,f0,p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) :
        IF encrypted?(crs0)
        THEN tpmStoreAsymkey(u0,m0,p0,k0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmQuote(n0,p0,crs0) :
        IF encrypted?(crs0)
        THEN tpmQuote(n0,p0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmEKBlob(b0,crs0) : 
        IF encrypted?(crs0)
	THEN tpmEKBlob(b0,decryptStatus(k,crs0))
	ELSE d
	ENDIF,
      tpmIdContents(digest0,aik0,crs0) :
        IF encrypted?(crs0)
        THEN tpmIdContents(digest0,aik0,decryptStatus(k,crs0)) 
	ELSE d
	ENDIF,
      tpmAsymCAContents(k0,d0,crs0) :
        IF encrypted?(crs0)
	THEN tpmAsymCAContents(k0,d0,decryptStatus(k,crs0))
	ELSE d
	ENDIF
      ELSE d
    ENDCASES;

  decrypt_encrypt : THEOREM FORALL (k:(asymKey?),c:CRYPTOSTATUS) : 
    decryptStatus(private(k),encryptStatus(k,c)) = c;

  decrypt_equal_keys: THEOREM FORALL (k0,k1:(asymKey?),b:CRYPTOSTATUS) :
    k0=k1 IMPLIES decryptStatus(private(k1),encryptStatus(k0,b)) = b;

  no_decrypt_unequal_keys: THEOREM FORALL (k0,k1:(asymKey?),b:CRYPTOSTATUS) :
    k0/=k1 IMPLIES decryptStatus(private(k1),encryptStatus(k0,b)) = encryptStatus(k0,b)

  signStatus(k:(asymKey?),c:CRYPTOSTATUS) : (signed?) =
    signed(k,c);


  sign(k:(asymKey?),d:tpmData) : tpmData =
    CASES d OF 
      tpmID(id0,crs0) : tpmID(id0,signStatus(k,crs0)),
      tpmDigest(digest0,crs0) :
        tpmDigest(digest0,signStatus(k,crs0)),
      tpmAuthData(authdata0,crs0) :
        tpmAuthData(authdata0,signStatus(k,crs0)),
      tpmMigKeyAuth(k0,s0,d0,crs0) :
        tpmMigKeyAuth(k0,s0,d0,signStatus(k,crs0)),
      tpmStoredData(s0,e0,crs0) : 
      	tpmStoredData(s0,e0,signStatus(k,crs0)),
      tpmSessKey(k0,crs0) :
        tpmSessKey(k0,signStatus(k,crs0)),
      tpmBoundData(p0,crs0) : 
        tpmBoundData(p0,signStatus(k,crs0)),
      tpmKey(k0,u0,f0,p0,crs0) :
        tpmKey(k0,u0,f0,p0,signStatus(k,crs0)),
      tpmStoreAsymkey(u0,m0,p0,k0,crs0) :
        tpmStoreAsymkey(u0,m0,p0,k0,signStatus(k,crs0)),
      tpmQuote(n0,p0,crs0) : tpmQuote(n0,p0,signStatus(k,crs0)),
      tpmEKBlob(b0,crs0) : tpmEKBlob(b0,signStatus(k,crs0)),
      tpmIdContents(digest0,aik0,crs0) :
        tpmIdContents(digest0,aik0,signStatus(k,crs0)),
      tpmAsymCAContents(k0,d0,crs0) :
        tpmAsymCAContents(k0,d0,signStatus(k,crs0))
      ELSE d
    ENDCASES;


  checkSigStatus(k:(asymKey?),c:CRYPTOSTATUS) : bool =
    CASES c OF
      signed(kq,cq) : private(k) = kq
      ELSE FALSE
    ENDCASES;

  checkSig(k:(asymKey?),d:tpmData) : bool =
    CASES d OF    
      tpmMigScheme(m0) : FALSE,
      tpmEKBlobActivate(k0,i0,p0) : FALSE,
      tpmEKBlobAuth(a0) : FALSE,
      tpmNonce : FALSE,
      tpmPCRInfo(p0) : FALSE,
      tpmSealedData(a0,p0,s0,d0) : FALSE,
      tpmStorePubkey(k0) : FALSE,
      tpmPubkey(k0) : FALSE,
      tpmStorePrivkey(k0) : FALSE,
      tpmMigrateAsymkey(u0,d0,p0) : FALSE
      ELSE 
        IF signed?(crs(d))
      	THEN checkSigStatus(k,crs(d))
	ELSE FALSE
	ENDIF
   ENDCASES;

  check_sign : THEOREM FORALL (k:(asymKey?),c:CRYPTOSTATUS) : 
    checkSigStatus(k,signStatus(private(k),c));
  
  check_sign_keys: THEOREM FORALL (k0,k1:(asymKey?),crs:CRYPTOSTATUS) :
    k0=k1 IFF checkSigStatus(k1,signStatus(private(k0),crs));

  % Predicate subtype for a certified key.  Key may be clear or wrapped.
  certKey?(r:tpmData):bool =
  CASES r OF
    tpmKey(k0,u0,f0,p0,crs0) : CASES crs0 OF
                           signed(k1,csr1) : clear?(csr1) OR wrapped?(csr1)
			   ELSE FALSE
			 ENDCASES
    ELSE FALSE
  ENDCASES;

  %%%% Wrapped Keys

  %% Predicate subtype for a wrapped key.  Wrapped key must be clear.
  wrapKey?(k:tpmData):bool =
  CASES k OF
    tpmKey(k0,u0,f0,p0,crs0) : CASES crs0 OF
    		        wrapped(k1,csr1) : clear?(csr1)
		      	ELSE FALSE
		      ENDCASES
    ELSE FALSE
  ENDCASES;

  %% Accessors for wrapped key elements
  childKey(k:(wrapKey?)):(asymKey?) = key(k)

  parentKey(k:(wrapKey?)):(asymKey?) = key(crs(k))

  %% Data structures used in identity establishment.
  %% An identity is a pair of keys signed by the same k.  First key is
  %% the certified AIK and the second is the EK
  identity?(id:[(certKey?),(certKey?)]):bool = 
    LET (aik,ek) = id IN
      EXISTS (k:(asymKey?)) : checkSig(k,aik) AND checkSig(k,ek)

  %% A full quote is a pair one key and a TPM quote both signed by the
  %% same k.
  fullQuote?(q:[(certKey?),(tpmQuote?)]):bool =
    LET (ck,tpmq) = q IN
      EXISTS (k:(asymKey?)) : checkSig(k,ck) AND checkSig(k,tpmq)
        
  %% Check a TPM quote
  checkQuote(q:(tpmQuote?),k:(asymKey?),p:list[PCR],n:(tpmNonce?)):bool =
    checkSig(k,q) AND nonce(q)=n AND digest(q)=p;

  %% Check a Full Quote using signed AIK. Check AIK against known
  %% public(CA) and check the TPM quote against AIK and expected values
  checkFullQuote(q:(fullQuote?),ca:(asymKey?),p:list[PCR],n:(tpmNonce?)):bool =
    LET (aik,tpmq) = q IN
      checkSig(ca,aik) AND checkQuote(tpmq,key(aik),p,n);

  %%%% Key sets and installation

  %% A keyset is simply a set of asymetric keys
  KEYSET : TYPE = set[(asymKey?)];
 
  %% Check against the root key passed in as rk
  checkKeyRoot(k:(wrapKey?),rk:(asymKey?)):bool = parentKey(k)=rk;
 
  %% Check against the set of installed keys and the root key
  checkKey(k:(asymKey?),srk:(asymKey?),ks:KEYSET):bool =
    member(k,ks) OR k=srk;
 
  %% Add a key to a set of it checks out
  addKey(k:(wrapKey?),srk:(asymKey?),ks:KEYSET,d:PCRS):KEYSET =
    IF checkKey(parentKey(k),srk,ks) AND d=PCRInfo(k)
    THEN add(childKey(k),ks)
    ELSE ks
    ENDIF;
 
  %% Remove a key - this is not currently used
  revokeKey(k:(wrapKey?),ks:KEYSET):KEYSET =
    remove(childKey(k),ks);

  child_if_parent: THEOREM FORALL (k:(wrapKey?),rk:(asymKey?),ks:KEYSET,d:PCRS) : 
    IF d=PCRInfo(k) AND (member(parentKey(k),ks) OR parentKey(k)=rk)
       THEN member(childKey(k),addKey(k,rk,ks,d))
       ELSE ks=addKey(k,rk,ks,d)
    ENDIF;

  no_child_if_no_parent: THEOREM FORALL (k:(wrapKey?),rk:(asymKey?),ks:KEYSET) :
    NOT(member(childKey(k),revokeKey(k,ks)));

END key
