%% ----
%%
%% Key Theory
%%
%% Author: Perry Alexander
%% Date: Mon Jan 16 15:26:29 CST 2012
%%
%% Description: Basic model of keys, encryption, decryption, and signing
%% 
%% Dependencies:
%%  None
%%
%% Todo: (key - => pending, + => done)
%%  + Add key sets
%%  + Add key installation and revocation from sets
%%  - Add regression tests for key installation and revocation functions
%% ----
key [DVAL,KVAL,HVAL:TYPE+] : THEORY

  BEGIN

  %%ASSUMING
  %%ENDASSUMING

  %% Basic key types - symmetric, assymetric, wrapped - built with key values
  %% Note that KVAL is completely uninterpretted at this point
  IMPORTING pcr[HVAL];

  KEY : DATATYPE
  BEGIN
    symKey(skey:KVAL) : symKey?
    asymKey(askey:KVAL) : asymKey?
    wrapKey(wrappingKey:(asymKey?),wkey:(asymKey?)) : wrapKey?
  END KEY;		

  private(k:(asymKey?)):(asymKey?)

  %% This theorem does NOT say that the private key of a private key is
  %% a key.  It says that everything - signing and encrypting - can be done
  %% in reverse if you swap the keys around.

  double_private: AXIOM FORALL (k:(asymKey?)) : private(private(k))=k;

  %% Basic blob types - data, keys, hashs, encrypted blobs, signed blobs
  %% Blobs in this context are things that can be encrypted or signed
  %% Note that encrypted and signed things can be encrypted and signed

  BLOB : DATATYPE
  BEGIN
    nothing : nothing?
    keyBlob(key:KEY) : keyBlob?
    hashBlob(h:HVAL) : hashBlob?
    encryptBlob(key:KEY,blob:BLOB) : encryptBlob?
    signBlob(key:KEY,blob:BLOB) : signBlob?
    sealBlob(key:KEY,pcrs:PCRS,blob:BLOB) : sealBlob?
    certBlob(key:KEY,blob:BLOB) : certBlob?
    pairBlob(left,right : BLOB) : pairBlob?
  END BLOB;

  %% Decryption for specific key types.  Key types not matching automatically
  %% is a failure
  decryptSym(b:(encryptBlob?),k:(symKey?)):BLOB =
    IF symKey?(key(b)) AND symKey?(k) AND key(b) = k
       THEN blob(b)
       ELSE nothing
    ENDIF;

  decryptAsym(b:(encryptBlob?),k:(asymKey?)):BLOB =
    IF asymKey?(key(b)) AND asymKey?(k) AND key(b) = private(k)
       THEN blob(b)
       ELSE nothing
    ENDIF;

  decryptWrapped(b:(encryptBlob?),k:(wrapKey?)):BLOB = nothing;
  
  %% Decryption for all key types
  decrypt(b:(encryptBlob?),k:KEY):BLOB = 
    CASES k OF 
      symKey(k0) : decryptSym(b,k),
      asymKey(k0) : decryptAsym(b,k),
      wrapKey(k0,k1) : nothing
  ENDCASES;

  %% Unseal for aysmetric keys
  unseal(b:(sealBlob?),pcrs:PCRS,k:(asymKey?)):BLOB =
    IF pcrs(b) = pcrs AND key(b)=private(k)
       THEN blob(b)
       ELSE nothing
    ENDIF;

  %% Signature check for specific key types
  %% This could (and should) be implemented with decryption function
  sigCheckSym(b:(signBlob?),k:(symKey?)):boolean =
    symKey?(key(b)) AND symKey?(k) AND key(b) = k;

  sigCheckAsym(b:(signBlob?),k:(asymKey?)):boolean =
    asymKey?(key(b)) AND asymKey?(k) AND key(b) = private(k);

  sigCheckWrapped(b:(signBlob?),k:(wrapKey?)):boolean = FALSE;

  %% Signature checking for all keys
  sigCheck(b:(signBlob?),k:KEY):boolean =
    CASES k OF
      symKey(k0) : sigCheckSym(b,k),
      asymKey(k0) : sigCheckAsym(b,k),
      wrapKey(k0,k1) : FALSE
    ENDCASES;

  KEYSET : TYPE = set[(asymKey?)];

  checkKeyRoot(k:(wrapKey?),rk:(asymKey?)):bool =
    wrappingKey(k)=rk;

  checkKey(k:(wrapKey?),rk:(asymKey?),ks:KEYSET):bool =
    member(wrappingKey(k),ks) OR wrappingKey(k)=rk;

  addKey(k:(wrapKey?),rk:(asymKey?),ks:KEYSET):KEYSET =
    IF checkKey(k,rk,ks)
    THEN add(wkey(k),ks)
    ELSE ks
    ENDIF;

  removeKey(k:(wrapKey?),ks:KEYSET):KEYSET =
    remove(wkey(k),ks);

  %% Lemmas

  %% Regression Theorems

  %% Signature checks
  
  test0: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
  
  k0=k1 IFF sigCheck(signBlob(k0,b),k1);

  test1: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    private(k0)=k1 IFF sigCheck(signBlob(k0,b),k1);

  %% Decryption

  test2: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0=k1 IMPLIES decrypt(encryptBlob(k0,b),k1) = b;

  test3: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    k0=k1 IMPLIES decrypt(encryptBlob(k0,b),private(k1)) = b;

  test4: THEOREM FORALL (k0,k1:(symKey?),b:BLOB) :
    k0/=k1 IMPLIES decrypt(encryptBlob(k0,b),k1) = nothing;

  test5: THEOREM FORALL (k0,k1:(asymKey?),b:BLOB) :
    k0/=k1 IMPLIES decrypt(encryptBlob(k0,b),private(k1)) = nothing;

  %% Key installation

  test6: THEOREM FORALL (k:(wrapKey?),rk:(asymKey?),ks:KEYSET) : 
    IF member(wrappingKey(k),ks) OR wrappingKey(k)=rk
       THEN member(wkey(k),addKey(k,rk,ks))
       ELSE ks=addKey(k,rk,ks)
    ENDIF;

  test7: THEOREM FORALL (k:(wrapKey?),rk:(asymKey?),ks:KEYSET) :
    NOT(member(wkey(k),removeKey(k,ks)));

END key
