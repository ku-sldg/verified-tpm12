   %% Verification of the quote generation process from init through
   %% generation of a appraiser's quote.
   %%
   %% Acronym map:
   %% MLE - Measured Launch Environment
   %% TSS - Trusted Software Stack
   %% CR - Certification Request
   %% CA - Certificate Authority used to sign AIKs
   %%
   %% Memory map:  
   %% 0 -> identity
   %% 1 -> CA cert
   %% 2 -> TPM quote
   %%


caProtocol : THEORY

BEGIN

  IMPORTING tpm

  makeCertActivate(state:tpmAbsState,k:(tpmKey?),e:(tpmEncAuth?),
	d:(tpmDigest?),i1,i2,i3,i4:authIn) : tpmAbsState =
   LET key=tpmKey(-keyGenCnt(state),
                  keyUsage(k),
                  keyFlags(k),
                  authDataUsage(k),
                  algoParms(k),
		  tpmPCRInfoLong(makeIdentityLocality,
                                 locAtRelease(PCRInfo(k)),
                                 creationPCRSelect(PCRInfo(k)),
                                 releasePCRSelect(PCRInfo(k)),
                                 tpmCompositeHash((# 
				    select := creationPCRSelect(PCRInfo(k)),
                                    pcrValue := pcrs(state) #)),
                                 digAtRelease(PCRInfo(k))),
                  wrappingKey(state`srk),
                  tpmStoreAsymkey(tpmSecret(authData(e)),
                                  state`permData`tpmProof,
                                  pubDataDigest(encDat(k)),
                                  privKey(encDat(k)),
				  clear),
                  clear) IN
   state WITH[
  	`keyGenCnt := 2+keyGenCnt(state),
        `memory := updateLoc(updateLoc(state`memory,
                                       0,
                                       OUT_MakeIdentity
                                       (key,
                                        tpmIdContents
                                        (d,
                                         key,
                                         signed(--keyGenCnt(state), clear)),
                                        (# nonceEven:=EVEN,
                                           nonceOdd:=ODD,
                                           contAuthSess:=FALSE,
                                           resAuth:=usageAuth(encDat(state`srk))
					 #),
                                        (# nonceEven:=EVEN,
                                           nonceOdd:=ODD,
                                           contAuthSess:=FALSE,
                                           resAuth:=ownerAuth(i2) #),
                                        TPM_SUCCESS)),
                             1,
                             OUT_Certify(key,
                                         tpmAsymCAContents(
					  tpmSessKey(1+-keyGenCnt(state),clear),
                                          d,
                                          encrypted(1,clear)),
                                         CPU_SUCCESS))]

  %% Note that the identity is not used in building the final
  %% appraiser's quote
  %% proved Sat Jul 14 11:19:56 CDT 2012
  cert_and_quote_with_prev_key: THEOREM
    FORALL (state:(afterStartup?)
%state:tpmAbsState
%      	     aik:(asymKey?),
%              n:BLOB,
% 	     pm:PCRMASK,
% 	     k:(symKey?),
% 	     sml:SML,
% 	     auth:AUTHDATA) :
   	  ,n:(tpmNonce?)
	  ,pm:PCR_SELECTION
	  ,e:(tpmEncAuth?)
	  ,idKey:(tpmKey?)
	  ,caDig:(tpmDigest?)
	  ,i1,i2,i3,i4,i5:authIn) :
    LET (a,s) = runState(
                % Start by initializing the TPM and runnining startup
		% to generate a clear TPM
%                TPM_Init
		% Startup initialized resettable PCRs to -1
% 		>> TPM_Startup(TPM_ST_CLEAR)
		% Call SENTER to start a measured launch
		% environment. This will result in PCR(0) being
		% reset to 0.  Only SENTER causes this reset to occur
% 		>> CPU_senter
		% Call SINIT to measure the MLE and extend PCR(0)
% 		>> CPU_sinit
		% At this point the MLE would start running.
		   
		% We've reached a point where PCR(0) is reset and has been
		% extended with the SINIT hash and the MLE hash.  This
		% value will indicate to an appraiser that: (i) SENTER
		% was called; (ii) the right SINIT ran; and (iii) the right
		% MLE was started.
		   
		% We're ready to run the CA based attestation
		% protocol.  Assume that the TSS has received a
		% request for a quote containing PCR(0).

		% Create a new identity by generating a new AIK value.
		% The output is a wrapped key and a CR.  The CR contains
		% a fresh assymetric key used as the new AIK and a fresh
		% summetric key used as a session key, both signed by the
		% TPM's EK.
%%  		>> TPM_MakeIdentity(aik,k,auth) % identity is output
%		>> TPM_MakeIdentity(e,caDig,idKey,i1,i2) % identity is output
		% Save the CR to use at a later time.
%		>>= CPU_saveOutput(0)
		% Ask an external CA to sign the new AIK by sending it
		% the CR generated by MakeIdentity.  The CA checks the
		% signature on the CR and if it is valid, returns an
		% activation record that includes a session key and the
		% AIK signed by the CA encrypted with the TPM's EK.
% 		>>= (LAMBDA (a:tpmAbsOutput) :
% 		     CASES a OF
% 		     	OUT_MakeIdentity(ik,bind,o1,o2,m) : CA_certify(ik,bind)
% 			ELSE TPM_Noop(a)
% 		     ENDCASES)
		% Save the CR for use again later.
% 	        >>= CPU_saveOutput(1)
		% At this piont, the TSS holds an activation record
		% encrypted by an EK.  If it is encrypted with its TPM's EK
		% it can decrypt the signed AIK and session key.  The
		% ActivateIdentity command does this.  Note that that is all
		% ActivateIdentity does.  Nothing is installed and the TPM
		% state is not modified in any way.
% 	        >>= (LAMBDA (a:tpmAbsOutput) :
% 		     CASES a OF
% %			outIdentActivation(actc,sk,actek,rc) : TPM_ActivateIdentity(wkey(actc),k)
% 			OUT_Certify(j,d,m) : TPM_ActivateIdentity(j,d,i3,i4)
% 			ELSE TPM_Noop(a)
% 		     ENDCASES)
% 		>> 
		CPU_read(0)
		% Only the correct TPM can decrypt the certificate
		% and session key.  This is critical as it links the
		% certificate and session key to the TPM.  Now the TPM
		% generates a quote signed by the AIK using the Quote
		% command.
		>>= (LAMBDA (a:tpmAbsOutput) :
		     CASES a OF 
			OUT_MakeIdentity(ik,b,o1,o2,m) : TPM_Quote(ik,n,pm,i5)
			ELSE TPM_Noop(a)
		     ENDCASES)
		>>= CPU_saveOutput(2) % Quote is saved in 2 Now the
		% TSS is ready to build the appraiser's quote.  It
		% has the generated TPM quote signed by the AIK
		% that only the TPM can generate. It has the
		% certificate from the CA that only the TPM could
		% decrypt.  It now ships the certificate and the quote
		% back to the appraiser 
		>> CPU_BuildQuoteFromMem(2,0) % Build the quote
		)
		% When the appraiser recieves the quote, it can check the
		% AIK signature and the AIK cert to ensure that the TPM
		% quote came from a legitimate TPM associated with the AIK.
		% However, it cannot collude with other appraisers to
		% learn more about the target as they all can use different
		% AIK values.
 		(makeCertActivate(state,idKey,e,caDig,i1,i2,i3,i4)) IN
% 		LET wk:wrapKey = (# parentKey:= private(asymKey(srkKeyVal)),
%                                     childKey := aik #)
% 				    IN
LET key=idKey(s`memory(0))
		  IN
%TODO: FIX KEY STUFF!!
    makeIdentity?(state,idKey) AND 
    	OUT_MakeIdentity?(s`memory(0)) AND
    certify?(idKey(s`memory(0)),idBinding(s`memory(0))) AND
    	OUT_Certify?(s`memory(1)) AND
	wellFormedRestore?(s`restore) 
    AND
    activateIdentity?(tpmRestore(s`restore),idKey(s`memory(0)),dat(s`memory(1)))
    AND
    quote?(key) AND
        OUT_Quote?(s`memory(2)) 
%AND key=idKey

	 =>
         % The protocol works if the object being output is what we believe
	 % shoud be output.
         a = OUT_FullQuote(
% 			   % Certificate from the CA over the AIK
% 	                    certBlob(private(asymKey(caKeyVal)),wk),
% 			    % Stored measurement list (unused)
%                                sml,
			    % TPM quote
                            tpmQuote(
				tpmCompositeHash((#select:=pm,
					pcrValue:=s`pcrs#)),
				n,
				signed(private(key),clear)),
				tpmIdContents(caDig,key,signed(private(key),
					clear)),
				CPU_SUCCESS) AND
      s = state WITH[`keyGenCnt := 2+keyGenCnt(state),
      	     	     `memory := s`memory]

% 					%Signed by the AIK
% 			                private(aik),
% 					% includes a nonce from the appraiser
%                                         n,
% 					% includes requested PCR values
%                                         map
%                                         ((pcrsSenter(pcrsReset(pcrAttrib(permData(s))),pcrAttrib(permData(s)))
% 					% This is the PCR generated by the
% 					% init, senter, sinit sequence.
%                                           WITH [(0)
%                                                 := extend
%                                                    (extend
%                                                     (reset, hash(sinit)),
%                                                     hash(mle))]),
%                                          pm),
% 					 TPM_SUCCESS),
% 				TPM_SUCCESS)	    

   ca_protocol:THEOREM
   FORALL (state:(afterStartup?)
   	  ,e:(tpmEncAuth?)
	  ,d:(tpmDigest?)
	  ,k:(tpmKey?)
   	  ,n:(tpmNonce?)
	  ,p:PCR_SELECTION
	  ,i1,i2,i3,i4,i5:authIn
	  ,x,y,z:nat) :
    LET (a,s) = runState(
 		TPM_MakeIdentity(e,d,k,i1,i2)
		>>= CPU_saveOutput(x)
		>>= (LAMBDA (a:tpmAbsOutput) :
		    CASES a OF
		    	  OUT_MakeIdentity(k,i,o1,o2,m) : CA_certify(k,i)
			  ELSE TPM_Noop(a)
		    ENDCASES)
		>>= CPU_saveOutput(y)
		>>= (LAMBDA (a:tpmAbsOutput) : 
		    CASES a OF
		    	  OUT_Certify(j,d,m) : TPM_ActivateIdentity(j,d,i3,i4)
			  ELSE TPM_Noop(a)
		    ENDCASES)
		>> CPU_read(x)
		>>= (LAMBDA (a:tpmAbsOutput) :
		     CASES a OF 
			OUT_MakeIdentity(ik,b,o1,o2,m) : TPM_Quote(ik,n,p,i5)
			ELSE TPM_Noop(a)
		     ENDCASES)
		>>= CPU_saveOutput(z)
		>> CPU_BuildQuoteFromMem(z,x) % Build the quote
		)
		(state) IN
     LET key=idKey(s`memory(x)) IN

    makeIdentity?(state,k) AND 
    	OUT_MakeIdentity?(s`memory(x)) AND
    certify?(key,idBinding(s`memory(x))) AND
    	OUT_Certify?(s`memory(y)) AND
	wellFormedRestore?(s`restore) AND
    activateIdentity?(tpmRestore(s`restore),key,
	dat(s`memory(y))) AND
    quote?(key) AND
        OUT_Quote?(s`memory(z)) 
    => 
         a = OUT_FullQuote(
		tpmQuote(tpmCompositeHash((#select:=p,pcrValue:=s`pcrs#)),
			 n,
			 signed(private(key),clear)),
			 tpmIdContents(d,key,signed(private(key),
			 clear)),
		CPU_SUCCESS) AND
    s=state WITH [`memory:=s`memory
    	    	 ,`keyGenCnt:=state`keyGenCnt+2]


END caProtocol
