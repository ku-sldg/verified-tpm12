%% ----
%%
%% TPM Theory
%%
%% Author: Perry Alexander, Brigid Halling
%% Date: Mon Nov 28 01:09:39 CST 2011
%%
%% Description: Basic model of a TPM using a monadic state model
%% 
%% Dependencies:
%%  StateMonad.pvs
%%  key.pvs
%%  pcr.pvs
%%
%% Todo: (key - => pending, + => done)
%% ----

%% Standard Error IDs
%%  0 = "Bad identity record"
%%  1 = "Bad input key"
%%  2 = "bad session key"
%%  4 = "bad quote parts"
%%  5 = "Clear Disabled"

tpm [ B:TYPE+ % BLOB
      , HV:TYPE+ % Hash value
      , hash:[B->HV] % Hash function
%      , K:TYPE+ % Key
     ] : THEORY

  BEGIN

  ASSUMING
    % Assume that different blobs always have different hashes
    unique_hash: ASSUMPTION
      FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
  ENDASSUMING

  K : TYPE = nat;

  IMPORTING pcr[HV];
  IMPORTING key[B,K,HV];
  IMPORTING ReturnCodes;
  IMPORTING startupData[B,K,HV];
  IMPORTING PermanentFlags;
  IMPORTING PermanentData[HV];

  SML : TYPE = list[HV];

  %% State monad output type
  tpmAbsOutput : DATATYPE
  BEGIN
    outNothing : outNothing?
    outError(m:ReturnCode) : outError?
    outQuote(oqk:KEY,oqnon:BLOB,oqpcrs:list[PCR],m:ReturnCode) : outQuote?
    outWrapKey(owk:wrapKey,m:ReturnCode) : outWrapKey?
    outAsymKey(oask:KEY,m:ReturnCode) : outAsymKey?
    outSymKey(osk:KEY,m:ReturnCode) : outSymKey?
    outBlob(obl:BLOB,m:ReturnCode) : outBlob?
    outCertReq(ocertaik:wrapKey,ocertek:(asymKey?), m:ReturnCode) : outCertReq?
    outIdentity(oidentaik:wrapKey,oidentc:(outCertReq?),
                m:ReturnCode) : outIdentity?
    outIdentActivation(oactc:(certBlob?),%osessk:(symKey?),oactek:(asymKey?),
                       m:ReturnCode) : outIdentActivation?
    outFullQuote(ofullqc:(certBlob?),ofullqsml:SML,ofullqq:(outQuote?),
                 m:ReturnCode) : outFullQuote?
    outPCR(pcr:PCR,m:ReturnCode) : outPCR?
    outMigKeyAuth(migKey:(asymKey?),migScheme:migrateScheme,digest:HV,
		  m:ReturnCode):outMigKeyAuth?
  END tpmAbsOutput;

  IMPORTING memory[tpmAbsOutput,outNothing];
  

  %% State monad input type.  All inputs are in the form of a command with
  %% parameters.
  tpmAbsInput : DATATYPE
  BEGIN
  %% Admin Startup and State commands (4)
    ABS_Reset : ABS_Reset? %unimplemented
    ABS_Init : ABS_Init? 
    ABS_SaveState : ABS_SaveState?
    ABS_Startup(startupType : TPM_STARTUP_TYPE) : ABS_Startup?
  %% Protected Storage Commands (10)
    ABS_Seal(sk:(asymKey?),data:BLOB) : ABS_Seal?
    ABS_Unseal(s:(sealBlob?),uk:(asymKey?)) : ABS_Unseal?   
    ABS_UnBind(inData:(encryptBlob?),dk:(asymKey?)) : ABS_UnBind?
    ABS_CreateWrapKey(parentk,keyInfo:(asymKey?)): ABS_CreateWrapKey?  
    ABS_LoadKey2(pk:(asymKey?),lk:wrapKey): ABS_LoadKey2? 
  %% Integrity Collection and Reporting (16)
    ABS_Extend(h:HV,i:PCRINDEX) : ABS_Extend?
    ABS_PcrRead(ind:PCRINDEX) : ABS_PcrRead?
    ABS_Quote(aik:wrapKey,nonce:BLOB,pm:PCRMASK) : ABS_Quote?
  %% Endorsement Key Handling (14)
    ABS_CreateEndorsementKeyPair(keyInfo:(asymKey?)) : ABS_CreateEndorsementKeyPair?
    ABS_ReadPubEK : ABS_ReadPubEK?
  %% Identity Creation and Activation (15)
    ABS_MakeIdentity(idKeyParams:(asymKey?)) : ABS_MakeIdentity?
    ABS_ActivateIdentity(caik:wrapKey,b:BLOB) : ABS_ActivateIdentity?
  %% Cryptographic Commands (13)
    ABS_Sign(sk:KEY,saik:wrapKey,sb:BLOB) : ABS_Sign?
  %% Admin Ownership Commands (6)
    ABS_TakeOwnership(srkParams:(asymKey?)) : ABS_TakeOwnership?
    ABS_OwnerClear(authK:(asymKey?)) : ABS_OwnerClear? 
    ABS_ForceClear : ABS_ForceClear? 
    ABS_DisableOwnerClear : ABS_DisableOwnerClear? 
    ABS_DisableForceClear : ABS_DisableForceClear? 
  %% Migration Commands (11)
    ABS_CreateMigrationBlob(pk:(asymKey?),m:migrateScheme,migKeyAuth:(outMigKeyAuth?),
			    encData:(encryptBlob?)) : ABS_CreateMigrationBlob?
    ABS_ConvertMigrationBlob(k:(asymKey?),inData:BLOB) : ABS_ConvertMigrationBlob?
    ABS_AuthorizeMigrationKey(migKey:(asymKey?),migScheme:migrateScheme) : ABS_AuthorizeMigrationKey?
    ABS_MigrateKey(migKey,pubKey:(asymKey?),data:BLOB) : ABS_MigrateKey?
  %% Changing AuthData (17)
    ABS_ChangeAuth : ABS_ChangeAuth?
  %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    ABS_save(i:nat,v:tpmAbsOutput) : ABS_save?
    ABS_read(i:nat) : ABS_read?
    ABS_Data_Bind(k:KEY,d:BLOB) : ABS_Data_Bind?
  %% CA Commands
    ABS_certify(aik:wrapKey,certReq:(outCertReq?)) : ABS_certify?
  %% Invented, imaginary Commands
    noopCom : noopCom?
  END tpmAbsInput;

  %% sinit blob instance for measurement
  sinit : B;

  %% mle blob instance for measurement
  mle : B;

  %% Initial key values not generated by TPM
  ekKeyVal : K = 0;
  srkKeyVal : K = 1;
  caKeyVal : K = 2;

  %% Initial key count value for initializing TPM
  initKeyVal : K = 100;

  %% Key definitions that make ek and srk values asymmetric keys.
  ekVal : KEY = asymKey(ekKeyVal,storage,keyFlagsF);
  srkVal : KEY = asymKey(srkKeyVal,storage,keyFlagsF);
  caVal : KEY = asymKey(caKeyVal,legacy,keyFlagsF); % Certificate Authority key

  %% Abstract TPM State with keys, PCR array and locality
  tpmAbsState : TYPE = [#
  	      	       restore : restoreStateData,
                       memory : mem,
                       postInit : bool,
                       srk : (asymKey?),
		       ek : (asymKey?),
		       keyGenCnt : K,
		       keys : KEYSET,
                       pcrs : PCRS,
		       locality : LOCALITY,
		       permFlags : PermFlags,
		       permData : PermData,
		       disableForceClear : bool
		    #];

  %% Well formedness condition for abstract states.  Currently unused, but we
  %% should show that forall commands, well formed input generates well formed
  %% output.

  wellFormed?(s:tpmAbsState):bool = wellFormedRestore?(restore(s));

  IMPORTING StateMonad[tpmAbsOutput,tpmAbsState];

  %% Define some common TPM states and state operations
  
  %% Unknown state
  tpmUnknown : tpmAbsState

  %% Power on state after init is raised by hardware.
  tpmPostInit : (wellFormed?) = (#
                         pcrs:=pcrsPower
			 , postInit:=true
                         , locality:=4
			 , keys:=emptyset
			 , srk:=private(srkVal)
			 , ek:=private(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsInit
			 , permData:=permDataInit
			 , disableForceClear:=FALSE
			 #);

  %% Standard initial state following startup command with the TPM_ST_CLEAR
  %% option set.  Note that this should be checked against the spec before
  %% asserting goodness.
  tpmStartup : (wellFormed?) = (#
                         pcrs:=pcrsReset(allResetAccess)
			 , postInit:=false
			 , locality:=4
			 , keys:=emptyset
			 , srk:=private(srkVal)
			 , ek:=private(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsInit
			 , permData:=permDataInit
			 , disableForceClear:=FALSE
			 #);

  %% Generate a new state from restore data.  Basically this is a clear
  %% restart with pcrs, keys, and pcr flags coming from the restore
  %% data.  Note that this function assumes valid data and will behave
  %% badly otherwise
  tpmRestore(rd:(wellFormedRestore?)) : (wellFormed?) = (#
                         pcrs:=pcrs(rd)
			 , postInit:=false
			 , locality:=4
			 , keys:=keys(rd)
			 , srk:=private(srkVal)
			 , ek:=private(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=rd
			 , permFlags:=permFlags(rd)
			 , permData:=permData(rd)
			 , disableForceClear:=FALSE
                         #)

  %% Predicate to determine if startup has occured.  Used as types
  %% (afterInit?) is the set of states occuring immediately after TPM_Init
  %% (afterStartup?) is the set of states occuring immediately after
  %% TPM_Startup
  afterInit?(s:tpmAbsState):bool = postInit(s);
  afterStartup?(s:tpmAbsState):bool = NOT postInit(s);

  %% Standard operations on TPM state definition above.  All such
  %% functions end with State to indicate they operate on the state
  %% value rather than on the TPM monad.  Note that key set and pcr
  %% manipulation functions are defined externally in key.pvs and
  %% pcr.pvs respectively

  %% Reset PCRs as performed by SENTER.
  pcrsResetSenterState(s:tpmAbsState) : tpmAbsState =
    s WITH [`pcrs := pcrsSenter(pcrs(s),pcrAttrib(permData(s)))];

  %% Decrease locality value
  changeLocalityState(s:tpmAbsState) : tpmAbsState =
    s WITH [`locality := IF locality(s) > 0
                         THEN locality(s) - 1
			 ELSE 0
			 ENDIF];
    
  %% Generate a new key
  genKeyState(s:tpmAbsState) : tpmAbsState =
    s WITH [`keyGenCnt := keyGenCnt(s)+1];

  createWrapKeyState(s:tpmAbsState,p,keyInfo:(asymKey?)) : tpmAbsState = 
    IF storage?(keyUsage(p)) 
       AND migratable(keyFlags(p))=FALSE AND migratable(keyFlags(keyInfo))=TRUE 
       AND not(identity?(keyUsage(keyInfo)) or authChange?(keyUsage(keyInfo)))
       AND migrateAuthority(keyFlags(keyInfo))=FALSE
      THEN genKeyState(s)
      ELSE s
    ENDIF;
  
  makeIdentityState(s:tpmAbsState,idKeyParams:(asymKey?)) : tpmAbsState = 
    IF identity?(keyUsage(idKeyParams)) AND migratable(keyFlags(idKeyParams))=FALSE
      THEN genKeyState(s)
      ELSE s
    ENDIF;
        

  %% Revoke key operation on TPM state
  revokeKeyState(s:tpmAbsState,k:wrapKey) : tpmAbsState =
    s WITH [`keys := removeKey(k,keys(s))];

  %% Install key operation on TPM state.
  loadKey2State(s:tpmAbsState,parentHandle:(asymKey?),k:wrapKey) : tpmAbsState =
    IF storage?(keyUsage(parentHandle)) AND parentHandle = parentKey(k)
      THEN CASES keyUsage(childKey(k)) OF
      	     identity: IF migratable(keyFlags(childKey(k)))=FALSE
	   	         THEN s with [`keys:=addKey(k,srk(s),keys(s))]
		     	 ELSE s
		       ENDIF,
	     authChange: s
	     ELSE s with [`keys:=addKey(k,srk(s),keys(s))]
	   ENDCASES
      ELSE s
    ENDIF;


  %% Extend operation on TPM state
  extendState(s:tpmAbsState,n:PCRINDEX,h:HV) : tpmAbsState =
    s WITH [`pcrs := pcrsExtend(pcrs(s),n,h)];

  createEndorsementKeyPairState(s:tpmAbsState, keyInfo:(asymKey?)) : tpmAbsState = 
    IF (ek(s) /= invalidKey)
      THEN s
      ELSE s WITH [`ek := private(keyInfo),
      	     	   `permFlags(CEKPUsed) := TRUE,
		   `permFlags(enableRevokeEK) := FALSE]
    ENDIF;


  % Use an AIK.
%   activateIdentityState(s:tpmAbsState,a:wrapKey,b:BLOB) : tpmAbsState =
%     loadKey2State(s,srk(s),a); %TODO: ARE WE SUPPOSED TO ACTUALLY DO THIS?

  takeOwnershipState(s:tpmAbsState,srkParams:(asymKey?)) : tpmAbsState =
   IF ownership(permFlags(s)) AND ek(s) /= invalidKey
     THEN s WITH [`srk:=srkParams,
      	     	  `permFlags(readPubek):=FALSE]
     ELSE s
   ENDIF;

  clear(s:tpmAbsState) : tpmAbsState = %not fully implemented
    s WITH [`keys:=emptyset,
      	    `permFlags(ownership):=TRUE,
	    `permFlags(operator):=FALSE,
	    `permFlags(maintenanceDone):=FALSE
      	   ]

  ownerClearState(s:tpmAbsState,auth:(asymKey?)) : tpmAbsState =
    IF auth = private(srk(s)) AND disableOwnerClear(permFlags(s))=FALSE
      THEN clear(s)
      ELSE s
    ENDIF

  forceClearState(s:tpmAbsState) : tpmAbsState = 
    IF s`disableForceClear=FALSE
      THEN clear(s)
      ELSE s
    ENDIF
  
  disableOwnerClearState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`permFlags(disableOwnerClear):=TRUE];

  disableForceClearState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`disableForceClear:=TRUE];

  saveState(s:tpmAbsState) : tpmAbsState =
    s WITH [`restore:=saveState(keys(s)
                                , ek(s)
		      		, srk(s)
				, keyGenCnt(s)
		      		, pcrs(s)
		      		, permFlags(s)
		      		, permData(s)
		      		)];

  restoreState(s:tpmAbsState) : tpmAbsState =
    IF valid?(restore(s))
       THEN LET rs=restore(s) IN
             (#
              restore := rs
	      , memory := memory(s)
	      , postInit := FALSE
	      , ek := ek(rs)
	      , srk := srk(rs)
	      , pcrs := pcrs(rs)
	      , keys := keys(rs)
	      , keyGenCnt:=keyGenCnt(rs)
	      , locality := 3
	      , permFlags := permFlags(rs)
	      , permData := permData(rs)
	      , disableForceClear := FALSE
            #)
       ELSE s
    ENDIF;

  % deactivate by going back to init.  Not sure this is correct.
  deactivateState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`postInit := TRUE];

  % save a value to external memory
  saveToMemState(s:tpmAbsState,i:nat,v:tpmAbsOutput) : tpmAbsState =
    s WITH [`memory := updateLoc(memory(s),i,v)];

  %% What we want to generate with each command is a pair of type
  %% [tpmAbsOut,tpmAbsState].  executeCom generates the the state
  %% from a TPM state and command while the upcoming outputCom
  %% generates the corresponding output.  Thus, to execute any
  %% operation, both executeCom and outputCom must be used

  %% Run if TPM_Init has run but TPM_Startup has not
  executeComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsState =
    CASES c OF
      ABS_Startup(t) : CASES t OF 
      		        TPM_ST_CLEAR : tpmStartup,
    			TPM_ST_STATE : restoreState(s),
    			TPM_ST_DEACTIVATED : deactivateState(s)
                       ENDCASES
      ELSE s
    ENDCASES;

  %% Run if ABS_Startup has run after TPM_Init
  executeComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsState = 
    CASES c OF
      ABS_LoadKey2(p,k): loadKey2State(s,p,k), 
      ABS_Extend(h,n) : extendState(s,n,h),
      ABS_CreateEndorsementKeyPair(k) : createEndorsementKeyPairState(s,k),
%       ABS_ActivateIdentity(a,b) : activateIdentityState(s,a,b),
      ABS_Init : tpmPostInit,
      ABS_CreateWrapKey(parent,k) : createWrapKeyState(s,parent,k),
      ABS_MakeIdentity(k) : makeIdentityState(s,k), 
      ABS_certify(aik,ek) : genKeyState(s),
      ABS_SaveState : saveState(s),
      ABS_TakeOwnership(srk) : takeOwnershipState(s,srk),
      ABS_OwnerClear(k): ownerClearState(s,k),
      ABS_ForceClear: forceClearState(s),
      ABS_DisableOwnerClear: disableOwnerClearState(s),
      ABS_DisableForceClear: disableForceClearState(s),
      ABS_senter : 
        changeLocalityState(extendState(pcrsResetSenterState(s),0,hash(sinit))),
      ABS_sinit : changeLocalityState(extendState(s,0,hash(mle))),
      ABS_save(i,v) : saveToMemState(s,i,v)
      ELSE s
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInit=true.
  executeCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsState =
    IF afterInit?(s)
       THEN executeComPostInit(s,c)
       ELSE executeComStartup(s,c)
    ENDIF;

  
  % Output secret sealed with asymmetric key 
  sealOut(s:tpmAbsState,k:(asymKey?),data:BLOB) : tpmAbsOutput = 
    IF data = nothing
      THEN outError(TPM_BAD_PARAMETER)
      ELSE outBlob(sealBlob(k,pcrs(s),data),TPM_SUCCESS)
    ENDIF

  % Output secret unsealed with an asymmetric key and PCRs 
  unsealOut(s:tpmAbsState,d:(sealBlob?),k:(asymKey?)) : tpmAbsOutput = 
    LET b:BLOB = unseal(d,pcrs(s),k) IN
    IF nothing?(b)
      THEN outError(TPM_NOTSEALED_BLOB)
      ELSE outBlob(b,TPM_SUCCESS)
    ENDIF

  % Output decrypted key
  unBindOut(s:tpmAbsState,d:(encryptBlob?),k:(asymKey?)) : tpmAbsOutput =
    LET b:BLOB = decrypt(d,k) IN
%% TODO: double check command specificiations... this might be okay without IF stmt
%      IF nothing?(b)
%        THEN outError()
%        ELSE 
       outBlob(b,TPM_SUCCESS)
%      ENDIF
    

  % Generate a NEW RANDOM key pair.
  createWrapKeyOut(s:tpmAbsState,parentHandle,keyInfo:(asymKey?)):tpmAbsOutput = 
      IF storage?(keyUsage(parentHandle)) 
      	 AND migratable(keyFlags(parentHandle))=FALSE AND migratable(keyFlags(keyInfo))=TRUE 
	 AND not(identity?(keyUsage(keyInfo)) or authChange?(keyUsage(keyInfo)))
	 AND migrateAuthority(keyFlags(keyInfo))=FALSE
	THEN LET wk:wrapKey = (# parentKey:=parentHandle,
	     	 	    childKey:=asymKey(keyGenCnt(s),keyUsage(keyInfo),keyFlags(keyInfo)) #)
	      	   IN outWrapKey(wk,TPM_SUCCESS)
	ELSE outError(TPM_INVALID_KEYUSAGE)
	ENDIF
    
  loadKey2Out(parentHandle:(asymKey?),k:wrapKey):tpmAbsOutput = 
    IF storage?(keyUsage(parentHandle))
      THEN IF parentHandle = parentKey(k)
      	     THEN LET usage = keyUsage(childKey(k)) IN
	     	  CASES usage OF
		    identity: IF migratable(keyFlags(childKey(k)))=FALSE
		    	        THEN outNothing
				ELSE outError(TPM_INVALID_KEYUSAGE)
			      ENDIF,
		    authChange: outError(TPM_INVALID_KEYUSAGE)
		    ELSE outNothing
		  ENDCASES
	     ELSE outError(TPM_DECRYPT_ERROR) %% Might not be right.
	   ENDIF
      ELSE outError(TPM_INVALID_KEYUSAGE)
    ENDIF;


  % Output PCR of given index
  pcrReadOut(s:tpmAbsState,ind:PCRINDEX) : tpmAbsOutput = 
  %% TODO: will ind not be allowed to be > 23 because of defn of PCRINDEX?
%     IF ind > 23
%       THEN outError(TPM_BADINDEX) 
%       ELSE 
      	   LET p = pcrs(s) IN outPCR(p(ind),TPM_SUCCESS)
%     ENDIF;

  % Output PCRs from a state as quote
  quoteOut(s:tpmAbsState,k:wrapKey,n:BLOB,pm:PCRMASK) : tpmAbsOutput =
  %% TODO: will pm be allowed to have elements > 23? see pcrReadOut 
%     IF some((LAMBDA (x:nat):x>23),pm)
%       THEN outError(TPM_INVALID_PCR_INFO)
%       ELSE 
      	   IF checkKeyRoot(k,srk(s))
      	     THEN outQuote(private(childKey(k)),n,getPCRs(s`pcrs,pm),TPM_SUCCESS)
      	     ELSE outError(TPM_INVALID_KEYUSAGE) %% TODO: double check this
	   ENDIF
%     ENDIF;


  % If ek doesn't exist, create a new ek from keyInfo
  createEndorsementKeyPairOut(s:tpmAbsState, keyInfo:(asymKey?)) : tpmAbsOutput = 
    IF (ek(s) /= invalidKey)
      THEN outError(TPM_DISABLED_CMD) 
      ELSE outAsymKey(keyInfo,TPM_SUCCESS) 
    ENDIF;
    %% TODO: should also output checksum hash of pubEndorsmentKey and antiReplay?

  readPubEKOut(s:tpmAbsState) : tpmAbsOutput =
    IF readPubek(permFlags(s))
      THEN IF ek(s) /= invalidKey
      	     THEN outAsymKey(ek(s),TPM_SUCCESS)
	     ELSE outError(TPM_NO_ENDORSEMENT)
	   ENDIF
      ELSE outError(TPM_DISABLED_CMD)
    ENDIF


  % Output a newly generated AIK.  Note that a simulates the new aik.
  makeIdentityOut(s:tpmAbsState,idKeyParams:(asymKey?)) : tpmAbsOutput =
    IF identity?(keyUsage(idKeyParams)) AND migratable(keyFlags(idKeyParams))=FALSE
      THEN LET idKey:wrapKey = (#
      	       	    parentKey:=srk(s),
		    childKey:=asymKey(keyGenCnt(s),keyUsage(idKeyParams),keyFlags(idKeyParams))
		    #) 
    		    IN outIdentity(idKey,outCertReq(idKey,ekVal,TPM_SUCCESS),TPM_SUCCESS)
      ELSE outError(TPM_INVALID_KEYUSAGE)
    ENDIF;

  % Retrieve a key if a can be installed
  % The command assumes the availability of the private key associated with the identity.
  % The command will verify the association between the keys during the process.
  % The command will decrypt the input blob and extract the session key and verify the
  % connection between the public and private keys. p 157
  activateIdentityOut(s:tpmAbsState,idKey:wrapKey,b:(certBlob?)) : tpmAbsOutput =
    IF identity?(keyUsage(childKey(idKey))) %AND checkKeyRoot(idKey,srk(s))
      THEN IF encrKey(b) = ekVal AND digest(b)=childKey(idKey)
	     THEN outSymKey(symK(b),TPM_SUCCESS)
	     ELSE outError(TPM_DECRYPT_ERROR) %% TODO: This may be wrong
	   ENDIF
      ELSE outError(TPM_BAD_PARAMETER)
    ENDIF;


  % Sign a blob if signing key isn't aik
  signOut(s:tpmAbsState,sk:KEY,aik:wrapKey,sb:BLOB) : tpmAbsOutput =
    IF sk /= childKey(aik)
     THEN outBlob(signBlob(sk,sb),TPM_SUCCESS)
     ELSE outError(TPM_INVALID_KEYUSAGE)
    ENDIF;
    
  % NEED TO ENSURE NEW, RANDOM SRK KEY PAIR
  % srkParams should = srkVal
  takeOwnershipOut(s:tpmAbsState,srkParams:(asymKey?)) : tpmAbsOutput =
  %% TODO: Lots of flags for this one.
    IF ownership(permFlags(s))
      THEN IF ek(s) /= invalidKey
      	     THEN outAsymKey(srkParams,TPM_SUCCESS)
	     ELSE outError(TPM_NO_ENDORSEMENT)
	   ENDIF
      ELSE outError(TPM_INSTALL_DISABLED)
    ENDIF

  ownerClearOut(s:tpmAbsState,auth:(asymKey?)) : tpmAbsOutput = 
    IF auth = private(srk(s))
      THEN IF disableOwnerClear(permFlags(s))
      	    THEN outError(TPM_CLEAR_DISABLED)
	    ELSE outNothing
	   ENDIF
      ELSE outError(TPM_AUTHFAIL)
    ENDIF

  forceClearOut(s:tpmAbsState) : tpmAbsOutput =
    IF disableForceClear(s)
      THEN outError(TPM_CLEAR_DISABLED)
      ELSE outNothing
    ENDIF

  checkMigKeyAuth?(s:tpmAbsState,a:(outMigKeyAuth?)):bool =
    true
%     digest(a)=hash(migKey(a)++migType(a)++tpmProof(permData(s)))
  
  createMigBlobOut(s:tpmAbsState,parent:(asymKey?),migType:migrateScheme,
			 migKeyAuth:(outMigKeyAuth?),encData:(encryptBlob?)) : tpmAbsOutput =
    IF storage?(keyUsage(parent))
    THEN IF parent=key(encData) 
      	 THEN IF checkMigKeyAuth?(s,migKeyAuth)
	      THEN CASES migType OF
      	   	   migrate : outError(TPM_INSTALL_DISABLED),%TODO: not correct in any sense.
      		   rewrap  : CASES blob(encData) OF 
		   	       keyBlob(k) : LET wk:wrapKey = (#parentKey:=migKey(migKeyAuth),
			       		    		       childKey:=k#)
		   	     			IN outWrapKey(wk,TPM_SUCCESS)
			       ELSE outError(TPM_INSTALL_DISABLED) %TODO: not correct!
			     ENDCASES
		   %ELSE outError(TPM_BAD_PARAMETER)
		   ENDCASES	
	      ELSE outError(TPM_INSTALL_DISABLED)%TODO: not at all correct.
	      ENDIF
	 ELSE outError(TPM_DECRYPT_ERROR)
	 ENDIF
    ELSE outError(TPM_INVALID_KEYUSAGE)
    ENDIF


  convertMigBlobOut(s:tpmAbsState,k:(asymKey?),inData:BLOB) : tpmAbsOutput
    %%outData = encrypted private key that can be loaded with tpm_loadkey 
    %%inData:BLOB may be wrong

  authorizeMigKeyOut(s:tpmAbsState,migKey:(asymKey?),migScheme:migrateScheme) : tpmAbsOutput = 
    outMigKeyAuth(migKey,migScheme,
			hash(%migKey++migScheme++tpmProof(permData(s))
				sinit), %% TODO: totally wrong... just placeholder
			TPM_SUCCESS);

  %% Decrypts the input packet (coming from TPM_CreateMigrationBlob) and then 
  %% re-encrypts it with the input public key. The output would then be sent to 
  %% TPM_ConvertMigrationBlob on the target TPM.
  migrateKeyOut(s:tpmAbsState,maKey,pubKey:(asymKey?),inData:(encryptBlob?)) : tpmAbsOutput =
    IF migrate?(keyUsage(maKey))
      %The TPM decripts inData and re-encrypts it using pubKey
      %THEN outBlob(encryptBlob(pubKey,blob(inData)),TPM_SUCCESS)
      THEN CASES blob(inData) OF
      	     keyBlob(key) : LET wk:wrapKey=(#parentKey:=pubKey,childKey:=key#)
      	      	       	   IN outWrapKey(wk,TPM_SUCCESS)
	     ELSE outError(TPM_INSTALL_DISABLED) %%TODO: not correct!
	   ENDCASES
      ELSE outError(TPM_INVALID_KEYUSAGE)
    ENDIF

  changeAuthOut(s:tpmAbsState) : tpmAbsOutput


  % Generate a certified AIK from an AIK.  Certification assumes that the
  % EK really does belong to the TPM.  We're abstracting away that check.
  certOut(s:tpmAbsState,aik:wrapKey,certReq:(outCertReq?)) : tpmAbsOutput =
    LET aik:wrapKey = ocertaik(certReq) IN
      outIdentActivation(certBlob(ocertek(certReq),childKey(aik),symKey(keyGenCnt(s))),TPM_SUCCESS);
    

  % Read a value and output
  readOut(s:tpmAbsState,i:nat) : tpmAbsOutput =
    memory(s)(i);
  
  dataBindOut(s:tpmAbsState,k:KEY,d:BLOB) : tpmAbsOutput = 
    outBlob(encryptBlob(k,d),TPM_SUCCESS);

  %% Run if TPM_Init has run but TPM_Startup has not
  outputComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsOutput =
    outNothing;

  %% Generate output from a command and state 
  %% Run if ABS_Startup has run after TPM_Init
  outputComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsOutput = 
    CASES c OF
      ABS_Seal(k,data) : sealOut(s,k,data),
      ABS_Unseal(d,k) : unsealOut(s,d,k),
      ABS_UnBind(d,k) : unBindOut(s,d,k),
      ABS_CreateWrapKey(parent,k) : createWrapKeyOut(s,parent,k),
      ABS_LoadKey2(p,k) : loadKey2Out(p,k),
      ABS_PcrRead(ind) : pcrReadOut(s,ind),
      ABS_Quote(k,n,pm) : quoteOut(s,k,n,pm),
      ABS_CreateEndorsementKeyPair(k) : createEndorsementKeyPairOut(s,k),
      ABS_ReadPubEK : readPubEKOut(s),
      ABS_MakeIdentity(a) : makeIdentityOut(s,a), 
      ABS_ActivateIdentity(a,b) : activateIdentityOut(s,a,b),
      ABS_Sign(sk,aik,sb) : signOut(s,sk,aik,sb),
      ABS_TakeOwnership(srk) : takeOwnershipOut(s,srk),
      ABS_OwnerClear(k) : ownerClearOut(s,k),
      ABS_ForceClear : forceClearOut(s),
      ABS_CreateMigrationBlob(pk,m,migKAuth,encData) : 
      				createMigBlobOut(s,pk,m,migKAuth,encData),
      ABS_ConvertMigrationBlob(k,data) : convertMigBlobOut(s,k,data),
      ABS_AuthorizeMigrationKey(mk,ms) : authorizeMigKeyOut(s,mk,ms),
      ABS_MigrateKey(mk,pubKey,data) : migrateKeyOut(s,mk,pubKey,data),
      ABS_ChangeAuth : changeAuthOut(s),
      ABS_certify(aik,cr) : certOut(s,aik,cr),
      ABS_read(i) : readOut(s,i),
      ABS_Data_Bind(k,d) : dataBindOut(s,k,d)
    ELSE outNothing
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInit=true.
  outputCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsOutput =
    IF afterInit?(s)
       THEN outputComPostInit(s,c)
       ELSE outputComStartup(s,c)
    ENDIF;



  %% CPU Command Definitions

  %% Requires use of bind
  CPU_saveOutput(i:nat) : [tpmAbsOutput -> State] =
      useOutputStateOutput(outNothing,
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    executeCom(s,ABS_save(i,a)))),
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    a)));

  CPU_read(i:nat) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_read(i))));

  %% Call SENTER 
  CPU_senter : State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_senter)));

  %% Reset the TPM by senter call - depreciated - DO NOT USE
  senterResetTPM : State = put(outNothing,tpmStartup);

  %% Measure sinit by senter call - depreciated - DO NOT USE
  %senterHashSinitTPM : State = TPM_Extend(hash(sinit),0);

  %% Call sinit for initial measurements
  CPU_sinit : State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_sinit)));
 
  %% Build a quote for the appraiser from the quote, cert, and log
  buildQuote(q:(outQuote?),ca:(outIdentActivation?),sml:SML,
             sessk:(symKey?)):tpmAbsOutput =
    IF sessk=symK(oactc(ca))
     THEN outFullQuote(oactc(ca),sml,q,TPM_SUCCESS)
     ELSE outError(TPM_INAPPROPRIATE_SIG) %% TODO: Double check this
    ENDIF;

  CPU_BuildQuoteFromMem(q,ca,sessk:nat,sml:SML):State =
    output(outNothing,
            (LAMBDA (s:tpmAbsState) :
	       LET theMem = memory(s) IN
	         IF outIdentActivation?(theMem(sessk))
		    AND outIdentActivation?(theMem(ca))
		    AND outQuote?(theMem(q))
                 THEN buildQuote(theMem(q),theMem(ca),sml,symK(oactc(theMem(sessk))))
		 ELSE outError(TPM_FAIL) %% TODO: Incorrect
		 ENDIF));

  %% CA Command Definitions
  %% Invoke the certification authority
  CA_certify(cr:(outCertReq?)) : State =
     modifyOutput(outNothing,
            (LAMBDA (s:tpmAbsState) :
	       executeCom(s,ABS_certify(ocertaik(cr),cr))),
            (LAMBDA (s:tpmAbsState) :
               outputCom(s,ABS_certify(ocertaik(cr),cr))));

  %% Assure the CA generates an appropriate cert from the AIK and Ek
  %% proved - Wed Jul 11 13:14:11 EDT 2012
  gen_cert: THEOREM 
    FORALL (aik:wrapKey,ek:(asymKey?),state:(afterStartup?)) :
      LET (a,s) = runState(
      	  	  CA_certify(outCertReq(aik,ek,TPM_SUCCESS)))
		  (state) IN
        a = outIdentActivation(
                 certBlob(ek,childKey(aik),symKey(keyGenCnt(s)-1)),
		 TPM_SUCCESS)
    AND s = state WITH [`keyGenCnt := keyGenCnt(state)+1];


  %% TPM Command Definitions - Note that all commands used by the TPM
  %% have the TPM suffix to distinguish from operations on tpm state.
  %% Commands thus far are defined as state transforming or output
  %% generating.  This does not exclude the eventuality of doing both.

  %% No-op - not a real TPM command
  TPM_Noop : [tpmAbsOutput -> State] =
    (LAMBDA (a:tpmAbsOutput): state((LAMBDA(s:tpmAbsState) : (a,s))));

  %% TPM is off - not a real TPM command
  TPM_Off : State = put(outNothing,tpmUnknown);

  %% Power up the TPM and hit the TPM_Init signal
  TPM_Init : State = put(outNothing,tpmPostInit);

  %% Save the TPM state in preparation for restore at startup
  TPM_SaveState : State =
    modify(outNothing,
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_SaveState)))
  
  %% Save state actually saves the correct information.
  %% proved - Fri Sep 14 11:20:25 CDT 2012
  save_state_post : THEOREM
    FORALL (s0:(afterStartup?)) : 
      LET (a,s) = runState(TPM_SaveState)(s0) IN
       LET save = restore(s) IN
        valid?(save)
	AND keys(save) = keys(s0)
	AND ek(save) = ek(s0)
	AND srk(save) = srk(s0)
	AND FORALL (i:PCRINDEX) : 
	      IF pcrReset(pcrAttrib(permData(save))(i))
	         THEN pcrs(save)(i) = resetOne
		 ELSE pcrs(save)(i) = pcrs(s0)(i)
	      ENDIF
	AND permFlags(save) = permFlags(s0)
	AND permData(save) = permData(s0)

  %% Start up the TPM after TPM_Init
  TPM_Startup(st:TPM_STARTUP_TYPE) : State =
    modify(outNothing,
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Startup(st))));

  %% TPM_Startup post condition covering three major cases: clear, restore
  %% state and deactivate.
  %% proved - Sat Sep 15 09:58:36 CDT 2012
  startup_post : THEOREM
    FORALL (s0:(afterInit?), f:TPM_STARTUP_TYPE) : 
      LET (a,s) = runState(TPM_Startup(f))(s0) IN
       LET save = restore(s) IN
        CASES f OF
          TPM_ST_CLEAR : s = tpmStartup,
	  TPM_ST_STATE : valid?(save) AND wellFormedRestore?(save) =>
	                      keys(save) = keys(s)
			      AND ek(save) = ek(s)
			      AND srk(save) = srk(s)
			      AND FORALL (i:PCRINDEX) : 
	      		      	    IF pcrReset(pcrAttrib(permData(save))(i))
	         		    THEN pcrs(save)(i) = resetOne
		 		    ELSE pcrs(save)(i) = pcrs(s)(i)
	      			    ENDIF
			      AND permFlags(save) = permFlags(s)
			      AND permData(save) = permData(s),
	  TPM_ST_DEACTIVATED : postInit(s)
        ENDCASES

  %% Prove that the only command that can run and do anyting folling a
  %% TPM_Init is TPM_Startup.  If anything else tries to run, nothing happens. 
  %% Note the use of an "anything" command in the first command sequence.
  startup_after_init: THEOREM 
    FORALL (s:tpmAbsState,a:tpmAbsOutput,c:tpmAbsInput) :
      NOT ABS_Startup?(c) =>
        LET (a0,s0) = runState(TPM_Init >> state(LAMBDA (s:tpmAbsState):(a,executeCom(s,c))))(s) IN
          LET (a1,s1) = runState(TPM_Init)(s) IN
	      s0=s1


  %% Prove that senter after power up results in reset PCRs followed by sinit
  %% measurement.
  %% proved - Tue Jun 12 15:31:12 CDT 2012
  resetMonad: THEOREM 
    FORALL (hv:HV, state:tpmAbsState) :
      LET (a,s) = runState(
      	          TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
      		  >> CPU_senter
      		  >> CPU_sinit)
      		  (state)
      IN s = changeLocalityState(
               changeLocalityState(
                 extendState(
                   extendState(pcrsResetSenterState(tpmStartup),0,hash(sinit)),0,hash(mle))))
      AND a = outNothing

  %% Extend PCR n with hash value h.
  TPM_Extend(h:HV,n:PCRINDEX):State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Extend(h,n))));

  %% Extend is antisymmetric if the hash values used for extension are
  %% not equal.  In this example we use the LET form to define
  %% commands directly with monad functions defined in StateMonad.pvs
  antisymmetryMonad: THEOREM 
    FORALL (hv0,hv1:HV,state:(afterStartup?)) :
      LET f1:State =
          modify(outNothing,
                 (LAMBDA (s:tpmAbsState):
		   s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv0)])),
      	f2:State =
          modify(outNothing,
                 (LAMBDA (s:tpmAbsState):
		   s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv1)])) IN
      hv0/=hv1 =>
        runState(
          f2 >>= (LAMBDA (x:tpmAbsOutput): f1))(tpmStartup)
        /=
        runState(
          f1 >>= (LAMBDA (x:tpmAbsOutput): f2))(tpmStartup)

  %% Extending a reset PCR is antisymmetric if the two values are not equal
  %% Let form used to defined commands for bind.  Will use command forms
  %% later in antisymmetryMonad3
  antisymmetryMonad2: THEOREM 
    FORALL (hv0,hv1:HV) :
      LET 
        f1:State = TPM_Extend(hv0,0),
      	f2:State = TPM_Extend(hv1,0) IN
      (hv0/=hv1 =>
        runState(f2 >> f1)(tpmStartup)
        /=
        runState(f1 >> f2)(tpmStartup))

  %% Extending a reset PCR is antisymmetric if the two values are not equal.
  %% No let form - commands appear directly in bind
  %% Theorem is now false when PCRs other than PCR0 are included.
  antisymmetryMonad3: THEOREM 
    FORALL (hv0,hv1:HV) :
      hv0/=hv1 =>
         runState(TPM_Extend(hv1,0)
		>> TPM_Extend(hv0,0))
	   (tpmStartup)
       /=
         runState(TPM_Extend(hv0,0)
		>> TPM_Extend(hv1,0))
	   (tpmStartup)


  %% Establish SRK
  TPM_TakeOwnership(srk:(asymKey?)) : State = 
     modifyOutput(outNothing,
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_TakeOwnership(srk))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_TakeOwnership(srk))));

  take_ownership_post: THEOREM FORALL (state:(afterStartup?),srk:(asymKey?)) : 
    LET (a,s) = runState(
		 TPM_TakeOwnership(srk))
		 (state) IN
    IF ownership(permFlags(s))
      THEN IF ek(s) /= invalidKey
      	     THEN a = outAsymKey(srk,TPM_SUCCESS) AND
     	     	  s = state WITH [`srk:=srk,
		      	    	  `permFlags(readPubek):=FALSE]
	     ELSE a = outError(TPM_NO_ENDORSEMENT) AND
      	     	  s = state
	   ENDIF
      ELSE a = outError(TPM_INSTALL_DISABLED) AND
      	   s = state
    ENDIF
		 
          
  TPM_OwnerClear(auth:(asymKey?)) : State = 
     modifyOutput(outNothing,
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_OwnerClear(auth))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerClear(auth)))
	    );

  owner_clear_post: THEOREM FORALL (state:(afterStartup?),k:(asymKey?)) : 
    LET(a,s) = runState(
	       TPM_OwnerClear(k))
	       (state) IN   
    IF k=private(srk(s))
      THEN IF disableOwnerClear(permFlags(s))
      	    THEN a=outError(TPM_CLEAR_DISABLED) AND keys(s)=keys(state)
	    ELSE a=outNothing AND keys(s) = emptyset AND 
	         ownership(permFlags(s)) = TRUE AND 
		 operator(permFlags(s)) = FALSE AND
		 maintenanceDone(permFlags(s)) = FALSE
	   ENDIF
      ELSE a=outError(TPM_AUTHFAIL) AND keys(s)=keys(state)
    ENDIF

  TPM_ForceClear : State = 
     modifyOutput(outNothing,
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_ForceClear)),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ForceClear))
	    );

  force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(
	       TPM_ForceClear)
	       (state) IN
	IF disableForceClear(state)
      	  THEN a=outError(TPM_CLEAR_DISABLED) AND keys(s)=keys(state)
	    ELSE a=outNothing AND keys(s) = emptyset AND 
	         ownership(permFlags(s)) = TRUE AND 
		 operator(permFlags(s)) = FALSE AND
		 maintenanceDone(permFlags(s)) = FALSE
    	ENDIF

  TPM_DisableOwnerClear : State = 
     modify(outNothing,
		(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableOwnerClear)));

  disable_owner_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(
    	       TPM_DisableOwnerClear)
	       (state) IN
      disableOwnerClear(permFlags(s)) = TRUE
      AND a = outNothing;

  TPM_DisableForceClear : State =
     modify(outNothing,
		(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableForceClear)));

  disable_force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(
    	       TPM_DisableForceClear)
	       (state) IN
      disableForceClear(s) = TRUE
      AND a = outNothing;

  TPM_AuthorizeMigrationKey(migKey:(asymKey?),migScheme:migrateScheme) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_AuthorizeMigrationKey(migKey,migScheme))));

  authorize_migration_key_post: THEOREM 
   FORALL (state:(afterStartup?),k:(asymKey?),scheme:migrateScheme) : 
    LET(a,s) = runState(
    	       TPM_AuthorizeMigrationKey(k,scheme))
	       (state) IN
      a=outMigKeyAuth(k,scheme,hash(sinit),TPM_SUCCESS)
      AND s=state

  TPM_CreateMigrationBlob(pk:(asymKey?),m:migrateScheme,mka:(outMigKeyAuth?),
			    d:(encryptBlob?)) : State = 
     output(outNothing,
	    (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateMigrationBlob(pk,m,mka,d))));

  create_mig_blob_post: THEOREM 
   FORALL (state:(afterStartup?),pk:(asymKey?),m:migrateScheme,
   	   mka:(outMigKeyAuth?),d:(encryptBlob?)) : 
    LET(a,s) = runState(
    	       TPM_CreateMigrationBlob(pk,m,mka,d))
	       (state) IN
      IF storage?(keyUsage(pk))
      THEN IF pk=key(d) 
      	   THEN IF checkMigKeyAuth?(state,mka)
	        THEN CASES m OF
      	   	   migrate : a=outError(TPM_INSTALL_DISABLED),%TODO: not correct in any sense.
      		   rewrap  : a=
		   	     CASES blob(d) OF
			       keyBlob(k) : outWrapKey((#parentKey:=migKey(mka),
							 childKey:=k#),
						       TPM_SUCCESS)
			       ELSE outError(TPM_INSTALL_DISABLED) %%TODO: incorrect!
			     ENDCASES
		   %ELSE outError(TPM_BAD_PARAMETER)
		   ENDCASES	
	        ELSE a=outError(TPM_INSTALL_DISABLED)%TODO: not at all correct.
	        ENDIF
	   ELSE a=outError(TPM_DECRYPT_ERROR)
	   ENDIF
      ELSE a=outError(TPM_INVALID_KEYUSAGE)
      ENDIF
      AND s=state 

  TPM_ConvertMigrationBlob(k:(asymKey?),inData:BLOB) : State =
     output(outNothing,
	    (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_ConvertMigrationBlob(k,inData))));

  TPM_MigrateKey(migKey,pubKey:(asymKey?),data:BLOB) : State =
     output(outNothing,
	    (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_MigrateKey(migKey,pubKey,data))));

  migrate_key_post: THEOREM 
   FORALL (state:(afterStartup?),mk,k:(asymKey?),d:(encryptBlob?)) : 
    LET(a,s) = runState(
    	       TPM_MigrateKey(mk,k,d))
	       (state) IN
    IF migrate?(keyUsage(mk))
      THEN a = 
      	   CASES blob(d) OF
      	     keyBlob(key) : outWrapKey((#parentKey:=k,childKey:=key#),
				       TPM_SUCCESS)
	     ELSE outError(TPM_INSTALL_DISABLED) %%TODO: not correct!
	   ENDCASES
      ELSE a = outError(TPM_INVALID_KEYUSAGE)
    ENDIF
  
  %% Wrap new key k with parent key
  TPM_CreateWrapKey(parent,keyInfo:(asymKey?)) : State = 
     modifyOutput(outNothing,
	  (LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_CreateWrapKey(parent,keyInfo))),
          (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateWrapKey(parent,keyInfo)))
	      );

  create_wrap_key_post: THEOREM 
    FORALL (p,keyInfo:(asymKey?),state:(afterStartup?)) : 
      LET (a,s) = runState(
     	          TPM_CreateWrapKey(p,keyInfo))
		  (state) IN
      IF storage?(keyUsage(p)) 
      	 AND migratable(keyFlags(p))=FALSE AND migratable(keyFlags(keyInfo))=TRUE 
	 AND not(identity?(keyUsage(keyInfo)) or authChange?(keyUsage(keyInfo)))
	 AND migrateAuthority(keyFlags(keyInfo))=FALSE
        THEN LET wk : wrapKey = (# parentKey:=p, 
                              childKey:=asymKey(keyGenCnt(state),keyUsage(keyInfo),keyFlags(keyInfo)) #) IN
             	 a = outWrapKey(wk,TPM_SUCCESS)
      	     AND s = state WITH [`keyGenCnt := keyGenCnt(state)+1]
        ELSE 	 a = outError(TPM_INVALID_KEYUSAGE)
      	     AND s = state
      ENDIF

  %% Install key k in a TPM
  TPM_LoadKey2(p:(asymKey?),k:wrapKey):State =
    modifyOutput(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_LoadKey2(p,k))),
	   (LAMBDA (s:tpmAbsState):outputCom(s,ABS_LoadKey2(p,k))));

  % A key is installed if it is wrapped with SRK
  load_key_post: THEOREM 
    FORALL (p:(asymKey?),k:wrapKey,state:(afterStartup?)) :
      LET (a,s) = runState(
    		    TPM_LoadKey2(p,k))
		    (state) IN
    IF storage?(keyUsage(p))
      THEN IF p=parentKey(k)
      	     THEN LET usage = keyUsage(childKey(k)) IN
	     	  CASES usage OF
		    identity: IF migratable(keyFlags(childKey(k)))=FALSE
		    	        THEN a=outNothing
				     AND s=state with [`keys:=addKey(k,srk(state),keys(state))]
				ELSE a=outError(TPM_INVALID_KEYUSAGE)
				     AND s=state
			      ENDIF,
		    authChange: a=outError(TPM_INVALID_KEYUSAGE)
		    		AND s=state
		    ELSE a=outNothing
		    	 AND s=state with [`keys:=addKey(k,srk(state),keys(state))]
		  ENDCASES
	     ELSE a=outError(TPM_DECRYPT_ERROR) %% Might not be right.
	     	  AND s=state
	   ENDIF
      ELSE a=outError(TPM_INVALID_KEYUSAGE)
      	   AND s=state
    ENDIF;

  loadKey?(p:(asymKey?),k:wrapKey):bool=
    storage?(keyUsage(p))
      AND p=parentKey(k) AND
      	      LET usage = keyUsage(childKey(k)) IN
	     	  CASES usage OF
		    identity: IF migratable(keyFlags(childKey(k)))=FALSE
		    	        THEN TRUE
				ELSE FALSE
			      ENDIF,
		    authChange: FALSE
		    ELSE TRUE
		  ENDCASES

  load_key_pred_test: THEOREM
    FORALL (p:(asymKey?),k:wrapKey,state:(afterStartup?)) :
      LET (a,s) = runState(
    		    TPM_LoadKey2(p,k))
		    (state) IN
	IF loadKey?(p,k)
	  THEN a=outNothing
	       AND s=state with [`keys:=addKey(k,srk(state),keys(state))]
	  ELSE IF storage?(keyUsage(p)) AND p/=parentKey(k) 
	         THEN a=outError(TPM_DECRYPT_ERROR)
		 ELSE a=outError(TPM_INVALID_KEYUSAGE)
	       ENDIF
	       AND s=state
	ENDIF

  %% A key is installed if it is wrapped with an installed key
  %% proved - Tue Jun 12 15:38:22 CDT 2012
  load_key_post2: THEOREM 
    FORALL (j,k:wrapKey,p:(asymKey?),state:(afterStartup?)) :
      LET (out,s) = runState(
      	  	  TPM_LoadKey2(p,k)
		  >> TPM_LoadKey2(childKey(k),j))
		  (state) IN
	p=srk(state) AND loadKey?(p,k) AND loadKey?(childKey(k),j)
		=> member(childKey(j),keys(s));


  load_key_prev_post: THEOREM 
    FORALL (k,p:(asymKey?),state:(afterStartup?)) :
      LET (out,s) = runState(
      	  	    TPM_CreateWrapKey(p,k)
		    >>= CPU_saveOutput(0)
		    >>= (LAMBDA (a:tpmAbsOutput) :
		    	 CASES a OF
		           outWrapKey(wk,m) : TPM_LoadKey2(p,wk)
			   ELSE TPM_Noop(a)
			 ENDCASES))
		    (state) IN 
      checkKey(p,srk(state),keys(state)) AND loadKey?(p,owk(memory(s)(0))) =>
     		%member(asymKey(keyGenCnt(state),keyUsage(k),keyFlags(k)),keys(s))
      out = outNothing
      

  %%install nested wrapped keys? - IS THIS PROOF WORTH DOING?
%   nested_wrapped_keys_post: THEOREM 
%     FORALL (p,kInfo1,kInfo2:(asymKey?),state:(afterStartup?)) :
%       LET (a,s) = runState(
% 		  TPM_CreateWrapKey(p,kInfo1)
% 		  >>= CPU_saveOutput(0)
% 		  >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       CASES a OF 
% 		         outWrapKey(wk,m) : TPM_LoadKey2(p,wk) 
% 			 ELSE TPM_Noop(a) 
% 		       ENDCASES)
% 		  >>= (LAMBDA (a:tpmAbsOutput) :
% 		       CASES a OF
% 		         outWrapKey(wk,m) : TPM_CreateWrapKey(childKey(wk),kInfo2)
% 			 ELSE TPM_Noop(a)
% 		       ENDCASES)
% 		  >>= CPU_saveOutput(1)
% 		  >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       CASES a OF
% 		         outWrapKey(wk2,m) : TPM_LoadKey2(p,wk2) 
% 			 ELSE TPM_Noop(a) 
% 		       ENDCASES))
% 		  (state) IN
% 	checkKey(p,srk(s),keys(s)) AND outWrapKey?(memory(s)(1)) =>
% 		 member(childKey(owk(memory(s)(1))),keys(s)) 
% % 	AND member(k,keys(s))
% 	AND a = outNothing

  TPM_CreateEndorsementKeyPair(k:(asymKey?)) : State =
     %% TODO: Perm Data stuff with RNG
     modifyOutput(outNothing,
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_CreateEndorsementKeyPair(k))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_CreateEndorsementKeyPair(k)))
	    );

  create_endorsement_key_pair_post: THEOREM
    FORALL (state:(afterStartup?),k:(asymKey?)) : 
      LET (a,s) = runState(
      	  	  TPM_CreateEndorsementKeyPair(k))
		  (state) IN
      IF (ek(state) = invalidKey)
        THEN a = outAsymKey(k,TPM_SUCCESS) AND 
	     s = state WITH [`ek := private(k),
      	     	       	    `permFlags(CEKPUsed) := TRUE,
		   	    `permFlags(enableRevokeEK) := FALSE]
        ELSE a = outError(TPM_DISABLED_CMD) AND 
	     s = state
      ENDIF;

  TPM_ReadPubEK : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ReadPubEK)));

  read_pub_ek_post: THEOREM
    FORALL (state:(afterStartup?)) : 
      LET (a,s) = runState(
      	  	  TPM_ReadPubEK)
		  (state) IN
      IF readPubek(permFlags(state))
        THEN IF ek(state) /= invalidKey
	       THEN a=outAsymKey(ek(state),TPM_SUCCESS)
	       ELSE a=outError(TPM_NO_ENDORSEMENT)
	     ENDIF
	ELSE a=outError(TPM_DISABLED_CMD)
      ENDIF


  %% Make a new identity and output it
  TPM_MakeIdentity(idKeyParams:(asymKey?)) : State =
     modifyOutput(outNothing,
	    (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_MakeIdentity(idKeyParams))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_MakeIdentity(idKeyParams)))
	    );

  make_identity_post: THEOREM 
    FORALL (state:(afterStartup?),idKeyParams:(asymKey?)) :
      LET (a,s) = runState(
     	 	   TPM_MakeIdentity(idKeyParams))
		 (state) IN
        LET waik:wrapKey = (# parentKey:=srk(s),
	    		   childKey:=asymKey(keyGenCnt(state),
					     keyUsage(idKeyParams),
					     keyFlags(idKeyParams)) 
			   #) IN
      IF identity?(keyUsage(idKeyParams)) AND not(migratable(keyFlags(idKeyParams)))
        THEN a = outIdentity(waik,outCertReq(waik,ekVal,TPM_SUCCESS),TPM_SUCCESS)
	     AND s = state WITH [`keyGenCnt := keyGenCnt(state)+1]
	ELSE a = outError(TPM_INVALID_KEYUSAGE)
	     AND s = state
      ENDIF;
   
  %% Use an AIK
  TPM_ActivateIdentity(a:wrapKey,b:BLOB) : State =
     modifyOutput(outNothing,
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_ActivateIdentity(a,b))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ActivateIdentity(a,b)))
	    );

  %% Assure that activate idenity installs its AIK and returns K if AIK can
  %% be installed.
  activate_identity_post: THEOREM 
    FORALL (aik:wrapKey,b:BLOB,state:(afterStartup?)) :
      LET (a,s) = runState(
                  TPM_ActivateIdentity(aik,b))
		  (state) IN     
      IF identity?(keyUsage(childKey(aik))) 
      	 	AND encrKey(b)=ekVal 
	 	AND digest(b)=childKey(aik)
      	 	%AND checkKeyRoot(aik,srk(state))
        THEN a=outSymKey(symK(b),TPM_SUCCESS)
	ELSE a=outError(TPM_DECRYPT_ERROR) OR a=outError(TPM_BAD_PARAMETER)
      ENDIF
     % AND checkKeyRoot(aik,srk(s)) => member(childKey(aik),keys(s));


  % need to get oiaik to TPM_ActivateIdentity somehow... using mem?
%   activate_prev_post: THEOREM 
%     FORALL (state:(afterStartup?),idKeyParams:(asymKey?)) :
%       LET  (a,s) = runState(
%  		   TPM_MakeIdentity(idKeyParams) % identity is output
% 		   >>= CPU_saveOutput(0)
% 		   >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       	CASES a OF
% 		          outIdentity(oiaik,cr,m) : CA_certify(cr)
% 			  ELSE TPM_Noop(a)
% 			ENDCASES)
% 		   >>= CPU_saveOutput(1)
% 		   >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       	CASES a OF
% 		          outIdentActivation(cb,m) : TPM_ActivateIdentity(oidentaik(memory(*)(0)),cb)
% 			  ELSE TPM_Noop(a)
% 			ENDCASES))
% 		  (state) IN
%        LET waik=oidentaik(memory(s)(0)), cb=oactc(memory(s)(1)) IN
%       identity?(keyUsage(idKeyParams))
% 	AND encrKey(cb) = ekVal AND digest(cb)=childKey(waik) =>
%       a = outSymKey(symK(cb),TPM_SUCCESS)
%        %AND member(childKey(aik),keys(s));


  %% Generate and output a signature
  TPM_Sign(k:KEY,aik:wrapKey,b:BLOB) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Sign(k,aik,b))));
	   
  sign_post: THEOREM 
    FORALL (k:KEY,aik:wrapKey,b:BLOB,state:(afterStartup?)) :
      LET(out,s) = runState(
     		  TPM_Sign(k,aik,b))
		  (state) IN
	IF k /= childKey(aik)
	   THEN out = outBlob(signBlob(k,b),TPM_SUCCESS)
	   ELSE out = outError(TPM_INVALID_KEYUSAGE)
	ENDIF
	AND s = state;
% TODO: Need to test to make sure aik parameter is actual aik?

	           	  
  %% Output PCR(i)
  TPM_PcrRead(i:PCRINDEX) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PcrRead(i))));

  pcr_read_post: THEOREM
    FORALL (i:PCRINDEX,state:(afterStartup?)) : 
      LET(a,s) = runState(
     		  TPM_PcrRead(i))
		  (state) IN
	a = outPCR(pcrs(s)(i),TPM_SUCCESS)
	AND s = state;


  %% Generate and output a quote
  TPM_Quote(k:wrapKey,n:BLOB,pm:PCRMASK) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Quote(k,n,pm))));

  %% If nonces don't match, quotes don't match.  We don't care about this
  %% if the a quote cannot be produced.
  %% proved - Fri Jun 22 16:55:16 CDT 2012
  bad_nonce: THEOREM
    FORALL (k:wrapKey, n1,n2:BLOB, pm:PCRMASK, s:tpmAbsState) :
      n1/=n2 AND checkKeyRoot(k,srk(s)) 
      AND afterStartup?(s) =>
       runState(
         TPM_Quote(k,n1,pm))
	 (s)
       /=
       runState(
	 TPM_Quote(k,n2,pm))
	 (s);
  
  %% Bad Signing Key - Man in the Middle Attack - we don't care about this
  %% if either key won't produce a quote.
  %% proved - Fri Jun 22 16:55:56 CDT 2012
  bad_signing_key: THEOREM
    FORALL (n:BLOB, pm:PCRMASK, k0,k1:wrapKey, s:tpmAbsState) :
      LET (a0,s0) = runState(TPM_Quote(k0,n,pm))(s) IN
        LET (a1,s1) = runState(TPM_Quote(k1,n,pm))(s) IN
          private(childKey(k0)) /= private(childKey(k1)) 
	  AND checkKeyRoot(k0,srk(s))
	  AND checkKeyRoot(k1,srk(s))
	  AND afterStartup?(s)
          =>
	  a0 /= a1;
     
  %% Output after going through tpm commands is same as grabbing pcrs
  %% This is one of those theorems where assert must be called before grind
  %% proved - Fri Jun 22 16:56:08 CDT 2012
  check_PCRS: THEOREM (
    FORALL (k:wrapKey,hv:HV,pm:PCRMASK,n:BLOB,state:(afterStartup?)) :
      LET (a,s) = runState(
        	  TPM_Extend(hv,0)
        	  >> TPM_Quote(k,n,pm))
      		  (state) IN
    checkKeyRoot(k,srk(s)) => 
      a = outQuote(private(childKey(k)),n,map(s`pcrs,pm),TPM_SUCCESS));

  %% Prove that quote generation returns the correct PCR.  This theorem
  %% needs to be updated with something cleaner.
  %% proven - Wed Jul 11 10:40:28 EDT 2012
  quote_post: THEOREM 
    FORALL (k:wrapKey,n:BLOB,p:PCRINDEX,state:(afterStartup?)) :
        LET (a,s) = runState(
      	    	    TPM_Quote(k,n,cons(p,null)))
		    (state) IN 
	checkKeyRoot(k,srk(state)) => 
        a = outQuote(private(childKey(k)),
	             n,
		     cons(s`pcrs(p),null),TPM_SUCCESS)
	AND s = state
      
  %% TODO: need way to reference waik in proof.
  quote_with_prev_key: THEOREM
    FORALL (state:tpmAbsState,k,idKeyParams:(asymKey?),n:BLOB,
            pm:PCRMASK) :
      LET (a,s) = runState(
      	  	  TPM_Init
		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_MakeIdentity(idKeyParams)
		  >>=CPU_saveOutput(0)
		  >>= (LAMBDA (a:tpmAbsOutput) : 
		       CASES a OF 
		         outIdentity(waik,creq,m) : TPM_Quote(waik,n,pm) 
			 ELSE TPM_Noop(a) 
		       ENDCASES))
		  (state) IN
		  LET waik=oidentaik(memory(s)(0)) IN
	checkKeyRoot(waik,srk(s)) => 
        a = outQuote(private(asymKey(100,keyUsage(idKeyParams),keyFlags(idKeyParams))),
	             n,
                     map(pcrs(s),pm),
		     TPM_SUCCESS)
	


  %% Seal and output a blob (should be binary or data)
  TPM_Seal(k:(asymKey?),data:BLOB) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Seal(k,data))));

  %% Seal a secret successfully
  seal_post: THEOREM
    FORALL (k:(asymKey?),b:BLOB,state:(afterStartup?)) :
      LET (a,s) = runState(
     	 	  TPM_Seal(k,b))
 		  (state) IN
	IF nothing?(b) 
	  THEN a = outError(TPM_BAD_PARAMETER) 
	  ELSE a = outBlob(sealBlob(k,s`pcrs,b),TPM_SUCCESS)
	ENDIF
	AND s = state


  %% Unseal and output a blob (should be binary or data)
  TPM_Unseal(d:(sealBlob?),k:(asymKey?)) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Unseal(d,k))));

  unseal_post: THEOREM
    FORALL (j,k:(asymKey?),b:BLOB,pcrs:PCRS,state:(afterStartup?)) :
      LET (out,s) = runState(
                    TPM_Unseal(sealBlob(k,pcrs,b),j))
		    (state) IN
      IF j=private(k) AND pcrs=pcrs(s) AND not(nothing?(b))
         THEN out=outBlob(b,TPM_SUCCESS)
         ELSE out=outError(TPM_NOTSEALED_BLOB) 
      ENDIF 
      AND s = state;  

  unseal_prev_post: THEOREM
    FORALL (k,j:(asymKey?),b:BLOB,pcrs:PCRS,state:(afterStartup?)) :
      LET (out,s) = runState(
      	  	  TPM_Seal(k,b)
		  >>= (LAMBDA (a:tpmAbsOutput) : 
		       CASES a OF
		         outBlob(obl,m) : CASES obl OF
			 		    sealBlob(key,pcrs,blob) :
		       			    	TPM_Unseal(obl(a),j) 
		       				ELSE TPM_Noop(a)
						ENDCASES
			 ELSE TPM_Noop(a)
		       ENDCASES))
		  (state) IN  
	j=private(k) AND pcrs=pcrs(s) AND not(nothing?(b))
	   => out = outBlob(b,TPM_SUCCESS)      
	AND s = state


  %% UnBind encrypted blob (decrypt)
  TPM_UnBind(d:(encryptBlob?),k:(asymKey?)) : State = 
     output(outNothing,
	    (LAMBDA (s:tpmAbsState): outputCom(s,ABS_UnBind(d,k))));

  %% UnBind an encrypted blob successfully
  unBind_post: THEOREM
    FORALL (k,j:(asymKey?),b:BLOB,state:(afterStartup?)) : 
      LET (a,s) = runState(
		  TPM_UnBind(encryptBlob(j,b),k))
		  (state) IN
      j = private(k) =>
         a = outBlob(b,TPM_SUCCESS)
     AND s = state

	
  Tspi_Data_Bind(k:KEY,d:BLOB) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Data_Bind(k,d))));

  %% UnBind an encrypted blob successfully
  unBind_prev_post: THEOREM 
    FORALL (d:BLOB,k,j,jInfo:(asymKey?),state:tpmAbsState) : 
      LET (a,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_CreateWrapKey(j,jInfo)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		      CASES a OF 
		        outWrapKey(owk,m) : TPM_LoadKey2(j,owk) 
			ELSE TPM_Noop(a) 
			ENDCASES
		  >> Tspi_Data_Bind(k,d)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		      CASES a OF
		        outBlob(obl,m) : CASES obl OF
				           encryptBlob(key,blob) : 
					   	TPM_UnBind(obl,private(k)) 
						ELSE TPM_Noop(a) ENDCASES
			ELSE TPM_Noop(a) 
		      ENDCASES)
 		  (state) IN 
 	  j = srk(s) OR  member(j,keys(s)) => 
	  a = outBlob(d,TPM_SUCCESS)
	

  %% Monotonicity of locality
  %% Assuming that we're not resetting or powering on, locality goes down
  %% or remains the same
  %% proved - Fri Sep 21 15:07:30 CDT 2012
  monotonic_locality: THEOREM 
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Init?(c) or ABS_Startup?(c)) =>
        locality(s) >= locality(executeCom(s,c));

  pcrs_unchanged: THEOREM 
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Extend?(c) or ABS_Startup?(c) or 
	  ABS_sinit?(c) or ABS_senter?(c) or 
	  ABS_Init?(c)) =>
      pcrs(s) = pcrs(executeCom(s,c));

  srk_unchanged: THEOREM 
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c) or
      	  ABS_TakeOwnership?(c)) =>
        srk(s) = srk(executeCom(s,c));

  ek_unchanged: THEOREM 
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c) or
          ABS_CreateEndorsementKeyPair?(c) ) =>
        ek(s) = ek(executeCom(s,c));

  keys_unchanged: THEOREM 
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c) or 
    	  ABS_LoadKey2?(c) or ABS_ActivateIdentity?(c) or
	  ABS_OwnerClear?(c) or ABS_ForceClear?(c)) =>
      keys(s) = keys(executeCom(s,c));

  postInit_unchanged: THEOREM 
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c)) =>
        postInit(s) = postInit(executeCom(s,c));

  disableForceClear_unchanged: THEOREM
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c) or
      	  ABS_DisableForceClear?(c)) =>
        disableForceClear(s) = disableForceClear(executeCom(s,c));

  restore_unchanged: THEOREM
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c) or
      	  ABS_SaveState?(c)) =>
        restore(s) = restore(executeCom(s,c));

  memory_unchanged: THEOREM
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c) or
      	  ABS_save?(c)) =>
        memory(s) = memory(executeCom(s,c));

  permFlags_unchanged: THEOREM
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c) or
          ABS_DisableOwnerClear?(c) or ABS_ForceClear?(c) or
	  ABS_OwnerClear?(c) or ABS_TakeOwnership?(c)) =>
        permFlags(s) = permFlags(executeCom(s,c));

  permData_unchanged: THEOREM
    FORALL (s:tpmAbsState,c:tpmAbsInput) :
      not(ABS_Startup?(c) or ABS_Init?(c)) =>
        permData(s) = permData(executeCom(s,c));
  

  %% Prove that skipping SENTER is detectable by showing the quote following
  %% a command differs when SENTER is excluded.
  %% proved - Tue Jun 12 15:34:24 CDT 2012
  no_senter: THEOREM 
    FORALL (k:wrapKey,hv:HV,n:BLOB,pcrMask:PCRMASK,state:tpmAbsState) :
      runState(
	TPM_Init
      	>> TPM_Startup(TPM_ST_CLEAR)
      	>> CPU_senter
      	>> CPU_sinit
      	>> TPM_Extend(hv,0)
      	>> TPM_Quote(k,n,pcrMask))
      	(state)
      /=
      runState(
	TPM_Init
	>> TPM_Extend(hv,0)
	>> TPM_Quote(k,n,pcrMask))
	(state)

  %% TPMs will not lie about who they are.  If the AIK cannot be installed
  %% then no quote will be generated
  %% proved - Wed Jul 11 11:28:46 EDT 2012
  aik_binding: THEOREM
    FORALL (aik:wrapKey,b:BLOB,pm:PCRMASK,state:tpmAbsState) :
      LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_Quote(aik,b,pm))
		  (state) IN
       NOT checkKeyRoot(aik,srk(s)) => out=outError(TPM_INVALID_KEYUSAGE);

   %% Simple verification of the quote generation process from init
   %% through generation of the appraiser's quote.  Yay.  This is what
   %% I was after!!
   %%
   %% Memory map:  
   %% 0 -> identity
   %% 1 -> CA cert
   %% 2 -> TPM quote
   %%
   %% Note that the identity is not used in building the final
   %% appraiser's quote
   %% proved Sat Jul 14 11:19:56 CDT 2012
%    cert_and_quote_with_prev_key: THEOREM
%      FORALL (state:tpmAbsState,
% 	     n:BLOB,
% 	     pm:PCRMASK,
% 	     idKeyParams:(asymKey?),
% 	     sml:SML) :
%        LET (out,s) = runState(
%                    TPM_Init
%  		   >> TPM_Startup(TPM_ST_CLEAR)
%  		   >> CPU_senter
%  		   >> CPU_sinit
%  		   >> TPM_MakeIdentity(idKeyParams) % identity is output
% 		   >>= CPU_saveOutput(0)
% 		   >>= (LAMBDA (a:tpmAbsOutput) :
% 		         CASES a OF
% 			   outIdentity(ik,rc) : CA_certify(outCertReq(ik,ek(state),k,TPM_SUCCESS))
% 			   ELSE TPM_Noop(a)
% 			 ENDCASES)
% 	           >>= CPU_saveOutput(1)
% 	           >>= (LAMBDA (a:tpmAbsOutput) :
% 		         CASES a OF
% 			   outIdentActivation(actc,sk,actek,rc) : TPM_ActivateIdentity(wkey(actc),sk)
% % =======
% % 			   outIdentActivation(oiacb,oiawk,rc) : TPM_ActivateIdentity(oiawk,oiacb)
% % >>>>>>> Stashed changes
% 			   ELSE TPM_Noop(a)
% 			 ENDCASES)
% 		   >> CPU_read(0)
% 		   >>= (LAMBDA (a:tpmAbsOutput) :
% 		         CASES a OF 
% 			   outIdentity(aik,rc) : TPM_Quote(aik,n,pm)
% 			   ELSE TPM_Noop(a)
% 			 ENDCASES)
% 		   >>= CPU_saveOutput(2) % Quote is saved in 2
% 		   >> CPU_BuildQuoteFromMem(2,1,1,sml) % Build the quote
% 		   )
%  		   (state) IN
% 		   LET wk:wrapKey = (# parentKey:= private(srkVal),
%                                        childKey := asymKey(100,keyUsage(idKeyParams),keyFlags(idKeyParams)) #)
% 				       IN
%          out = outFullQuote(certBlob(private(caVal),wk),
%                                sml,
%                                outQuote(private(asymKey(100,keyUsage(idKeyParams),keyFlags(idKeyParams))),
%                                         n,
%                                         map
%                                         ((pcrsSenter(pcrsReset(pcrAttrib(permData(s))),pcrAttrib(permData(s)))
%                                           WITH [(0)
%                                                 := extend
%                                                    (extend
%                                                     (reset, hash(sinit)),
%                                                     hash(mle))]),
%                                          pm),
% 					 TPM_SUCCESS),
% 				TPM_SUCCESS)	    
END tpm
