%% ----
%%
%% TPM Theory
%%
%% Author: Perry Alexander, Brigid Halling
%% Date: Mon Nov 28 01:09:39 CST 2011
%%
%% Description: Basic model of a TPM using a monadic state model
%% 
%% Dependencies:
%%  StateMonad.pvs
%%  ReturnCodes.pvs
%%  memory.pvs 
%%  StclearFlags.pvs
%%  startupData.pvs
%%  PermanentData.pvs
%%  StanyData.pvs
%%  StanyFlags.pvs
%%  key.pvs
%%  data.pvs
%%  keyData.pvs
%%  pcr.pvs
%%  authdata.pvs
%%  PermanentFlags.pvs
%%
%% Todo: (key - => pending, + => done)
%% ----

%% Standard Error IDs
%%  0 = "Bad identity record"
%%  1 = "Bad input key"
%%  2 = "bad session key"
%%  4 = "bad quote parts"
%%  5 = "Clear Disabled"

tpm[HV:TYPE+] : THEORY

  BEGIN

%   ASSUMING
%   % Assume that different blobs always have different hashes
%     unique_hash: ASSUMPTION
%       FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
%   ENDASSUMING

  K : TYPE = nat;

  IMPORTING ReturnCodes;
  IMPORTING startupData[K,HV];

  OAEPdecode(d:(tpmXOR?)) : tpmData = a(d)


  %% State monad output type
  tpmAbsOutput : DATATYPE
  BEGIN
    OUT_Nothing : OUT_Nothing?
    OUT_Error(m:ReturnCode) : OUT_Error?
    OUT_CPUError(m:cpuReturn) : OUT_CPUError?
    OUT_Data_Bind(outData:(tpmBoundData?),m:cpuReturn) : OUT_Data_Bind?
    OUT_Certify(k:(tpmKey?),dat:(tpmAsymCAContents?),m:cpuReturn) : OUT_Certify?
    	% added k here for proofs... helps when sequencing.
	% potentially look for better way to do this.
    OUT_FullQuote(quote:(tpmQuote?),idBind:(tpmIdContents?),m:cpuReturn) 
    	: OUT_FullQuote?
  %% Admin Startup and State (3)
    OUT_Init(m:ReturnCode) : OUT_Init?
    OUT_SaveState(m:ReturnCode) : OUT_SaveState?
    OUT_Startup(m:ReturnCode) : OUT_Startup?
  %% Admin Opt-in (5)
    OUT_SetOwnerInstall(m:ReturnCode) : OUT_SetOwnerInstall?
    OUT_OwnerSetDisable(o1:authOut,m:ReturnCode) : OUT_OwnerSetDisable?
    OUT_PhysicalEnable(m:ReturnCode) : OUT_PhysicalEnable?
    OUT_PhysicalDisable(m:ReturnCode) : OUT_PhysicalDisable?
    OUT_PhysicalSetDeactivated(m:ReturnCode) : OUT_PhysicalSetDeactivated?
    OUT_SetTempDeactivated(a:authOut,m:ReturnCode) : OUT_SetTempDeactivated?
    OUT_SetOperatorAuth(m:ReturnCode) : OUT_SetOperatorAuth?
  %% Admin Ownership (6)
    OUT_TakeOwnership(srk:(tpmKey?),a:authOut,m:ReturnCode) : OUT_TakeOwnership?
    OUT_OwnerClear(a:authOut,m:ReturnCode) : OUT_OwnerClear? 
    OUT_ForceClear(m:ReturnCode) : OUT_ForceClear? 
    OUT_DisableOwnerClear(a:authOut,m:ReturnCode) : OUT_DisableOwnerClear? 
    OUT_DisableForceClear(m:ReturnCode) : OUT_DisableForceClear? 
    OUT_PhysicalPresence(m:ReturnCode) : OUT_PhysicalPresence?
    OUT_ResetEstablishmentBit(m:ReturnCode) : OUT_ResetEstablishmentBit?
  %% Storage Functions (10)
    OUT_Seal(sealedData:(tpmStoredData?),a:authOut,m:ReturnCode) : OUT_Seal?
    OUT_Unseal(secret:tpmData,a,da:authOut,m:ReturnCode) : OUT_Unseal?
    OUT_UnBind(outData:tpmData,a:authOut,m:ReturnCode) : OUT_UnBind?
    OUT_CreateWrapKey(wrappedKey:(tpmKey?),a:authOut,m:ReturnCode) : 
    	OUT_CreateWrapKey?
    OUT_LoadKey2(inkeyHandle:(tpmKey?),a:authOut,m:ReturnCode) : OUT_LoadKey2?
    OUT_GetPubKey(pubKey:(tpmPubkey?),a:authOut,m:ReturnCode) : OUT_GetPubKey?
    OUT_Sealx(sealedData:(tpmStoredData?),a:authOut,m:ReturnCode) : OUT_Sealx?
  %% Migration (11)
    OUT_CreateMigrationBlob(random:int,outData:tpmData,a1,a2:authOut,
	m:ReturnCode) : OUT_CreateMigrationBlob?
    OUT_ConvertMigrationBlob(outData:(tpmStoreAsymkey?),a:authOut,
	m:ReturnCode) : OUT_ConvertMigrationBlob?
    OUT_AuthorizeMigrationKey(outData:(tpmMigKeyAuth?),a:authOut,m:ReturnCode):
    	OUT_AuthorizeMigrationKey?
    OUT_MigrateKey(outData:tpmData,a:authOut,m:ReturnCode) : OUT_MigrateKey?
    OUT_CMK_SetRestrictions(a:authOut,m:ReturnCode) : OUT_CMK_SetRestrictions?
    OUT_CMK_ApproveMA(outData:(tpmDigest?),a:authOut,m:ReturnCode) : 
        OUT_CMK_ApproveMA?
    OUT_CMK_CreateKey(wk:(tpmKey?),a:authOut,m:ReturnCode) : OUT_CMK_CreateKey?
    OUT_CMK_CreateTicket(sigTic:(tpmDigest?),a:authOut,m:ReturnCode) : 
        OUT_CMK_CreateTicket?
    OUT_CMK_CreateBlob(random:int,data:tpmData,a:authOut,m:ReturnCode) : 
        OUT_CMK_CreateBlob?
    OUT_CMK_ConvertMigration(data:tpmData,a:authOut,m:ReturnCode) : 
        OUT_CMK_ConvertMigration?
  %% Cryptographic Functions (13)
    OUT_Sign(sig:tpmData,m:ReturnCode) : OUT_Sign?
    OUT_CertifyKey(c:(tpmCertifyInfo?),o1,o2:authOut,m:ReturnCode) : 
    	OUT_CertifyKey?
  %% Endorsement Key Handling (14)
    OUT_CreateEndorsementKeyPair(pubEk:(tpmKey?),checksum:(tpmDigest?),
	m:ReturnCode) : OUT_CreateEndorsementKeyPair?
    OUT_CreateRevocableEK(pubEK:(tpmPubkey?),checksum:(tpmDigest?),
	outputEKreset:(tpmNonce?),m:ReturnCode) : OUT_CreateRevocableEK?
    OUT_RevokeTrust(m:ReturnCode) : OUT_RevokeTrust?
    OUT_ReadPubek(pubEk:(tpmKey?),checksum:(tpmDigest?),m:ReturnCode) : 
    	OUT_ReadPubek?
    OUT_OwnerReadInternalPub(k:(tpmPubkey?),a:authOut,m:ReturnCode) : 
    	OUT_OwnerReadInternalPub?
  %% Identity Creation and Activation (15)
    OUT_MakeIdentity(idKey:(tpmKey?),idBinding:(tpmIdContents?),a1,a2:authOut,
	m:ReturnCode) : OUT_MakeIdentity?
   OUT_ActivateIdentity(symmKey:(tpmSessKey?),a1,a2:authOut,m:ReturnCode) : 
   	OUT_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
    OUT_Extend(outDigest:PCR,m:ReturnCode) : OUT_Extend?
    OUT_PCRRead(outDigest:PCR,m:ReturnCode) : OUT_PCRRead?
    OUT_Quote(pcrData:list[PCR],sig:(tpmQuote?),a:authOut,m:ReturnCode) : 
    	OUT_Quote?
    OUT_PCR_Reset(m:ReturnCode) : OUT_PCR_Reset?
  %% Changing AuthData (17)
    OUT_ChangeAuth(data:tpmData,o1,o2:authOut,m:ReturnCode) : OUT_ChangeAuth?
    OUT_ChangeAuthOwner(o1:authOut,m:ReturnCode) : OUT_ChangeAuthOwner?
  %% Authorizaton Sessions (18)
    OUT_OIAP(auth:(tpmAuthData?),even:(tpmNonce?),m:ReturnCode) : OUT_OIAP?
    OUT_OSAP(auth:(tpmAuthData?),e,eOSAP:(tpmNonce?),m:ReturnCode) : OUT_OSAP?
  %% Eviction (22)
    OUT_FlushSpecific(m:ReturnCode) : OUT_FlushSpecific?
  %% DAA Commands (26)
    OUT_DAA_Join(outputData:tpmData,a:authOut,m:ReturnCode) : OUT_DAA_Join?
    OUT_DAA_Sign(outputData:tpmData,a:authOut,m:ReturnCode) : OUT_DAA_Sign?
  END tpmAbsOutput;

  IMPORTING memory[tpmAbsOutput,OUT_Nothing];
  

  %% State monad input type.  All inputs are in the form of a command with
  %% parameters.
  tpmAbsInput : DATATYPE
  BEGIN
  %% Admin Startup and State commands (3)
    ABS_Reset : ABS_Reset? %unimplemented
    ABS_Init : ABS_Init? 
    ABS_SaveState : ABS_SaveState?
    ABS_Startup(startupType : TPM_STARTUP_TYPE) : ABS_Startup?
  %% Admin Opt-in (5)
    ABS_SetOwnerInstall(state:bool) : ABS_SetOwnerInstall?
    ABS_OwnerSetDisable(disableState:bool,i:authIn) : ABS_OwnerSetDisable?
    ABS_PhysicalEnable : ABS_PhysicalEnable?
    ABS_PhysicalDisable : ABS_PhysicalDisable?
    ABS_PhysicalSetDeactivated(state:bool) : ABS_PhysicalSetDeactivated?
    ABS_SetTempDeactivated(i:authIn) : ABS_SetTempDeactivated?
    ABS_SetOperatorAuth(opAuth:(tpmSecret?)) : ABS_SetOperatorAuth?
  %% Admin Ownership Commands (6)
    ABS_TakeOwnership(oA,sA:(tpmEncAuth?),srk:(tpmKey?),a:authIn) : 
    	ABS_TakeOwnership? %TODO: oA,sA:(tpmAuthData?)
    ABS_OwnerClear(a:authIn) : ABS_OwnerClear? 
    ABS_ForceClear : ABS_ForceClear? 
    ABS_DisableOwnerClear(a:authIn) : ABS_DisableOwnerClear? 
    ABS_DisableForceClear : ABS_DisableForceClear? 
    ABS_PhysicalPresence(p:PHYSPRES) : ABS_PhysicalPresence?
    ABS_ResetEstablishmentBit : ABS_ResetEstablishmentBit?
  %% Protected Storage Commands (10)
    ABS_Seal(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : ABS_Seal?	%encAuth:(tpmAuthData?)
    ABS_Unseal(parent:(tpmKey?),inData:(tpmStoredData?),a,da:authIn) : 
    	ABS_Unseal?   
    ABS_UnBind(key:(tpmKey?),inData:(tpmBoundData?),a:authIn) : ABS_UnBind?
    ABS_CreateWrapKey(parentH,keyInfo:(tpmKey?),dUA,dMA:(tpmEncAuth?),a:authIn):
	ABS_CreateWrapKey?
    ABS_LoadKey2(parent,inKey:(tpmKey?),a:authIn): ABS_LoadKey2? 
    ABS_GetPubKey(key:(tpmKey?),a:authIn): ABS_GetPubKey? 
    ABS_Sealx(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : ABS_Sealx?
  %% Migration Commands (11)
    ABS_CreateMigrationBlob(p:(tpmKey?),m:migrateScheme,migKey:(tpmMigKeyAuth?),
	encData:(tpmKey?),a1,a2:authIn) : ABS_CreateMigrationBlob?
    ABS_ConvertMigrationBlob(parent:(tpmKey?),inData:(tpmMigrateAsymkey?),
	random:int,a:authIn) : ABS_ConvertMigrationBlob?
    ABS_AuthorizeMigrationKey(migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : ABS_AuthorizeMigrationKey?
    ABS_MigrateKey(ma,pub:(tpmKey?),inData:tpmData,a:authIn) : ABS_MigrateKey?
    ABS_CMK_SetRestrictions(restr:(tpmCMKDelegate?),i:authIn) : 
        ABS_CMK_SetRestrictions?
    ABS_CMK_ApproveMA(migAuth:(tpmDigest?),i:authIn) : ABS_CMK_ApproveMA?
    ABS_CMK_CreateKey(p:(tpmKey?),dataUsageAuth:(tpmEncAuth?),k:(tpmKey?),
        migAuthApp:(tpmDigest?),migAuthDig:(tpmDigest?),i:authIn) : 
        ABS_CMK_CreateKey?
    ABS_CMK_CreateTicket(verifKey:(tpmPubkey?),signedData:(tpmDigest?),
        sigVal:tpmData,i:authIn) : ABS_CMK_CreateTicket?
    ABS_CMK_CreateBlob(p:(tpmKey?),t:(tpmMigScheme?),mkAuth:(tpmMigKeyAuth?),
        psk:(tpmDigest?),msaList:(tpmMSAComposite?),restrTicket:(tpmCMKAuth?),
        sigTicket:(tpmDigest?),encData:(tpmStoreAsymkey?),i:authIn) : 
	ABS_CMK_CreateBlob?
    ABS_CMK_ConvertMigration(p:(tpmKey?),restrTick:(tpmCMKAuth?),
        sigTick:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),rand:int,
        i:authIn) : ABS_CMK_ConvertMigration?
  %% Cryptographic Commands (13)
    ABS_Sign(keyHandle:(tpmKey?),areaToSign:tpmData) : ABS_Sign?
    ABS_CertifyKey(c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) : ABS_CertifyKey?
  %% Endorsement Key Handling (14)
    ABS_CreateEndorsementKeyPair(antiReplay:(tpmNonce?),keyInfo:(tpmKey?)) : 
    	ABS_CreateEndorsementKeyPair?
    ABS_CreateRevocableEK(antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	genReset:bool,inputEKreset:(tpmNonce?)) : ABS_CreateRevocableEK?
    ABS_RevokeTrust(EKReset:(tpmNonce?)) : ABS_RevokeTrust?
    ABS_ReadPubek(n:(tpmNonce?)) : ABS_ReadPubek?
    ABS_OwnerReadInternalPub(k:(tpmKey?),a:authIn) : ABS_OwnerReadInternalPub?
  %% Identity Creation and Activation (15)
    ABS_MakeIdentity(idAuth:(tpmEncAuth?),CADigest:(tpmDigest?),idKey:(tpmKey?),
	a1,a2:authIn) : ABS_MakeIdentity?
    ABS_ActivateIdentity(aik:(tpmKey?),b:(activateIdentityBlob?),a1,a2:authIn):
    	ABS_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
%     ABS_Extend(pcrNum:PCRINDEX,inDigest:(tpmDigest?)) : ABS_Extend?
    ABS_Extend(pcrNum:PCRINDEX,d:HV) : ABS_Extend?
    ABS_PCRRead(ind:PCRINDEX) : ABS_PCRRead?
    ABS_Quote(aik:(tpmKey?),nonce:(tpmNonce?),pm:PCR_SELECTION,i:authIn) : 
    	ABS_Quote?
    ABS_PCR_Reset(pcrSelect:PCR_SELECTION) : ABS_PCR_Reset?
  %% Changing AuthData (17)
    ABS_ChangeAuth(p:(tpmKey?),newA:(tpmEncAuth?),d:tpmData,i1,i2:authIn) : 
    	ABS_ChangeAuth?
    ABS_ChangeAuthOwner(newA:(tpmEncAuth?),i:authIn) : ABS_ChangeAuthOwner?
  %% Authorizaton Sessions (18)
    ABS_OIAP : ABS_OIAP?
    ABS_OSAP(oOSAP:(tpmNonce?)) : ABS_OSAP?
  %% Eviction (22)
    ABS_FlushSpecific(h:tpmData) : ABS_FlushSpecific?
  %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    ABS_save(i:nat,v:tpmAbsOutput) : ABS_save?
    ABS_read(i:nat) : ABS_read?
    ABS_Data_Bind(k:(tpmKey?),d:tpmData) : ABS_Data_Bind?
  %% CA Commands
   ABS_certify(aik:(tpmKey?),certReq:(tpmIdContents?)) : ABS_certify?
  %% Invented, imaginary Commands
    noopCom : noopCom?
  END tpmAbsInput;

  %% sinit blob instance for measurement
  %sinit : B;
  sinitHash : HV;

  %% mle blob instance for measurement
  %mle : B;
  mleHash : HV;

  %% random number
  RAND : RNG;

  %% Initial key values not generated by TPM
  ekKeyVal : K = 1;
  srkKeyVal : K = 2;
  caKeyVal : K = 3;

  %% Initial key count value for initializing TPM
  initKeyVal : K = 100;

  %% Key definitions that make ek and srk values asymmetric keys.
  %% TODO: I mostly just made this stuff up... needs to be checked and changed
  ekVal:(tpmKey?) = tpmKey(ekKeyVal,storage,keyFlagsF,
			   always,keyParmsDef,
			   pcrInfoLongDefault,
			   storeAsymkeyDefault(ekKeyVal,ekKeyVal));
  srkVal:(tpmKey?) = tpmKey(srkKeyVal,storage,keyFlagsF,
			    always,keyParmsDef,
			    pcrInfoLongDefault,
			    storeAsymkeyDefault(srkKeyVal,ekKeyVal));
  caVal:(tpmKey?) = tpmKey(caKeyVal,storage,keyFlagsF,
			   always,keyParmsDef,
			   pcrInfoLongDefault,
			   storeAsymkeyDefault(caKeyVal,ekKeyVal)); 
			   % Certificate Authority key

  %% Abstract TPM State with keys, PCR array and locality
  tpmAbsState : TYPE = [#
  	      	       restore : restoreStateData,
                       memory : mem,
                       srk : (tpmKey?),
		       ek : (tpmKey?),
		       keyGenCnt : K,
		       keys : KEYSET,
                       pcrs : PCRVALUES,	%stcleardata`PCR?
		       locality : LOCALITY,
		       permFlags : PermFlags,
		       permData : PermData,
		       stanyFlags : StanyFlags,
		       stanyData : StanyData,
		       stclearFlags : StclearFlags,
		       stclearData : StclearData
		    #];

  %% Well formedness condition for abstract states.  Currently unused, but we
  %% should show that forall commands, well formed input generates well formed
  %% output.

  wellFormed?(s:tpmAbsState):bool = wellFormedRestore?(restore(s));

  IMPORTING StateMonad[tpmAbsOutput,tpmAbsState];

  %% Define some common TPM states and state operations
  
  %% Unknown state
  tpmUnknown : tpmAbsState

  %% Power on state after init is raised by hardware.
  tpmPostInit : (wellFormed?) = (#
                         pcrs:=pcrsPower
                         , locality:=4
			 , keys:=emptyset
			 , srk:=privateKey(srkVal)
			 , ek:=privateKey(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsDefault
			 , permData:=permDataInit
			 , stanyFlags:=stanyFlagsInit 
			   		WITH [`postInitialize:=TRUE]
			 , stanyData:=stanyDataInit
			 , stclearFlags:=stclearFlagsInit % TODO: check
			 , stclearData :=stclearDataInit  % TODO: check
			 #);

  %% Standard initial state following startup command with the TPM_ST_CLEAR
  %% option set.  Note that this should be checked against the spec before
  %% asserting goodness.
  tpmStartup : (wellFormed?) = (#
                         pcrs:=pcrsReset(allResetAccess)
			 , locality:=4
			 , keys:=emptyset
			 , srk:=privateKey(srkVal)
			 , ek:=privateKey(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsDefault
			 , permData:=permDataInit
			 , stanyFlags:=stanyFlagsInit 
			   		WITH [`postInitialize:=FALSE]
			 , stanyData:=stanyDataInit
			 , stclearFlags:=stclearFlagsInit % TODO: check
			 , stclearData :=stclearDataInit  % TODO: check
			 #);

  %% Generate a new state from restore data.  Basically this is a clear
  %% restart with pcrs, keys, and pcr flags coming from the restore
  %% data.  Note that this function assumes valid data and will behave
  %% badly otherwise
  tpmRestore(rd:(wellFormedRestore?)) : (wellFormed?) = (#
                         pcrs:=pcrs(rd)
			 , locality:=4
			 , keys:=keys(rd)
			 , srk:=privateKey(srkVal)
			 , ek:=privateKey(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=rd
			 , permFlags:=permFlags(rd)
			 , permData:=permData(rd)
			 , stanyFlags:=stanyFlags(rd)
			 , stanyData:=stanyData(rd)
			 , stclearFlags:=stclearFlagsInit % TODO: check
			 , stclearData :=stclearDataInit  % TODO: check
                         #)

  %% Predicate to determine if startup has occured.  Used as types
  %% (afterInit?) is the set of states occuring immediately after TPM_Init
  %% (afterStartup?) is the set of states occuring immediately after
  %% TPM_Startup
  afterInit?(s:tpmAbsState):bool = postInitialize(stanyFlags(s));
  afterStartup?(s:tpmAbsState):bool = NOT postInitialize(stanyFlags(s));

  %% Standard operations on TPM state definition above.  All such
  %% functions end with State to indicate they operate on the state
  %% value rather than on the TPM monad.  Note that key set and pcr
  %% manipulation functions are defined externally in key.pvs and
  %% pcr.pvs respectively

  %% Reset PCRs as performed by SENTER.
  pcrsResetSenterState(s:tpmAbsState) : tpmAbsState =
    s WITH [`pcrs := pcrsSenter(pcrs(s),pcrAttrib(permData(s)))];

  %% Decrease locality value
  changeLocalityState(s:tpmAbsState) : tpmAbsState =
    s WITH [`locality := IF locality(s) > 0
                         THEN locality(s) - 1
			 ELSE 0
			 ENDIF];
    
  %% Generate a new key
  genKeyState(s:tpmAbsState) : tpmAbsState =
    s WITH [`keyGenCnt := keyGenCnt(s)+1];

  saveState(s:tpmAbsState) : tpmAbsState =
    s WITH [`restore:=saveState(keys(s)
                                , ek(s)
		      		, srk(s)
				, keyGenCnt(s)
		      		, pcrs(s)
		      		, permFlags(s)
		      		, permData(s)
				, stanyFlags(s)
				, stanyData(s)
				, stclearFlags(s)
				, stclearData(s)
		      		)];

  setOwnerInstallState(s:tpmAbsState,state:bool) : tpmAbsState = 
    IF not(invalidAuth?(s`permData`ownerAuth)) 				% 1
    THEN s
    ELSIF s`stclearFlags`physicalPresence				% 2
    THEN s WITH [`permFlags`ownership:=state]
    ELSE s
    ENDIF;

  setOwnerInstallOut(s:tpmAbsState,state:bool) : tpmAbsOutput =
    IF not(invalidAuth?(s`permData`ownerAuth)) 				% 1
    THEN OUT_SetOwnerInstall(TPM_SUCCESS)	
    ELSIF s`stclearFlags`physicalPresence				% 2
    THEN OUT_SetOwnerInstall(TPM_SUCCESS)
    ELSE OUT_Error(TPM_SUCCESS) %TODO: INCORRECT!
    ENDIF;

  ownerSetDisableState(s:tpmAbsState,disableState:bool,i:authIn) : tpmAbsState =
    % Authenticate command as coming form TPM Owner. If unsuccessful 
    % THEN OUT_Error(TPM_AUTHFAIL)					% 1
    s WITH [`permFlags`disable:=disableState]				% 2

  ownerSetDisableOut(s:tpmAbsState,disableState:bool,i:authIn) : tpmAbsOutput =
    % Authenticate command as coming form TPM Owner. If unsuccessful 
    % THEN OUT_Error(TPM_AUTHFAIL)					% 1
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
    OUT_OwnerSetDisable(o1,TPM_SUCCESS);
    
  physicalEnableState(s:tpmAbsState) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=FALSE]				% 2
    ENDIF;
    
  physicalEnableOut(s:tpmAbsState) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalEnable(TPM_SUCCESS)
    ENDIF;

  physicalDisableState(s:tpmAbsState) : tpmAbsState = 
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=TRUE]				% 2
    ENDIF;

  physicalDisableOut(s:tpmAbsState) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalDisable(TPM_SUCCESS)
    ENDIF;

  physicalSetDeactivatedState(s:tpmAbsState,state:bool) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=state]				% 2
    ENDIF;

  physicalSetDeactivatedOut(s:tpmAbsState,state:bool) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalSetDeactivated(TPM_SUCCESS)
    ENDIF;

  setTempDeactivatedState(s:tpmAbsState,i:authIn) : tpmAbsState =
    IF not s`permFlags`operator						% 1a
    THEN s
    ELSIF % Validate command and params using ownerAuth(i) else		% 1b
    	 % OUT_Error(TPM_AUTHFAIL)
    	 not s`stclearFlags`physicalPresence				% 2
    THEN s
    ELSE s WITH [`stclearFlags`deactivated:=TRUE]			% 3
    ENDIF;

  setTempDeactivatedOut(s:tpmAbsState,i:authIn) : tpmAbsOutput =
    IF not s`permFlags`operator						% 1a
    THEN OUT_Error(TPM_NOOPERATOR)
    ELSIF % Validate command and params using ownerAuth(i) else		% 1b
    	 % OUT_Error(TPM_AUTHFAIL)
    	 not s`stclearFlags`physicalPresence				% 2
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
 	OUT_SetTempDeactivated(o1,TPM_SUCCESS)
    ENDIF;

  setOperatorAuthState(s:tpmAbsState,opAuth:(tpmSecret?)) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permData`operatorAuth:=opAuth				% 2
    	   	,`permFlags`operator:=TRUE]				% 3
    ENDIF;

  setOperatorAuthOut(s:tpmAbsState,opAuth:(tpmSecret?)) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_SetOperatorAuth(TPM_SUCCESS)
    ENDIF;


  takeOwnership?(s:tpmAbsState,k:(tpmKey?)) : bool =
    COND
      i(s`permData`ownerAuth)/=INVALIDAUTH -> FALSE,			% 1
      not s`permFlags`ownership -> FALSE,				% 2
      not goodkey?(key(s`ek)) -> FALSE,					% 3
      %not OIAP?(authHandle) -> FALSE,					% 4
      %not protocolID = TPM_PID_OWNER -> FALSE,				% 5
      %  not length(A1)=20bytes -> FALSE,	     			% 6
      %not command, params using A1, ownerAuth -> FALSE,		% 7b
      not storage?(keyUsage(k)) -> FALSE,   				% 8a
      migratable(keyFlags(k)) -> FALSE,					% 8b
      not RSA?(algoId(algoParms(k))) -> FALSE,				% 8c
      %not SHA1_MGF1?(encScheme(algoParms(k))) -> FALSE,		% 8d    
      %not SS_NONE?(sigScheme(algoParms(k))) -> FALSE,			% 8e
      %length(parms(algoParms(k)))<2048 -> FALSE,			% 8f
      %expSize(parms(algoParms(k)))/=0 -> FALSE,			% 8g
      s`permFlags`FIPS AND never?(authDataUsage(k))-> FALSE,		% 8h
      ELSE -> TRUE
    ENDCOND;

  takeOwnershipState(s:tpmAbsState,encOwnerA,encSrkA:(tpmEncAuth?),
	k:(tpmKey?),a:authIn) : tpmAbsState =
    COND
      NOT takeOwnership?(s,k) -> s,					% 1-8
      ELSE -> LET A2=decrypt(private(s`ek),encSrkA),			% 10
      	      	  A1=decrypt(private(s`ek),encOwnerA) IN		% 6
	      LET asymkey=tpmStoreAsymkey(A2,	 			% 10c
			migrationAuth(encDat(k)),
			pubDataDigest(encDat(k)),
			privKey(encDat(k)),
			crs(encDat(k))) IN %TODO
	      LET K1=tpmKey(key(k),keyUsage(k),keyFlags(k),
		      authDataUsage(k),algoParms(k),			% 9
		      PCRInfo(k),asymkey) IN
	      	  s WITH [`srk:=K1					% 11
			 ,`permData(ownerAuth):=A1			% 12
			 % TODO: 
			 %,`permData(contextKey)?			% 13
			 %,`permData(delegateKey)?			% 14
			 %,`permData(tpmProof)=TPM_RNG?			% 15
		    	 ,`permFlags(readPubek):=FALSE]			% 17
    ENDCOND;

  takeOwnershipOut(s:tpmAbsState,encOwnerA,encSrkA:(tpmEncAuth?),
	k:(tpmKey?),a:authIn) : tpmAbsOutput =
    IF NOT takeOwnership?(s,k)
    THEN IF i(s`permData`ownerAuth)/=INVALIDAUTH % TODO: CHECK 
      	    THEN OUT_Error(TPM_OWNER_SET)				% 1
     	 ELSIF not s`permFlags`ownership 
      	    THEN OUT_Error(TPM_INSTALL_DISABLED)			% 2
     	 ELSIF not goodkey?(key(s`ek)) 
      	    THEN OUT_Error(TPM_NO_ENDORSEMENT)				% 3
     	 ELSIF not storage?(keyUsage(k)) 
	    THEN OUT_Error(TPM_INVALID_KEYUSAGE)			% 8a
     	 ELSIF migratable(keyFlags(k)) 
	    THEN OUT_Error(TPM_INVALID_KEYUSAGE)			% 8b
     	 ELSIF not RSA?(algoId(algoParms(k))) 
	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8c
     	 ELSIF s`permFlags`FIPS AND never?(authDataUsage(k))
	    THEN OUT_Error(TPM_NOTFIPS)					% 8h
	 % TODO: implemented?
%   	 ELSIF not OIAP?(a`authHandle) 
% 	    THEN OUT_Error(TPM_AUTHFAIL)				% 4
%   	 ELSIF not protocolID = TPM_PID_OWNER 
% 	    THEN OUT_Error(TPM_BAD_PARAMETER)				% 5
% 	 ELSIF LET A1:(tpmSecret?)=decrypt(encOwnerA,PRIVEK) IN		
%   	   not length(A1)=20bytes 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 6
%   	 ELSIF not command, params using A1, ownerAuth 
% 	    THEN OUT_Error(TPM_AUTHFAIL)				% 7b
%   	 ELSIF not SHA1_MGF1?(encScheme(algoParms(k))) 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8d    
%   	 ELSIF not SS_NONE?(sigScheme(algoParms(k))) 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8e
%   	 ELSIF length(parms(algoParms(k)))<2048 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8f
%   	 ELSIF expSize(parms(algoParms(k)))/=0
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8g
     	 ELSE OUT_Error(TPM_SUCCESS) % should never reach here
    	 ENDIF 
    ELSE %takeOwnership?(s,k)
        LET A1:(tpmSecret?)=decrypt(private(s`ek),encOwnerA),		% 6
	    A2:(tpmSecret?)=decrypt(private(s`ek),encSrkA) IN		% 10
	LET asymkey=tpmStoreAsymkey(A2,	 				% 10c
			migrationAuth(encDat(k)),
			pubDataDigest(encDat(k)),
			privKey(encDat(k)),
			crs(encDat(k))) IN %TODO: clear?
	 LET K1=tpmKey(key(k),keyUsage(k),keyFlags(k),
		      authDataUsage(k),algoParms(k),
		      PCRInfo(k),asymkey),				% 9
	     aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			    contAuthSess:=TRUE,resAuth:=A1#) IN		% 18
    	 OUT_TakeOwnership(K1,aOut,TPM_SUCCESS)				% 16
    ENDIF;


  clear(s:tpmAbsState) : tpmAbsState = %not fully implemented
    s WITH [`keys:=emptyset
	   ,`permData(ownerAuth):=tpmSecret(INVALIDAUTH)		% 5a
      	   ,`srk:=tpmKey(0,keyUsage(s`srk),keyFlags(s`srk),
			 authDataUsage(s`srk),algoParms(s`srk),
			 PCRInfo(s`srk),encDat(s`srk))			% 5b
	   %,`permData(delegateKey):=badkey				% 5c
	   %,`permData(delegateTable):=invalid				% 5d
	   %,`permData(contextKey):=badkey				% 5e
	   ,`permData(tpmProof):=tpmSecret(INVALIDPROOF)		% 5f
	   ,`permData(operatorAuth):=tpmSecret(INVALIDAUTH)		% 5g
	   %,`permData(noOwnerNVWrite):=0				% 6a
	   %,`permData(ordinalAuditStatus):=default			% 6b
	   %,`permData(restrictDelegate):=default			% 6c
	   ,`stanyData:=stanyDataInit					% 7
	   %TODO : nonces shall be reset, lists invalidated
	   ,`stclearData:=stclearDataInit WITH [`PCR:=PCR(stclearData(s))]% 8
	   %TODO: nonces shall be reset, lists invalidated, deferredPhysPresence=0
	   ,`permFlags(disable):=disableDef				% 9a
	   ,`permFlags(deactivated):=deactivatedDef			% 9b
	   ,`permFlags(readPubek):=readPubekDef				% 9c
	   ,`permFlags(disableOwnerClear):=disableOwnerClearDef		% 9d
	   ,`permFlags(disableFullDALogicInfo):=disableFullDALogicInfoDef% 9e
	   ,`permFlags(allowMaintenance):=allowMaintenanceDef		% 9f
	   ,`permFlags(readSRKPub):=readSRKPubDef			% 9g
      	   ,`permFlags(ownership):=TRUE					% 10a
	   ,`permFlags(operator):=FALSE					% 10b
	   ,`permFlags(maintenanceDone):=FALSE				% 10c
	   %,`permData(monotonicCounter):= release all values		% 11
	   % TODO: 12-14
      	   ]

  ownerClearState(s:tpmAbsState,a:authIn) : tpmAbsState =
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> s,
      s`permFlags`disableOwnerClear -> s,				% 2
      ELSE -> clear(s)		      	 				% 3-14
    ENDCOND;

  ownerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> TPM_Error(TPM_AUTHFAIL),
      disableOwnerClear(permFlags(s)) -> OUT_Error(TPM_CLEAR_DISABLED),	% 2 
      ELSE -> LET a:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			     contAuthSess:=FALSE,resAuth:=ownerAuth(a)#) IN
      	      OUT_OwnerClear(a,TPM_SUCCESS)				% 3-14
    ENDCOND;

  forceClearState(s:tpmAbsState) : tpmAbsState = 
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN s								% 2
    	 ELSE clear(s)							% 3
    	 ENDIF
    ELSE s								% 1
    ENDIF
  
  forceClearOut(s:tpmAbsState) : tpmAbsOutput =
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN OUT_Error(TPM_CLEAR_DISABLED)   	 	  	      	% 2
    	 ELSE OUT_ForceClear(TPM_SUCCESS)				% 3
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PRESENCE)					% 1
    ENDIF

  disableOwnerClearState(s:tpmAbsState,a:authIn) : tpmAbsState = 
  % 1. TPM verifies authHandle properly authorizes owner
    s WITH [`permFlags(disableOwnerClear):=TRUE];			% 2

  disableOwnerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=TRUE,resAuth:=ownerAuth(a)#) IN
    OUT_DisableOwnerClear(a1,TPM_SUCCESS)				
    % TODO: 3. When this flag is TRUE... Prove this?

  disableForceClearState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`stclearFlags(disableForceClear):=TRUE];			% 1

  disableForceClearOut(s:tpmAbsState) : tpmAbsOutput = 
    OUT_DisableForceClear(TPM_SUCCESS)

  physicalPresenceState(s:tpmAbsState,p:PHYSPRES) : tpmAbsState =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN s								% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN s								% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN s								% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN s								% 2d
	 ELSE s WITH [`permFlags`physicalPresenceHWEnable:=
			IF member(HW_ENABLE,p) THEN TRUE		% 2e
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2f
			ELSE s`permFlags`physicalPresenceHWEnable ENDIF,
		      `permFlags`physicalPresenceCMDEnable:=
			IF member(CMD_ENABLE,p) THEN TRUE		% 2g
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2h
			ELSE s`permFlags`physicalPresenceCMDEnable ENDIF,
		      `permFlags`physicalPresenceLifetimeLock:=
			IF member(LIFETIME_LOCK,p) THEN TRUE		% 2i
			ELSE s`permFlags`physicalPresenceLifetimeLock ENDIF]
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN s								% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN s								% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN s								% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN s								% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN s								% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE		% 3fi
	      	     ,`stclearFlags`physicalPresenceLock:=TRUE]		% 3fii
    	 ELSIF member(PRESENT,p)					% 3g
	 THEN s WITH [`stclearFlags`physicalPresence:=TRUE]		% 3gi
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE]		% 3hi
	 ELSE s % should never get to this case.
    	 ENDIF
    ELSE s								% 4
    ENDIF

  physicalPresenceOut(s:tpmAbsState,p:PHYSPRES) : tpmAbsOutput =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2d
	 ELSE OUT_PhysicalPresence(TPM_SUCCESS)				% 2j
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)	% 3
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3fiii
    	 ELSIF member(PRESENT,p) 					% 3g
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSE OUT_Error(TPM_BAD_PARAMETER) % should never get here
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PARAMETER)					% 4
    ENDIF
  
  resetEstablishment?(s:tpmAbsState) : bool = 
    s`locality=3 or s`locality=4;

  resetEstablishmentBitState(s:tpmAbsState) : tpmAbsState = 
    IF resetEstablishment?(s)						% 1
    THEN s WITH [`permFlags(tpmEstablished):=FALSE]			% 2
    ELSE s
    ENDIF

  resetEstablishmentBitOut(s:tpmAbsState) : tpmAbsOutput = 
    IF resetEstablishment?(s)						% 1
    THEN OUT_ResetEstablishmentBit(TPM_SUCCESS)				% 3
    ELSE OUT_Error(TPM_BAD_LOCALITY)					%TODO
    ENDIF
  
  
  seal?(k:(tpmKey?)) : bool =
    storage?(keyUsage(k)) AND not(migratable(keyFlags(k))) %AND DECRYPTED TODO
    
  % Output secret sealed with asymmetric key 
  % crs(S1) encrypts S2
  sealOut(s:tpmAbsState,kH:(tpmKey?),enc:(tpmEncAuth?),p:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : tpmAbsOutput = 
    % Validate the authorization to use the key pointed to by kH	% 1
    % IF inDataSize = 0 THEN OUT_Error(TPM_BAD_PARAMETER)     		% 2
    IF not seal?(kH)
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 3,4
    % TODO: Determine version of pcrInfo				% 5
    ELSE LET h2=tpmCompositeHash((#select:=creationPCRSelect(p),	% 11bvi 
				   pcrValue:=s`pcrs#)) IN
    	 LET s1=tpmStoredData(tpmPCRInfoLong(				% 11
				s`stanyFlags`localityModifier,		% 11viii
				locAtRelease(p),			% 11bv
				creationPCRSelect(p),			% 11bii
				releasePCRSelect(p),			% 11biii
				h2,					% 11bvii
				digAtRelease(p)),			% 11biv
			      tpmNull,					% 9
			      clear) IN					% 7
	     % decrypting encAuth according to the ADIP indicated by authHandle
	 LET a1=decryptADIP(enc,authHandle(a)), % TODO: incorrect	% 12
	     h3:(tpmDigest?)=SHA1(s1) IN	  			% 14c
    	 LET S3=tpmSealedData(a1,			 		% 14e
			      s`permData`tpmProof,			% 14b
			      h3,					% 14d
    	     		      inData,					% 14g
			      encrypted(key(kH))) IN 		% 16
	% Validate the size(S2) can be encrypted by kH,TPM_BAD_DATASIZE % 15
	LET S1=tpmStoredData(sealInfo(s1),S3,clear),  	  		% 11,19
	    A:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,				% 17
			resAuth:=usageAuth(encDat(kH))#)
    	     IN OUT_Seal(S1,A,TPM_SUCCESS)				% 20
    ENDIF

  unseal?(p:(tpmKey?)) : bool =	% 2,3
    storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) %AND DECRYPTED

  % Output secret unsealed with an asymmetric key and PCRs 
  unsealOut(s:tpmAbsState,parent:(tpmKey?),inData:(tpmStoredData?),
	pa,da:authIn) : tpmAbsOutput = 
    % Validate that pa authorizes the use of the key in p TPM_AUTHFAIL	% 1
    LET d=decrypt(key(parent),inData) IN				% 5
    LET d1:(tpmSealedData?)=encData(d),		      			% 5,6a
	S2=tpmStoredData(sealInfo(inData),tpmNull,clear),		% 4
	h2=tpmCompositeHash((#select:=releasePCRSelect(sealInfo(inData)),
			      pcrValue:=s`pcrs#)) IN			% 7bii
    IF not unseal?(parent)						% 2,3
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not crs(d)=clear						% 5
       THEN OUT_CPUError(CPU_DECRYPT_ERROR)
    ELSIF not(tpmProof(d1)=tpmProof(s`permData) AND			% 6b
       SHA1(S2)=storedDigest(d1))					% 6e,f
       % TODO: 6g,
       THEN OUT_Error(TPM_NOTSEALED_BLOB)				% 6h
    ELSIF not locAtRelease(sealInfo(S2))=localityModifier(s`stanyFlags) % 7biii
       THEN OUT_Error(TPM_BAD_LOCALITY)
    ELSIF not h2=digAtRelease(sealInfo(S2))				% 7c
       THEN OUT_Error(TPM_WRONGPCRVAL)
    % validate authorization to use d1 by checking the HMAC calculation using 
    % authData(d1) as the shared secret matches the ownerAuth(da) TPM_AUTHFAIL 
    % on mismatch     	  	 		    		  	% 8
    % TODO: authdata stuff						% 9
    ELSE let a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
    	     resAuth:=usageAuth(encDat(parent))#) IN	% TODO: made up
    	 OUT_Unseal(data(d1),a,a,TPM_SUCCESS) 			% 10,11,12
    ENDIF;
  
  unBind?(k:(tpmKey?)) : bool =
    legacy?(keyUsage(k)) OR bind?(keyUsage(k))				% 3
  
  % Output decrypted key
  unBindOut(s:tpmAbsState,k:(tpmKey?),d:(tpmBoundData?),a:authIn):tpmAbsOutput=
    % if inDataSize=0 OUT_Error(TPM_BAD_PARAMETER)			% 1
    % validate the AuthData to use the key pointed to by k		% 2
    LET d1:(tpmBoundData?)=decrypt(private(k),d) IN    	 		% 4
    IF not unBind?(k)							% 3
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not clear?(crs(d1))						% 4
       THEN OUT_CPUError(CPU_DECRYPT_ERROR)
%     ELSIF SHA1_MGF1?(encScheme(algoParms(k))) AND legacy?(keyUsage(k))% 5
%        THEN outData=payloadData(d1) d1 NOT :(tpmBoundData?)		% 5b
    ELSE LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#)
	 IN OUT_UnBind(payloadData(d1),a,TPM_SUCCESS)			% 6,7
    ENDIF  	    

  checkFIPS?(s:tpmAbsState,k:(tpmKey?)) : bool =
    IF s`permFlags`FIPS AND
       	   (%keySize(k) < 1024 OR
    	    never?(authDataUsage(k)) OR
	    legacy?(keyUsage(k)))	
    THEN FALSE
    ELSE TRUE
    ENDIF

  checkKey?(k:(tpmKey?)) : bool = 
    not((storage?(keyUsage(k)) or migrate?(keyUsage(k)))		% 8
    	 AND not RSA?(algoId(algoParms(k)))				% 8i
       )
%     IF (storage?(keyUsage(k)) or migrate?(keyUsage(k)))			% 8
%     	AND not RSA?(algoId(algoParms(k)))				% 8i
%   	  AND not SHA1_MGF1?(encScheme(algoParms(srkParms))) 		% 8ii
%   	  AND not SS_NONE?(sigScheme(algoParms(srkParms))) 		% 8iii
%   	  AND length(parms(algoParms(srkParms)))/=2048 			% 8iv
%   	  AND expSize(parms(algoParms(srkParms)))/=0			% 8v
%     THEN FALSE
%     ELSE TRUE
%     ENDIF

  createWrapKey?(p,k:(tpmKey?)):bool = 
    storage?(keyUsage(p)) AND						% 4
    IF migratable(keyFlags(p)) AND not(migratable(keyFlags(k)))		% 5
    THEN FALSE 
    ELSE IF identity?(keyUsage(k)) OR authChange?(keyUsage(k))		% 6a
    	 THEN FALSE
	 ELSE not(migrateAuthority(keyFlags(k)))			% 6b
	 ENDIF
    ENDIF;

  createWrapKeyState(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsState =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN s
    ELSIF not checkFIPS?(s,k)					% 7
       THEN s
    ELSIF not checkKey?(k)						% 8
       THEN s
    % Determine version of key						% 9
    ELSE genKeyState(s)
    ENDIF;

  % Generate a NEW RANDOM key pair.
  createWrapKeyOut(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsOutput =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not checkFIPS?(s,k)						% 7
       THEN OUT_Error(TPM_NOTFIPS)
    ELSIF not checkKey?(k)						% 8
       THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    % determine version of key						% 9
    ELSE 
    	 LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),		% 10
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)),		% 11
	     b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 12
			resAuth:=usageAuth(encDat(p))#) IN
	LET h=tpmCompositeHash((#select:=creationPCRSelect(PCRInfo(k)),
			      pcrValue:=s`pcrs#)) IN			% 15d
	LET encData=tpmStoreAsymkey(DU1,				% 14a
			IF migratable(keyFlags(k)) THEN DM1		% 14b
			ELSE s`permData`tpmProof ENDIF, 		% 14c
			%TODO: next line is incorrect?
			pubDataDigest(encDat(k)),
			inverse(s`keyGenCnt),
			encrypted(key(p))),
	    pcrs=tpmPCRInfoLong(s`locality,				% 15e	
				locAtRelease(PCRInfo(k)),		% 15c
				creationPCRSelect(PCRInfo(k)),		% 15c
				releasePCRSelect(PCRInfo(k)),		% 15c
				h,					% 15d
				digAtRelease(PCRInfo(k))) IN		% 15c
      	   OUT_CreateWrapKey(tpmKey(s`keyGenCnt,			% 13,14
				    keyUsage(k),
				    keyFlags(k),
				    authDataUsage(k),
				    algoParms(k),
				    pcrs,				% 15c
				    encData),
			     b,TPM_SUCCESS)
    ENDIF
    

  validateKeyConsistency(s:tpmAbsState,p,k:(tpmKey?)) : nat = 
    IF migratable(keyFlags(k))=0 AND
    	 migrationAuth(encDat(k))/=tpmProof(permData(s)) 
    THEN 4								% 7d
    ELSIF FIPS(permFlags(s)) AND (never?(authDataUsage(k)) OR 
		 legacy?(keyUsage(k))) 
    THEN 3								% 7f
	 % TODO 7g
	 % TODO 7h
	 % TODO 7i
    ELSE 0 
    ENDIF

  validateLoadKey2(s:tpmAbsState,p,k:(tpmKey?)) : nat = 
    %Validate cmd & params using ownerAuth(a) and usageAuth(encDat(p))	% 1 
    IF not storage?(keyUsage(p)) 	      	  			% 2  
    THEN 1 	      				
    %If not designed to operate on key type(k) TPM_BAD_KEY_PROPERTY 	% 3
    ELSIF not(clear?(crs(decrypt(key(p),encDat(k)))))  	      		% 5
    THEN 2
    %Reproduce pubDataDigest(encDat(k)) = pubDataDigest(encDat(k))	% 6
    %TODO:IF migratable(keyFlags(k)) THEN verify consistency		% 7a
    ELSE CASES keyUsage(k) OF
    	 identity: IF migratable(keyFlags(k))=FALSE			% 7b
	 	   THEN validateKeyConsistency(s,p,k)
	 	   ELSE 1  
		   ENDIF,
	 authChange: 1							% 7c
	 ELSE validateKeyConsistency(s,p,k)
	 ENDCASES
    ENDIF;

  loadKey2?(state:tpmAbsState,p,k:(tpmKey?)) : bool = 
    validateLoadKey2(state,p,k)=0

  %% Install key operation on TPM state.
  loadKey2State(s:tpmAbsState,p,k:(tpmKey?),a:authIn) : tpmAbsState =
    IF validateLoadKey2(s,p,k)=0 
    THEN s with [`keys:=loadKey(k,p,keys(s),pcrs(s))]
    ELSE s
    ENDIF;

  loadKey2Out(s:tpmAbsState,parentH,inKey:(tpmKey?),a:authIn) : tpmAbsOutput = 
    LET num=validateLoadKey2(s,parentH,inKey) IN	      		% 1-7
      COND 
      num=0 -> LET aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN % TODO: resAuth!
	       OUT_LoadKey2(inKey,aOut,TPM_SUCCESS),			% 9
	       % TODO: 8,10-12
      num=1 -> OUT_Error(TPM_INVALID_KEYUSAGE),
      num=2 -> OUT_CPUError(CPU_DECRYPT_ERROR),	%%TODO: Might not be right.
      num=3 -> OUT_Error(TPM_NOTFIPS),
      ELSE -> OUT_Error(TPM_FAIL) %TODO: incorrect?
      ENDCOND;


  getPubKey?(s:tpmAbsState,key:(tpmKey?)) : bool = 
    %Validate cmd params using usageAuth(encDat(key)) TPM_AUTHFAIL	% 1a
    never?(authDataUsage(key)) AND s`permFlags`readSRKPub
    AND %pcrInfoSize(key)/=0						% 4
    (pcrIgnoredOnRead(keyFlags(key))					% 4a
    OR dig(digAtRelease(PCRInfo(key)))= 				% 4ai
    	dig(digAtRelease(PCRInfo(key))) WITH [`pcrValue:=s`pcrs])
  
  getPubKeyOut(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsOutput =
    %Validate cmd params using usageAuth(encDat(key)) TPM_AUTHFAIL	% 1a
    IF not never?(authDataUsage(k)) 
    THEN OUT_Error(TPM_AUTHFAIL)					% 2a
    ELSIF not(s`permFlags`readSRKPub)
    THEN OUT_Error(TPM_INVALID_KEYHANDLE)				% 3a	
    ELSIF %pcrInfoSize(key)/=0						% 4
    	  not(pcrIgnoredOnRead(keyFlags(k)))				% 4a
    	  AND dig(digAtRelease(PCRInfo(k)))/=
    	      dig(digAtRelease(PCRInfo(k))) WITH [pcrValue:=s`pcrs] 	% 4ai
    THEN OUT_Error(TPM_WRONGPCRVAL)
    %TODO: If specified, validate any locality requests			% 4aii
    ELSE LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#),
	     pubKey=tpmPubkey(algoParms(k),key(k)) IN
    	 OUT_GetPubKey(pubKey,aOut,TPM_SUCCESS)				% 5
    ENDIF;
    
   
%    sealxOut(k:(tpmKey?),encAuth:(tpmEncAuth?),p:(tpmPCRInfoLong?),
% 	inData:tpmData,a:authIn) : tpmAbsOutput = 
%    %Validate the authorization to use k					% 1
%    %IF inDataSize=0 THEN OUT_Error(TPM_BAD_PARAMETER)			% 2
%    IF not seal?(k)
%    THEN OUT_Error(TPM_INVALID_KEYUSAGE)					% 3,4
%    ELSE LET h2=tpmCompositeHash((#select:=creationPCRSelect(p),		% 9f
% 				  pcrValue:=s`pcrs#)) IN
%    	LET S1=tpmStoredData(tpmPCRInfoLong(
% 				s`stanyFlags`localityModifier,		% 9h
% 				locAtRelease(p),			% 9e
% 				creationPCRSelect(p),			% 9b
% 				releasePCRSelect(p),			% 9c
% 				h2,					% 9g
% 				digAtRelease(p)),			% 9d
% 			     tpmNull,					% 6,7
% 			     clear)
% 	LET a1=decryptADIP(encAuth,authHandle(a)),			% 11
% 	    % TODO: 11 a,b, 13
% 	    % TODO: o1=decrypt(,inData)					% 14
% 	    h3=SHA1(S1) IN						% 15c
% 	LET S2=tpmSealedData(a1,					% 10,15e
% 	    		     s`permData`tpmProof,			% 15b
% 			     h3,					% 15d
% 			     o1,					% 15g
% 			     ) IN
% 	LET S3=tpmSealedData(
			     

  checkMigKeyAuth?(s:tpmAbsState,a:(tpmMigKeyAuth?)):bool =		% 5
    digest(a)=SHA1(concat(key(a),concat(scheme(a),s`permData`tpmProof)))
  
  createMigBlob?(s:tpmAbsState,p:(tpmKey?),m:migrateScheme,a:(tpmMigKeyAuth?),
	e:tpmData) : bool = 
    storage?(keyUsage(p)) AND						% 2
    % TODO: detect decrypt error...					% 3
    checkMigKeyAuth?(s,a) AND						% 5
    CASES m OF
    	  migrate : TRUE,
	  rewrap  : TRUE
	  ELSE FALSE							% 8
    ENDCASES	

  createMigBlobOut(s:tpmAbsState,p:(tpmKey?),migType:migrateScheme,
	mKeyAuth:(tpmMigKeyAuth?),encData:(tpmKey?),a1,a2:authIn):tpmAbsOutput =
    %Validate ownerAuth(a1) authorizes use of p				% 1
    LET d1:(tpmKey?)=decrypt(key(p),encData),				% 3
    	ao1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(p))#),
    	ao2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(key(mKeyAuth)))#) IN
    IF not storage?(keyUsage(p))       	      				% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    %Validate ownerAuth(a2) authorizes migration of d1, 		% 4
    % 	   	 must use migrationAuth(d1) as secret.
    ELSIF not checkMigKeyAuth?(s,mKeyAuth)				% 5
    THEN OUT_Error(TPM_AUTHFAIL)
    ELSE CASES migType OF
	       migrate: LET K1=privKey(encDat(d1)),			% 6ai
	       		    K2=privKey(encDat(d1)) IN			% 6aii
				% only supposed to be part of private key... 
	       		LET M1=tpmMigrateAsymkey(usageAuth(encDat(d1)),	% 6bii
					pubDataDigest(encDat(d1)),	% 6biii
					K2) IN				% 6bv
			LET o1=OAEP(M1,migrationAuth(encDat(d1)),K1),	% 6c
			    r1=RAND IN					% 6d
			LET x1=tpmXOR(o1,r1,				% 6e
				encrypted(key(key(mKeyAuth)))) IN % 6g
			OUT_CreateMigrationBlob(r1,			% 6f
				x1,
				ao1,ao2,
				TPM_SUCCESS),
	       rewrap : OUT_CreateMigrationBlob(0,			% 7b
				rewrap(encData,key(key(mKeyAuth))),	% 7a
				ao1,ao2,
				TPM_SUCCESS)
	       ELSE OUT_Error(TPM_BAD_PARAMETER)			% 8
	 ENDCASES
    ENDIF
	 

  convertMigBlobOut(s:tpmAbsState,parent:(tpmKey?),inData:(tpmMigrateAsymkey?),
	rand:int,a:authIn) : tpmAbsOutput =
    % Validate authData to use key in parent				% 1
    IF not storage?(keyUsage(parent))					% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSE LET d1=decrypt(key(parent),inData) IN				% 3
     	 LET o1=tpmXOR(d1,rand,clear) IN		    		% 4
	 LET m1=inData, %TODO: seed,pHash by OAEPdecode(o1),		% 5
	     pHash:(tpmSecret?) = tpmSecret(1) IN
	 LET k1:KVAL=partPrivKey(m1) IN %TODO:combine seed		% 6
% 	 IF payload(m1)=TPM_PT_MIGRATE 		    		  	% 7a
% 	 THEN 
	 LET d2=tpmStoreAsymkey(%TPM_PT_ASYM,				% 7b
				usageAuth(m1),				% 7c
				pHash,					% 7d
				pubDataDigest(m1),			% 7e
				k1,					% 7f
				encrypted(key(parent))), 		% 8
	     aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(parent))#) IN
	OUT_ConvertMigrationBlob(d2,aOut,TPM_SUCCESS)
    ENDIF
    
  authorizeMigKeyOut(s:tpmAbsState,migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : tpmAbsOutput = 
    % Check cryptographic strength of migrationKey >=2048RSA		% 1
    % Validate authdata to use the TPM by the TPM owner			% 2
%     IF TODO: not MGF1?(encScheme(algoParms(migKey)))	  		% 4
%     THEN OUT_Error(TPM_INAPPROPRIATE_ENC)
%     ELSE 
    	 OUT_AuthorizeMigrationKey(
		tpmMigKeyAuth(migKey,					% 3,5
			migScheme,					% 6
			SHA1(concat(migKey,
				concat(migScheme,s`permData`tpmProof))),% 7,8,9
			clear),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(a)#),
		TPM_SUCCESS)
%     ENDIF;

  %% Decrypts the input packet (coming from TPM_CreateMigrationBlob) and then 
  %% re-encrypts it with the input public key. The output would then be sent to 
  %% TPM_ConvertMigrationBlob on the target TPM.
  migrateKeyOut(s:tpmAbsState,m,p:(tpmKey?),d:tpmData,a:authIn) : tpmAbsOutput =
    % Validate ownerAuth(a) authorizes use of m			  	% 1
    IF not migrate?(keyUsage(m))       	      				% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
%     IF TODO: not MGF1?(encScheme(algoParms(m)))	  		% 2
%     THEN OUT_Error(TPM_INAPPROPRIATE_ENC)
    ELSE OUT_MigrateKey(encrypt(key(p),decrypt(key(m),d)),		% 4
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(m))#),
		TPM_SUCCESS)
    ENDIF

  CMKSetRestr?(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : bool =
    %permData(restrictDelegate) is used as follows:
    %sessionType = TPM_PID_DSAP AND			    		% 1
%        migrateAuthority(keyFlags(_)) %TODO: WHICH KEY?
%        AND (signing?(keyUsage(_)) AND r(delegateSigning)) OR	% 1a
%            (storage?(keyUsage(_)) AND r(delegateStorage)) OR
%            (bind?(keyUsage(_)) AND r(delegateBind)) OR
% 	   (legacy?(keyUsage(_)) AND r(delegateLegacy)) OR
% 	   (migrate?(keyUsage(_)) AND r(delegateMigrate))
	   TRUE;


  CMKSetRestrState(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : tpmAbsState =
    IF CMKSetRestr?(s,r,i)
    THEN %key can be used
    	 %Validate ordinal and parameters using TPM Owner authentication
	 %on error, OUT_Error(TPM_AUTHFAIL)
	 s WITH [`permData(restrictDelegate):=r]			% 2
    ELSE s
    ENDIF;

  CMKSetRestrOut(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : tpmAbsOutput =
    IF CMKSetRestr?(s,r,i)
    THEN %key can be used
    	 %TODO Validate ordinal and parameters using TPM Owner authentication
	 %on error, OUT_Error(TPM_AUTHFAIL)				% 1
	 LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i)#) IN
	 OUT_CMK_SetRestrictions(a,TPM_SUCCESS)				% 3
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF;

  CMKApproveMAOut(s:tpmAbsState,migAuth:(tpmDigest?),i:authIn) : tpmAbsOutput = 
    %TODO Validate AuthDat to use the TPM by TPM 0wner			% 1
    LET M2=tpmCMKMAApproval(migAuth),	     	 			% 2
	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(i)#) IN
    OUT_CMK_ApproveMA(tpmHMAC(M2,s`permData`tpmProof),a,TPM_SUCCESS);	% 3

  validateMigrateAuthority?(s:tpmAbsState,m,a:(tpmDigest?)) : bool =
    LET M1=tpmCMKMAApproval(m) IN					% 8ai
    a=tpmHMAC(M1,s`permData`tpmProof)					% 8b

  validateKeyParams?(k:(tpmKey?)) : bool =
    not(identity?(keyUsage(k)) or authChange?(keyUsage(k)))		% 9

  CMKCreateKey?(s:tpmAbsState,p:(tpmKey?),k:(tpmKey?),m,a:(tpmDigest?)) : bool =
    storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND		% 4,5
    migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k))		% 6,7
    AND validateMigrateAuthority?(s,m,a) 				% 8  
    AND validateKeyParams?(k)						% 9
    AND checkFIPS?(s,k)							% 10
    AND checkKey?(k)							% 11

  CMKCreateKeyOut(s:tpmAbsState,p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
    a:(tpmDigest?),m:(tpmDigest?),i:authIn) : tpmAbsOutput = 
    %TODO: Validate AuthData to use key pointed to by p. OUT_Error(TPM_AUTHFAIL)
    % Validate session type for p is OSAP				% 2
    % IF TPM not designed to create key of type requested in k, OUT_ERROR(TPM_BAD_KEY_PROPERTY) % 3
    IF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND	% 4,5
    migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k)))		% 6,7
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not(validateMigrateAuthority?(s,m,a))				% 8
    THEN OUT_Error(TPM_MA_AUTHORITY)
    ELSIF not(validateKeyParams?(k))					% 9
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				
    ELSIF not(checkFIPS?(s,k))						% 10
    THEN OUT_Error(TPM_NOTFIPS)
    ELSIF not(checkKey?(k))						% 11
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    %TODO 12
    ELSE LET DU1=decryptADIP(d,authHandle(i)),				% 14
    	     ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 15
			resAuth:=usageAuth(encDat(p))#),
	     pcr=tpmPCRInfoLong(s`stanyFlags`localityModifier,		% 18d
				locAtRelease(PCRInfo(k)), 
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				tpmCompositeHash((#
					select:=creationPCRSelect(PCRInfo(k)),
					pcrValue:=s`pcrs#)),		% 18c
				digAtRelease(PCRInfo(k))),
	     M2=tpmCMKMigAuth(m,					% 17di
             		      SHA1(tpmPubkey(algoParms(k),key(k)))) IN	% 17dii
	 LET enc=tpmStoreAsymkey(DU1,					% 17a
%	     			 tpmHMAC(M2,s`permData`tpmProof),	% 17e
 				 tpmSecret(1),
% 				 %TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				 pubDataDigest(encDat(k)),
				 privKey(encDat(k)),
				 encrypted(key(p))) IN		% 19
    	 LET wrappedKey=tpmKey(key(k),					% 13,17
	     		       keyUsage(k),
			       keyFlags(k),
			       authDataUsage(k),
			       algoParms(k),
			       pcr,					% 18
			       enc) IN
	 OUT_CMK_CreateKey(wrappedKey,ao,TPM_SUCCESS)
    ENDIF;

  validateKeyAlgo?(k:(tpmPubkey?)) : bool = 
    RSA?(algoId(algoParms(k)))
       %AND NONE?(encScheme(algoParms(verifKey)))
       %AND (SHA1?(sigScheme(algoParms(verifKey))) OR 
       % INFO?(sigScheme(algoParms(verifKey))))
  
  CMKCreateTicket?(k:(tpmPubkey?),signedData:(tpmDigest?)) : bool = 
    validateKeyAlgo?(k) AND
    checkSig(pubKey(k),signedData)
    
  CMKCreateTicketOut(s:tpmAbsState,verifKey:(tpmPubkey?),signedData:(tpmDigest?)
    ,sigVal:tpmData,i:authIn) : tpmAbsOutput = 
    %TODO Validate Owner authentication					% 1
    IF not(validateKeyAlgo?(verifKey))					% 2
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)	%TODO: CHECK
    ELSIF not(checkSig(pubKey(verifKey),signedData))			% 3
    THEN OUT_Error(TPM_BAD_SIGNATURE)
    ELSE LET M2=tpmCMKSigTicket(SHA1(verifKey),signedData),		% 4
    	     a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,%TODO: FLAG?
			resAuth:=ownerAuth(i)#) IN%TODO: CHANGED... DOUBLE CHECK
    	 OUT_CMK_CreateTicket(tpmHMAC(M2,s`permData`tpmProof),a,TPM_SUCCESS)%5,6
    ENDIF;

  CMKCreateBlob?(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      encData:(tpmStoreAsymkey?),i:authIn) : bool =
    t=scheme(mkAuth) AND						% 2
    not(migratable(keyFlags(p))) AND					% 3
    migrationAuth(decrypt(key(p),encData))=				% 7b
	tpmHMAC(tpmCMKMigAuth(SHA1(msaList),psk),s`permData`tpmProof) AND
    (restrictMigrate?(migScheme(scheme(mkAuth))) AND		        % 8 
    			RSA?(algoId(algoParms(key(mkAuth))))
     OR restrictApprove?(migScheme(scheme(mkAuth))))			% 9
   
    %encData:(tpmStoreAsymkey?)
  CMKCreateBlobOut2(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      resTic:(tpmCMKAuth?),sigTic:(tpmDigest?),encData:(tpmStoreAsymkey?),
      i:authIn) : tpmAbsOutput =
    LET d1:(tpmStoreAsymkey?)=decrypt(key(p),encData) IN		% 4
    LET K1=privKey(d1),	   						% 11a
    	K2=privKey(d1) IN % TODO					% 11b
    LET M1=tpmMigrateAsymkey(usageAuth(d1),pubDataDigest(d1),K2) IN	% 12
    LET o1=OAEP(M1,SHA1(concat(SHA1(msaList),psk)),K1),			% 13
    	r1=RAND,							% 14
    	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,%TODO: FLAG?
			resAuth:=usageAuth(encDat(p))#) IN    
    OUT_CMK_CreateBlob(r1,tpmXOR(o1,r1,encrypted(key(key(mkAuth))))% 15-17
		,a,TPM_SUCCESS);

  CMKCreateBlobOut(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      resTic:(tpmCMKAuth?),sigTic:(tpmDigest?),encData:(tpmStoreAsymkey?),
      i:authIn) : tpmAbsOutput =
    %TODO: Validate ownerAuth(i) authorizes use of key pointed to by p	% 1
    %TPM MAY DO FOLLOWING: ???
    LET d1=decrypt(key(p),encData),					% 4
    	M2=tpmCMKMigAuth(SHA1(msaList),psk) IN				% 7a
    IF t/=scheme(mkAuth)						% 2
    THEN OUT_Error(TPM_BAD_MODE)
    ELSIF migratable(keyFlags(p))					% 3
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    ELSIF % TODO % 5
    	  % TODO % 6 Payload...
	  migrationAuth(d1)/=tpmHMAC(M2,s`permData`tpmProof)		% 7b
    THEN OUT_Error(TPM_MA_AUTHORITY)
    ELSE CASES migScheme(scheme(mkAuth)) OF
    	   restrictMigrate : 						% 8
	     %TODO: 8ai
	     IF RSA?(algoId(algoParms(key(mkAuth))))			% 8bi
	     	%AND valid?(encScheme(algoParms(key(mkAuth))))		% 8bii
       		%AND (SSNONE?(sigScheme(algoParms(verifKey))) 		% 8biii
	     THEN CMKCreateBlobOut2(s,p,t,mkAuth,psk,msaList,resTic,
			sigTic,encData,i)
	     ELSE OUT_Error(TPM_BAD_KEY_PROPERTY)
	     ENDIF
	 , restrictApprove : 						% 9
	     % TODO: 9ai	   
	     CMKCreateBlobOut2(s,p,t,mkAuth,psk,msaList,resTic,sigTic,encData,i)
	 ELSE OUT_Error(TPM_BAD_PARAMETER)				% 10
	 ENDCASES
    ENDIF

  CMKConvertMigration?(s:tpmAbsState,p:(tpmKey?),r:(tpmCMKAuth?),m:(tpmKey?),
	l:(tpmMSAComposite?),n:int) : bool =
    LET d1=decrypt(key(p),encDat(m)) IN  				% 3
    LET o1=tpmXOR(d1,n,clear) IN    					% 4
    LET m1=OAEPdecode(o1), %TODO TCC GENERATED. FIGURE OUT OAEP DECODE	% 5
	migratedPubKey=tpmPubkey(algoParms(m),key(m)) IN		% 6
    LET k1=partPrivKey(m(m1)), %todo: should be seed & partprivkey	% 7
        M2=tpmCMKMigAuth(SHA1(l),SHA1(migratedPubKey)) IN		% 18
    LET d2=tpmStoreAsymkey(usageAuth(m(m1)),		     		% 8b
		%HMAC(M2,s`permData`tpmProof),				% 19
		tpmSecret(1),
		%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
		pubDataDigest(m(m1)),k1,				% 8c,a
		encrypted(key(p))),					% 20
        parentPubKey=tpmPubkey(algoParms(p),key(p)) IN		   	% 12
    storage?(keyUsage(p)) AND						% 2
    pHash(m1)=SHA1(concat(SHA1(l),SHA1(migratedPubKey))) AND		% 6
    not(migratable(keyFlags(p))) AND				        % 9
    destKey(r)=SHA1(parentPubKey) AND					% 13
    (privKey(encDat(m))=privKey(d2) AND
     pubDataDigest(encDat(m))=pubDataDigest(d2) AND
     usageAuth(encDat(m))=usageAuth(d2)) AND				% 14
    migratable(keyFlags(m)) AND						% 15
    migrateAuthority(keyFlags(m)) AND					% 16
    sourceKey(r)=SHA1(tpmPubkey(algoParms(m),key(m)))			% 17

  CMKConvertMigrationOut(s:tpmAbsState,p:(tpmKey?),resTic:(tpmCMKAuth?),
      sigTic:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),rand:int,
      i:authIn) : tpmAbsOutput =
    %TODO: Validate authdata to use key in p				% 1
    LET d1=decrypt(key(p),encDat(mk)) IN  				% 3
    LET o1=tpmXOR(d1,RAND,clear) IN    					% 4
    LET m1=OAEPdecode(o1), %TODO TCC GENERATED. FIGURE OUT OAEP DECODE	% 5
	migratedPubKey=tpmPubkey(algoParms(mk),key(mk)) IN		% 6
    LET k1=partPrivKey(m(m1)), %todo: should be seed & partprivkey	% 7
        M2=tpmCMKMigAuth(SHA1(msaList),SHA1(migratedPubKey)) IN		% 18
    LET d2=tpmStoreAsymkey(usageAuth(m(m1)),		     		% 8b
		%HMAC(M2,s`permData`tpmProof),				% 19
		tpmSecret(1),
		%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
		pubDataDigest(m(m1)),k1,				% 8c,a
		encrypted(key(p))) IN					% 20
    LET parentPubKey=tpmPubkey(algoParms(p),key(p)) IN		   	% 12
    IF not(storage?(keyUsage(p)))					% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF pHash(m1)/=SHA1(concat(SHA1(msaList),SHA1(migratedPubKey)))	% 6a
    THEN OUT_Error(TPM_SHA_ERROR) %TODO
    ELSIF migratable(keyFlags(p))					% 9
    THEN  OUT_Error(TPM_BAD_KEY_PROPERTY)
    % TODO 10 payload	
    % TODO 11
    ELSIF destKey(resTic)/=SHA1(parentPubKey)				% 13
    THEN OUT_Error(TPM_MA_DESTINATION)
    ELSIF not(privKey(encDat(mk))=privKey(d2) AND
    	      pubDataDigest(encDat(mk))=pubDataDigest(d2) AND
	      usageAuth(encDat(mk))=usageAuth(d2))			% 14
    THEN  OUT_Error(TPM_BAD_KEY_PROPERTY) %TODO
    ELSIF not(migratable(keyFlags(mk))) OR				% 15
    	  not(migrateAuthority(keyFlags(mk)))				% 16
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF sourceKey(resTic)/=SHA1(migratedPubKey)			% 17
    THEN OUT_Error(TPM_MA_SOURCE)
    ELSE LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(p))#) IN % TODO
    OUT_CMK_ConvertMigration(d2,a,TPM_SUCCESS)
    ENDIF;

  sign?(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : bool = 
    signing?(keyUsage(key)) OR legacy?(keyUsage(key))

  % Sign a blob if signing key isn't aik
  % TODO: add signature scheme (makes this more complicated)
  signOut(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : tpmAbsOutput=
    IF signing?(keyUsage(key)) OR legacy?(keyUsage(key)) 
    THEN OUT_Sign(sign(key(key),areaToSign),TPM_SUCCESS)
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF

  % TODO:
%   certifyKeyState(s:tpmAbsState,c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) :
%   	tpmAbsState
%   certifyKeyOut(s:tpmAbsState,c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) : 
%   	tpmAbsOutput

  createEKPairState(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?)) : tpmAbsState = 
    IF goodkey?(key(ek(s)))				       		% 1
    THEN s
    ELSE s WITH [`ek:=privateKey(k)					% 5
%     	   	,`permData(tpmDAASeed):=rand				% 6
% 		,`permData(daaProof):=rand				% 7
% 		,`permData(daaBlobKey):=rand				% 8
    	   	,`permFlags(CEKPUsed):=TRUE				% 9
		,`permFlags(enableRevokeEK):=FALSE]			% 10
    ENDIF;

  % If ek doesn't exist, create a new ek from keyInfo
  createEKPairOut(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?)) : tpmAbsOutput = 
    IF goodkey?(key(ek(s)))				     		% 1
    THEN OUT_Error(TPM_DISABLED_CMD)
    % Validate k parameters for key description?			% 2
%     ELSIF RSA?(algoId(algoParms(k))) AND length(k)<2048		% 2b
%     THEN OUT_Error(TPM
    ELSE LET checksum=SHA1(concat(k,r)) IN				% 4
    	 OUT_CreateEndorsementKeyPair(k,checksum,TPM_SUCCESS)		% 3
    ENDIF;

  createRevEKState(s:tpmAbsState,antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	generateReset:bool,inputEKreset:(tpmNonce?)) : tpmAbsState =
    IF goodkey?(key(ek(s)))
    THEN s
    ELSE LET s1=createEKPairState(s,antiReplay,keyInfo) IN
    	 s1 WITH [`permFlags(enableRevokeEK):=TRUE,			% 3
	     	  `permData(ekReset):=IF generateReset 
				      THEN tpmNonce(RAND)		% 3a
				      ELSE inputEKreset			% 3b
				      ENDIF]
    ENDIF;
    
  createRevEKOut(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?),genReset:bool,
	i:(tpmNonce?)) : tpmAbsOutput = 
    IF goodkey?(key(ek(s)))						% 1
    THEN OUT_Error(TPM_DISABLED_CMD) 
    ELSE LET o1=createEKPairOut(s,r,k) IN				% 2
    	 CASES o1 OF
	 OUT_CreateEndorsementKeyPair(e,c,m) :
	 	OUT_CreateRevocableEK(tpmPubkey(algoParms(e),key(e)),c,	% 4
			IF genReset THEN tpmNonce(RAND)			% 3a
			   ELSE i ENDIF,				% 3b
			TPM_SUCCESS)
	ELSE o1								% 2
	ENDCASES
    ENDIF;

  revokeTrust?(s:tpmAbsState,ekReset:(tpmNonce?)) : bool =
    s`permFlags`enableRevokeEK AND s`permData`ekReset=ekReset AND
    	s`stclearFlags`physicalPresence

  revokeTrustState(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsState = 
    IF s`permFlags`enableRevokeEK AND ekReset(permData(s))=ekReset AND	% 1,2
       s`stclearFlags`physicalPresence					% 3
    THEN LET s1 = clear(s) IN						% 4
	 %TODO NV items with pubInfo->nvIndex D value must be deleted	% 4a
	 s1 WITH [`permFlags(nvLocked):=FALSE,				% 4b
% 	      	  `permData(tpmDAASeed):=,				% 5
% 		  `permData(daaProof):=,				% 6
% 		  `permData(daaBlobKey):=,				% 7
		  `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),		% 8
			      authDataUsage(s`ek),algoParms(s`ek),
			      PCRInfo(s`ek),encDat(s`ek))
		 ]
	% TODO: invalidate any internal state associated with EK	% 8
    ELSE s
    ENDIF;

  revokeTrustOut(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsOutput =
    IF not s`permFlags`enableRevokeEK					% 1
    THEN OUT_Error(TPM_PERMANENTEK)				 
    ELSIF not s`permData`ekReset=ekReset				% 2
    THEN OUT_Error(TPM_AUTHFAIL) 
    ELSIF not s`stclearFlags`physicalPresence				% 3
    THEN OUT_Error(TPM_BAD_MODE)     % todo: check
    ELSE OUT_RevokeTrust(TPM_SUCCESS)
    ENDIF;

  readPubek?(s:tpmAbsState,n:(tpmNonce?)) : bool = 
    readPubek(permFlags(s)) AND goodkey?(key(ek(s)))

  readPubekOut(s:tpmAbsState,n:(tpmNonce?)) : tpmAbsOutput =
    IF not s`permFlags`readPubek					% 1
    THEN OUT_Error(TPM_DISABLED_CMD)
    ELSIF not goodkey?(key(ek(s)))					% 2
    THEN OUT_Error(TPM_NO_ENDORSEMENT)
    ELSE LET pubEK=publicKey(ek(s)) IN
    	 LET checksum=SHA1(concat(pubEK,n)) IN				% 3
    	 OUT_ReadPubek(pubEK,checksum,TPM_SUCCESS)			% 4
    ENDIF;


  ownerReadInternalPubOut(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsOutput = 
      % Validate the params and TPM Owner AuthData for this command	% 1
    LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN
    IF key(k)=ekKeyVal							% 2
    THEN OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,TPM_SUCCESS)
    ELSIF key(k)=srkKeyVal						% 3  
    THEN OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,TPM_SUCCESS)
    ELSE OUT_Error(TPM_BAD_PARAMETER)					% 4
    ENDIF;  


  makeIdentity?(s:tpmAbsState,k:(tpmKey?)):bool=
    identity?(keyUsage(k)) AND not(migratable(keyFlags(k)))
    AND not(s`permFlags`FIPS AND never?(authDataUsage(k)))

  makeIdentityState(s:tpmAbsState,iA:(tpmEncAuth?),CADig:(tpmDigest?),
	k:(tpmKey?),a1,a2:authIn) : tpmAbsState = 
    IF makeIdentity?(s,k)
    THEN genKeyState(s)
    ELSE s
    ENDIF;

  setDigAtCreation(s:tpmAbsState,pcr:(tpmPCRInfoLong?)) : (tpmCompositeHash?) =
    LET digest:PCR_COMPOSITE=(# select:=creationPCRSelect(pcr),		% 9
    			        pcrValue:=pcrs(s) #)
    IN tpmCompositeHash(digest);

  makeIdentityLocality : LOCALITY

  % Output a newly generated AIK.  Note that a simulates the new aik.
  makeIdentityOut(s:tpmAbsState,iA:(tpmEncAuth?),CADig:(tpmDigest?),k:(tpmKey?),
	i1,i2:authIn) : tpmAbsOutput =
    % validate k params for key description				% 1
    % IF RSA?(algoId(algoParms(srk))) AND length(k) < 2048		% 1a
    %   OR if alg type not RSA, strength comparable to RSA 2048		% 1b
    % THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 1c
    IF s`permFlags`FIPS AND never?(authDataUsage(k))			% 1d
    THEN OUT_Error(TPM_NOTFIPS)						% 1di
    % Use authHandle(i2) to verify Owner authorized input params	% 2
    % use authHandle(i1) to verify SRK owner authorized input params	% 3
    ELSIF not(identity?(keyUsage(k))) OR migratable(keyFlags(k))	% 4,5
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSE LET a1=decryptADIP(iA,authHandle(i2)),			% 6
    	     o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 7
			resAuth:=usageAuth(encDat(s`srk))#),
	     o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 7
			resAuth:=ownerAuth(i2)#) IN
         LET pcr=tpmPCRInfoLong(makeIdentityLocality,			% 9
			locAtRelease(PCRInfo(k)),
			creationPCRSelect(PCRInfo(k)),
			releasePCRSelect(PCRInfo(k)),
			setDigAtCreation(s,PCRInfo(k)),			% 9
			digAtRelease(PCRInfo(k))),
	     encData=tpmStoreAsymkey(a1,				% 11
			s`permData`tpmProof,				% 13
			pubDataDigest(encDat(k)),
			privKey(encDat(k)),
			encrypted(key(s`srk))) IN			% 15
      	LET idKey=tpmKey(keyGenCnt(s),					% 8
	    		keyUsage(k),
			keyFlags(k),
			authDataUsage(k),
			algoParms(k),
			pcr,
			encData) IN 
	LET idBind=tpmIdContents(CADig,idKey,				% 16
			signed(private(idKey))) IN			% 17
    	OUT_MakeIdentity(idKey,idBind,o1,o2,TPM_SUCCESS)
    ENDIF;


  activateIdentity?(s:tpmAbsState,i:(tpmKey?),b:(activateIdentityBlob?)) : bool=
    %Validate owners AuthData using authHandle(a1) to execute cmd & params  % 1
    %Use authHandle(a2) to validate the AuthData to execute cmd& params	% 2
    LET h1=tpmDigest(cons(tpmPubkey(algoParms(i),key(i)),null)),	% 4
    	b1=decrypt(private(ekVal),b) IN					% 5
    identity?(keyUsage(i)) AND
	CASES b1 OF			  				% 6
	 tpmAsymCAContents(k,d,crs) : h1=d AND not(encrypted?(crs)),
	 tpmEKBlob(blob,crs) :
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :
		  LET C1=tpmCompositeHash((#select:=pcrSelect(p),
				pcrValue:=pcrs(s) #)) IN
		  h1=d AND (null?(pcrSelect(p)) OR C1=digAtRelease(p))
		       AND member(s`locality,locAtRelease(p))
		ELSE FALSE
		ENDCASES
	ELSE FALSE
	ENDCASES


  % Retrieve a key if a can be installed
  % The cmd assumes the availability of the priv key associated with th identity
  % The cmd will verify the association between the keys during the process.
  % The cmd will decrypt the input blob and extract the sess key and verify
  % the connection between the public and private keys. p 157
  activateIdentityOut(s:tpmAbsState,idKey:(tpmKey?),b:(activateIdentityBlob?),
	i1,i2:authIn) : tpmAbsOutput =
    %Validate owners AuthData using authHandle(a1) to execute cmd & params  % 1
    %Use authHandle(a2) to validate the AuthData to execute cmd& params	% 2
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(idKey))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#) IN
    IF not identity?(keyUsage(idKey)) 
    THEN OUT_Error(TPM_BAD_PARAMETER)					% 3
    ELSE LET h1=tpmDigest(cons(tpmPubkey(algoParms(idKey),key(idKey)),null)),% 4
    	     b1=decrypt(private(ekVal),b) IN				% 5
	 CASES b1 OF			  				% 6
	 tpmAsymCAContents(k,d,crs) : 					% 6bi
	 	IF h1=d and not(encrypted?(crs))			% 7
		THEN OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS)		% 7b,9
		ELSE OUT_CPUError(CPU_DECRYPT_ERROR)			% 
		ENDIF,
	 tpmEKBlob(blob,crs) :						% 6ai
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :	
			LET C1=tpmCompositeHash((#select:=pcrSelect(p),	% 8di
    			        	pcrValue:=pcrs(s) #)) IN
			IF h1/=d					% 8c
			THEN OUT_Error(TPM_BAD_PARAMETER)
			ELSIF not(null?(pcrSelect(p)))			% 8d
			      AND C1/=digAtRelease(p)
			THEN OUT_Error(TPM_WRONGPCRVAL)			% 8dii
			ELSIF not member(s`locality,locAtRelease(p))
			THEN OUT_Error(TPM_BAD_LOCALITY)		% 8e
			ELSE OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS)	% 8f
			ENDIF
		ELSE OUT_Error(TPM_BAD_TYPE)				% 8a
		ENDCASES
	 ELSE OUT_Error(TPM_SUCCESS)	% Shouldn't be able to reach here
	 ENDCASES
    ENDIF;
        
  % For PCRS hashing is pcrsExtend instead of tpmDigest
  extend?(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : bool =
    LET L1=s`stanyFlags`localityModifier,				% 2
    	P1=pcrExtendLocal(s`permData`pcrAttrib(pcrNum)) IN		% 3
    (0<=pcrNum<=23) AND member(L1,P1)

  %% Extend operation on TPM state
  extendState(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsState =
    IF extend?(s,pcrNum,inDigest)
    THEN s WITH [`pcrs := pcrsExtend(pcrs(s),pcrNum,inDigest)]
    ELSE s
    ENDIF

  extendOut(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsOutput = 
    LET L1=s`stanyFlags`localityModifier,				% 2
    	P1=pcrExtendLocal(s`permData`pcrAttrib(pcrNum)),		% 3
	H1=pcrsExtend(s`pcrs,pcrNum,inDigest) IN			% 4
    IF pcrNum > 23 OR pcrNum < 0
    THEN OUT_Error(TPM_BADINDEX)					% 1
    ELSIF not member(L1,P1)						% 4
    THEN OUT_Error(TPM_BAD_LOCALITY)
    ELSIF s`permFlags`disable OR s`stclearFlags`deactivated		% 8
    THEN OUT_Extend(reset,TPM_SUCCESS)					% 8a
    ELSE OUT_Extend(extend(s`pcrs(pcrNum),inDigest),TPM_SUCCESS)	% 9a
    ENDIF    

  % Output PCR of given index
  pcrReadOut(s:tpmAbsState,ind:PCRINDEX) : tpmAbsOutput = 
    IF ind > 23 OR ind < 0
    THEN OUT_Error(TPM_BADINDEX)					% 1
    ELSE LET p=s`pcrs IN 						% 2
    	 OUT_PCRRead(p(ind),TPM_SUCCESS)				% 3
    ENDIF

  % Output PCRs from a state as quote
  quote?(k:(tpmKey?)) : bool = 
    signing?(keyUsage(k)) OR identity?(keyUsage(k)) OR legacy?(keyUsage(k))

  quoteOut(s:tpmAbsState,k:(tpmKey?),extDat:(tpmNonce?),p:PCR_SELECTION,
  	i:authIn) : tpmAbsOutput =
    % Validate AuthData to use key pointed to by k			% 1
    % IF not(SHA1?(sigScheme(k))) OR not(INFO?(sigScheme(k)))		% 2
    % THEN OUT_Error(TPM_INAPPROPRIATE_SIG)
    IF not quote?(k)
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSE %Validate p is valid PCR_SELECTION structure			% 4
         LET H1=tpmCompositeHash((#select:=p,pcrValue:=s`pcrs#)),	% 5
             pcrData=getPCRs(s`pcrs,p) IN				
	 OUT_Quote(pcrData,
		   tpmQuote(H1,						% 6c
			    extDat,					% 6d
			    signed(private(k))),			% 7,8
		  (#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#),
		  TPM_SUCCESS)
    ENDIF;

  validatePCRVals(s:tpmAbsState,pcrSelect:PCR_SELECTION) : RECURSIVE nat =
    LET L1=s`stanyFlags`localityModifier,				% 2
    	sum:nat=0 IN
    CASES pcrSelect OF
    	  null : 0,
	  cons(x,xs) : 
	      IF not pcrReset(s`permData`pcrAttrib(x))
	      THEN 1							% 3a
	      ELSIF not member(L1,pcrResetLocal(s`permData`pcrAttrib(x)))
	      THEN 2							% 3b
	      ELSE validatePCRVals(s,xs)
	      ENDIF
    ENDCASES		  
    measure pcrSelect by <<

  % induct on select, grind
  validatePCRs : LEMMA
    FORALL (s:tpmAbsState,select:PCR_SELECTION) : 
    LET a=validatePCRVals(s,select) IN
	a=0 OR a=1 or a=2
  
  check_validatePcrs: THEOREM
  LET s:tpmAbsState=tpmStartup WITH [`permData(pcrAttrib)(6):=
					(# pcrReset:=true,
					pcrResetLocal:=cons(2,null),
					pcrExtendLocal:=allLocs#)],
      p:PCR_SELECTION=cons(5,cons(6,null)) IN
      validatePCRVals(s,p)=2;

  pcrResetState(s:tpmAbsState,pcrSelect:PCR_SELECTION) : tpmAbsState  =
    IF null?(pcrSelect)							% 1b
    THEN s								% 1c
    ELSE LET num=validatePCRVals(s,pcrSelect) IN
      	 COND
      	 num=0 -> s WITH [`pcrs:=pcrsResetSelection(s`pcrs,pcrSelect)],	% 4a
      	 ELSE -> s
      	 ENDCOND
    ENDIF;

  pcrResetOut(s:tpmAbsState,pcrSelect:PCR_SELECTION) : tpmAbsOutput = 
    IF null?(pcrSelect)							% 1b
    THEN OUT_Error(TPM_INVALID_PCR_INFO)				% 1c
    ELSE LET num=validatePCRVals(s,pcrSelect) IN
      	 COND
      	 num=0 -> OUT_PCR_Reset(TPM_SUCCESS),				% 
      	 num=1 -> OUT_Error(TPM_NOTRESETABLE),				% 3a
      	 num=2 -> OUT_Error(TPM_NOTLOCAL),				% 3b
	 ELSE -> OUT_Error(TPM_SUCCESS)
      	 ENDCOND
    ENDIF;
  
  changeAuthOut2(s,d:(tpmSecret?),i:authIn) : (tpmSecret?) = 
    % TODO: Validate the command using ownerAuth(i)			% 10b
    d % IF valid, return d, else ?
    
  changeAuthOut(s:tpmAbsState,p:(tpmKey?),newA:(tpmEncAuth?),d:tpmData,
	i1,i2:authIn) : tpmAbsOutput = 
    %IF not (DATA?(et) OR KEY?(et)) THEN OUT_Error(TPM_WRONG_ENTITYTYPE) % 1
    %IF not OSAP?(sessType(i1`authHandle) THEN OUT_Error(TPM_BAD_MODE)	 % 2
    %IF not OIAP?(sessType(i2`authHandle) THEN OUT_Error(TPM_BAD_MODE)	 % 3
    %IF not ACDP?(pi) THEN OUT_Error(TPM_BAD_PARAMETER)			 % 4
    IF tpmKey?(d) OR tpmStoredData?(d) 	      	   			% 5
    THEN LET decryptAuth=decryptADIP(newA,authHandle(i1)) IN		% 6
    	 % VALIDATE command using authdata in ownerAuth(i1)		% 7
	 IF not storage?(keyUsage(p))	   
	 THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 8
	 ELSE LET b1=decrypt(key(p),d),					% 9
	      	  o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=usageAuth(encDat(p))#),
	      	  o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=ownerAuth(i2)#) IN
	      CASES b1 OF	       					% 10
	      tpmStoreAsymkey(u,m,v,k,c) : 
		OUT_ChangeAuth(tpmStoreAsymkey(
				changeAuthOut2(u,decryptAuth,i2),	% 10,11
				m,v,k,encrypted(key(p))),		% 12
				o1,o2,TPM_SUCCESS),
	      tpmSealedData(a,f,s,d,c) : 
		OUT_ChangeAuth(tpmSealedData(
				changeAuthOut2(a,decryptAuth,i2),	% 10,11
				f,s,d,encrypted(key(p))),		% 12
				o1,o2,TPM_SUCCESS)
	      ELSE OUT_Error(TPM_INVALID_STRUCTURE)			% 10a
	      ENDCASES
	 ENDIF
    ELSE OUT_Error(TPM_INVALID_STRUCTURE)			% TODO: check
    ENDIF
    % TODO: THe TPM MUST enforce the destruction of authHandle(i1) and 
    %  authHandle(i2) sessions						% 13

  oiapState(s:tpmAbsState) : tpmAbsState
    

  oiapOut(s:tpmAbsState) : tpmAbsOutput
%     LET auth=new auth handle,
%     	even=new nonceEven value IN
%     OUT_OIAP(auth,even,TPM_SUCCESS)

  validate(H:(tpmAuthData?)) : bool

%   validateOIAPSession(s:tpmAbsState,targetEntity:authIn) : tpmAbsOutput = 
%     % Validate the authoirzation session handle H referenced in the command 
%     % 	       points to a valid session. Else TPM_INVALID_AUTHHANDLE	% 1
%     IF not validate(targetEntity`authHandle)
%     THEN OUT_Error(TPM_INVALID_AUTHHANDLE)
%     % The TPM shall retrieve the latest version of the caller's nonce (nonceOdd)
%     % 	  and continueAuthSession flag from the input param list, and store it 
%     %	  in internal tpm memory with authSession H   	    	        % 2
%     ELSE LET a=targetEntity`nonceOdd,
%     	     b=targetEntity`contAuthSess,
% 	     c=targetEntity`authHandle IN %TODO: store in internal TPM memory?
%     % The TPM shall retrieve the latest version of the TPM's nonce stored with 
%     % 	  the authorization session H (authLastNonceEven) computed during the 
%     % 	  previously executed command   	      	  	   	% 3
      
    % The TPM must retrieve the secret AuthData (SecretE) of the target entity.
    % 	   The entity and its secret must have been previously loaded into the 
    %	   TPM.       	      	     	       	    	       	      	% 4
    % If the command using the OIAP session requires owner authorization% a
    % IF s`stclearData`ownerReference = TPM_KH_OWNER, 
    % THEN LET SecretE=s`permData`ownerAuth				% 4ai
    % ELSIF s`stclearData`ownerReference -> delegate row		% 4aii
    % THEN LET R1:rowIndex:=s`stclearData`ownerReference IN		% 4aii1
    % 	   LET D1:delegate_table_row:=s`permData`delegateTable`delRow[R1]%4aii2
    % 	   LET SecretE:=D1`authValue IN					% 4aii3
    %	   Validate D1`pub`permissions based on command ordinal		% 4aii4a
    %	   	    D1`pub`pcrInfo based on PCR values			% 4aii4b
    % HMAC Calculation per Part 1 Object-Independent Authorization Protocol? % 5
    %  	   entity secret data
    %      ordinal
    %	   input command parameters
    %	   authorization parameters
    % IF HM/=AuthData value received in input params
    % THEN IF authorization is first session THEN OUT_Error(TPM_AUTHFAIL) 
    %  	   ELSIF authorization is second session THEN OUT_ERROR(TPM_AUTH2FAIL)
    % ELSE TPM executes command which produces an output that requires authentication.			% 6
    % generate nonceEven	% 7
    % HMAC digest to authenticate Per Part 1 Object-Independent-Authorization Protocol
    %  	   return code		      	     				% 8
    % 	   return values
    % 	   authorization parametersto the same entity secret
    % Return return code, output parameters, authorization parameters, and authorization session digest			% 9
    % If continueUse=FALSE then TPM shall terminate the session. Future references to H will return error.		% 10
    % Ecah time access to entity is authorized using OIAP, the TPM must validate that the TPM_PCR_Info_xxx ...AtRelease values if specified for entity  % 11
    % The TPM should validate the values before using the shared secret to validate the command parameters. this prevents dictionary attack on the shared secret when the values are invalid for the entity.        % 11 a
  
  osapState(s:tpmAbsState) : tpmAbsState

  osapOut(s:tpmAbsState) : tpmAbsOutput

  flushSpecificState(s:tpmAbsState,d:tpmData) : tpmAbsState 

  flushSpecificOut(s:tpmAbsState,d:tpmData) : tpmAbsOutput
  
  dataBindOut(s:tpmAbsState,k:(tpmKey?),d:tpmData) : tpmAbsOutput = 
    OUT_Data_Bind(tpmBoundData(d,encrypted(key(k))),CPU_SUCCESS);


  certify?(aik:(tpmKey?),certReq:(tpmIdContents?)) : bool = 
    LET d=checkSig(key(aik),certReq) IN
      d AND tpmDigest?(digest(certReq))
  
  %% TODO: should this be able to affect state? i don't think so.
  certState(s:tpmAbsState,aik:(tpmKey?),certReq:(tpmIdContents?)) : tpmAbsState=
    IF certify?(aik,certReq)
    THEN genKeyState(s)
    ELSE s
    ENDIF
  
  % Generate a certified AIK from an AIK.  Certification assumes that the
  % EK really does belong to the TPM.  We're abstracting away that check.
  certOut(s:tpmAbsState,aik:(tpmKey?),certReq:(tpmIdContents?)) : tpmAbsOutput =
    IF certify?(aik,certReq)
    THEN OUT_Certify(aik,tpmAsymCAContents(tpmSessKey(keyGenCnt(s),clear),
				digest(certReq),
				encrypted(key(ekVal))),
		CPU_SUCCESS)
    ELSE OUT_CPUError(CPU_DECRYPT_ERROR)
    ENDIF
  
  % Read a value and output
  readOut(s:tpmAbsState,i:nat) : tpmAbsOutput = 
    s`memory(i);

  %% Revoke key operation on TPM state
  revokeKeyState(s:tpmAbsState,k:(tpmKey?)) : tpmAbsState =
    s WITH [`keys := revokeKey(k,keys(s))];


  restoreState(s:tpmAbsState) : tpmAbsState =
    IF valid?(restore(s))
       THEN LET rs=restore(s) IN
             (# restore := rs
	      , memory := memory(s)
	      , ek := ek(rs)
	      , srk := srk(rs)
	      , pcrs := pcrs(rs)
	      , keys := keys(rs)
	      , keyGenCnt:=keyGenCnt(rs)
	      , locality := 3
	      , permFlags := permFlags(rs)
	      , permData := permData(rs)
	      , stanyFlags := stanyFlags(rs)
	      , stanyData := stanyData(rs)
	      , stclearFlags := stclearFlags(rs)
	      , stclearData := stclearData(rs)
            #)
       ELSE s
    ENDIF;

  % deactivate by going back to init.  Not sure this is correct.
  deactivateState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`stanyFlags(postInitialize) := TRUE];

  % save a value to external memory
  saveToMemState(s:tpmAbsState,i:nat,v:tpmAbsOutput) : tpmAbsState =
    s WITH [`memory := updateLoc(memory(s),i,v)];

  %% What we want to generate with each command is a pair of type
  %% [tpmAbsOut,tpmAbsState].  executeCom generates the the state
  %% from a TPM state and command while the upcoming outputCom
  %% generates the corresponding output.  Thus, to execute any
  %% operation, both executeCom and outputCom must be used

  %% Run if TPM_Init has run but TPM_Startup has not
  executeComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsState =
    CASES c OF
      ABS_Startup(t) : CASES t OF 
      		        TPM_ST_CLEAR : tpmStartup,
    			TPM_ST_STATE : restoreState(s),
    			TPM_ST_DEACTIVATED : deactivateState(s)
                       ENDCASES
      ELSE s
    ENDCASES;

  %% Run if ABS_Startup has run after TPM_Init
  executeComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsState = 
    CASES c OF
      ABS_Init : tpmPostInit,
      ABS_SaveState : saveState(s),
      ABS_SetOwnerInstall(state) : setOwnerInstallState(s,state),
      ABS_OwnerSetDisable(d,i) : ownerSetDisableState(s,d,i),
      ABS_PhysicalEnable : physicalEnableState(s),
      ABS_PhysicalDisable : physicalDisableState(s),
      ABS_PhysicalSetDeactivated(st) : physicalSetDeactivatedState(s,st),
      ABS_SetTempDeactivated(i) : setTempDeactivatedState(s,i),
      ABS_SetOperatorAuth(opAuth) : setOperatorAuthState(s,opAuth),
      ABS_TakeOwnership(oA,sA,srk,a) : takeOwnershipState(s,oA,sA,srk,a),
      ABS_OwnerClear(a): ownerClearState(s,a),
      ABS_ForceClear: forceClearState(s),
      ABS_DisableOwnerClear(a): disableOwnerClearState(s,a),
      ABS_DisableForceClear: disableForceClearState(s),
      ABS_PhysicalPresence(p): physicalPresenceState(s,p),
      ABS_ResetEstablishmentBit: resetEstablishmentBitState(s),
      ABS_CreateWrapKey(p,k,u,m,a) : createWrapKeyState(s,p,k,u,m,a),
      ABS_LoadKey2(p,k,a): loadKey2State(s,p,k,a), 
      ABS_CMK_SetRestrictions(r,i) : CMKSetRestrState(s,r,i),
      %ABS_CertifyKey(c,k,n,i1,i2) : certifyKeyState(s,c,k,n,i1,i2),
      ABS_CreateEndorsementKeyPair(n,k) : createEKPairState(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKState(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustState(s,r),
      ABS_MakeIdentity(e,d,k,a1,a2) : makeIdentityState(s,e,d,k,a1,a2), 
      ABS_Extend(n,d) : extendState(s,n,d),
      ABS_PCR_Reset(p) : pcrResetState(s,p),
      ABS_FlushSpecific(h) : flushSpecificState(s,h),
      ABS_certify(k,cr) : certState(s,k,cr),
      ABS_senter : 
        changeLocalityState(extendState(pcrsResetSenterState(s),0,sinitHash)),
      ABS_sinit : changeLocalityState(extendState(s,0,mleHash)),
      ABS_save(i,v) : saveToMemState(s,i,v)
      ELSE s
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  executeCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsState =
    IF afterInit?(s)
    THEN executeComPostInit(s,c)
    ELSE executeComStartup(s,c)
    ENDIF;

  %% Run if TPM_Init has run but TPM_Startup has not
  outputComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsOutput =
    OUT_Error(TPM_SUCCESS);

  %% Generate output from a command and state 
  %% Run if ABS_Startup has run after TPM_Init
  outputComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsOutput = 
    CASES c OF
      ABS_SetOwnerInstall(state) : setOwnerInstallOut(s,state),
      ABS_OwnerSetDisable(d,i) : ownerSetDisableOut(s,d,i),
      ABS_PhysicalEnable : physicalEnableOut(s),
      ABS_PhysicalDisable : physicalDisableOut(s),
      ABS_PhysicalSetDeactivated(st) : physicalSetDeactivatedOut(s,st),
      ABS_SetTempDeactivated(i) : setTempDeactivatedOut(s,i),
      ABS_SetOperatorAuth(opAuth) : setOperatorAuthOut(s,opAuth),
      ABS_TakeOwnership(oA,sA,srk,a) : takeOwnershipOut(s,oA,sA,srk,a),
      ABS_OwnerClear(a) : ownerClearOut(s,a),
      ABS_ForceClear : forceClearOut(s),
      ABS_DisableOwnerClear(a) : disableOwnerClearOut(s,a),
      ABS_DisableForceClear : disableForceClearOut(s),
      ABS_PhysicalPresence(p) : physicalPresenceOut(s,p),
      ABS_ResetEstablishmentBit : resetEstablishmentBitOut(s),
      ABS_Seal(k,e,p,data,a) : sealOut(s,k,e,p,data,a),
      ABS_Unseal(d,k,pa,da) : unsealOut(s,d,k,pa,da),
      ABS_UnBind(k,d,a) : unBindOut(s,k,d,a),
      ABS_Data_Bind(k,d) : dataBindOut(s,k,d),
      ABS_CreateWrapKey(parent,k,u,m,a) : createWrapKeyOut(s,parent,k,u,m,a),
      ABS_LoadKey2(p,k,a) : loadKey2Out(s,p,k,a),
      ABS_GetPubKey(k,a): getPubKeyOut(s,k,a), 
      ABS_CreateMigrationBlob(pk,m,migKAuth,encData,a1,a2) : 
      		createMigBlobOut(s,pk,m,migKAuth,encData,a1,a2),
      ABS_ConvertMigrationBlob(p,d,r,a) : convertMigBlobOut(s,p,d,r,a),
      ABS_AuthorizeMigrationKey(mk,ms,a) : authorizeMigKeyOut(s,mk,ms,a),
      ABS_MigrateKey(mk,pubKey,data,a) : migrateKeyOut(s,mk,pubKey,data,a),
      ABS_CMK_SetRestrictions(r,i) : CMKSetRestrOut(s,r,i),
      ABS_CMK_ApproveMA(m,i) : CMKApproveMAOut(s,m,i),
      ABS_CMK_CreateKey(p,d,k,m,a,i) : CMKCreateKeyOut(s,p,d,k,m,a,i),
      ABS_CMK_CreateTicket(k,a,v,i) : CMKCreateTicketOut(s,k,a,v,i),
      ABS_CMK_CreateBlob(p,t,m,k,l,r,d,e,i) : 
      		CMKCreateBlobOut(s,p,t,m,k,l,r,d,e,i),
      ABS_CMK_ConvertMigration(p,r,t,k,l,d,i) : 
    		CMKConvertMigrationOut(s,p,r,t,k,l,d,i),
      ABS_Sign(k,a) : signOut(s,k,a),
      %ABS_CertifyKey(c,k,n,i1,i2) : certifyKeyOut(s,c,k,n,i1,i2),
      ABS_CreateEndorsementKeyPair(n,k) : createEKPairOut(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKOut(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustOut(s,r),
      ABS_ReadPubek(n) : readPubekOut(s,n),
      ABS_OwnerReadInternalPub(k,a) : ownerReadInternalPubOut(s,k,a),
      ABS_MakeIdentity(e,d,k,a1,a2) : makeIdentityOut(s,e,d,k,a1,a2),
      ABS_ActivateIdentity(i,b,a1,a2) : activateIdentityOut(s,i,b,a1,a2),
      ABS_Extend(n,d) : extendOut(s,n,d),
      ABS_PCRRead(ind) : pcrReadOut(s,ind),
      ABS_Quote(k,n,pm,i) : quoteOut(s,k,n,pm,i),
      ABS_PCR_Reset(p) : pcrResetOut(s,p),
      ABS_ChangeAuth(p,n,d,i1,i2) : changeAuthOut(s,p,n,d,i1,i2),
      %ABS_OIAP : oiapOut(s),
      ABS_FlushSpecific(h) : flushSpecificOut(s,h),
      ABS_certify(aik,cr) : certOut(s,aik,cr),
      ABS_read(i) : readOut(s,i)
    ELSE OUT_Error(TPM_SUCCESS)
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  outputCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsOutput =
    IF afterInit?(s)
       THEN outputComPostInit(s,c)
       ELSE outputComStartup(s,c)
    ENDIF;


  %% CPU Command Definitions

  %% Requires use of bind
  CPU_saveOutput(i:nat) : [tpmAbsOutput -> State] =
      useOutputStateOutput(
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    executeCom(s,ABS_save(i,a)))),
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    a)));

  CPU_read(i:nat) : State =
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_read(i)));

  %% Call SENTER 
  CPU_senter : State =
    modify(OUT_Error(TPM_SUCCESS),
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_senter)));

  %% Reset the TPM by senter call - depreciated - DO NOT USE
  %senterResetTPM : State = put(OUT_Error(TPM_SUCCESS),tpmStartup);

  %% Measure sinit by senter call - depreciated - DO NOT USE
  %senterHashSinitTPM : State = TPM_Extend(hash(sinit),0);

  %% Call sinit for initial measurements
  CPU_sinit : State =
    modify(OUT_Error(TPM_SUCCESS),
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_sinit)));
 
  CPU_BuildQuoteFromMem(q,idcont:nat):State =
    output(LAMBDA (s:tpmAbsState) :
	       LET theMem = memory(s) IN
	         IF OUT_Quote?(theMem(q)) AND tpmQuote?(sig(theMem(q)))
		    AND OUT_MakeIdentity?(theMem(idcont))
                 THEN  OUT_FullQuote(sig(theMem(q)),
				idBinding(theMem(idcont)),
				CPU_SUCCESS)
		 ELSE OUT_CPUError(CPU_QUOTE_ERROR) %% TODO: Incorrect?
		 ENDIF);

  gen_quote : THEOREM
   FORALL (state:(afterStartup?),x,y:nat) :
    LET (a,s) = runState(
    	      	CPU_BuildQuoteFromMem(x,y))
		(state) IN
    IF OUT_Quote?(s`memory(x)) AND 
       tpmQuote?(sig(s`memory(x))) AND
       OUT_MakeIdentity?(s`memory(y)) 
       THEN a=OUT_FullQuote(sig(s`memory(x)),
			idBinding(s`memory(y)),
			CPU_SUCCESS)
       ELSE a=OUT_CPUError(CPU_QUOTE_ERROR)
    ENDIF
    AND s=state;


  %% CA Command Definitions
  %% Invoke the certification authority
  CA_certify(aik:(tpmKey?),cr:(tpmIdContents?)) : State =
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_certify(aik,cr))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_certify(aik,cr))));

  %% Assure the CA generates an appropriate cert from the AIK and Ek
  %% proved - Wed Jul 11 13:14:11 EDT 2012
  gen_cert: THEOREM 
   FORALL (state:(afterStartup?),aik:(tpmKey?),id:(tpmIdContents?)) :
    LET (a,s) = runState(
    	      	CA_certify(aik,id))
		(state) IN
    IF certify?(aik,id)
    THEN a=OUT_Certify(aik,tpmAsymCAContents(tpmSessKey(keyGenCnt(state),clear),
				digest(id),
				encrypted(key(ekVal))),
		CPU_SUCCESS)
	 AND s = state WITH [`keyGenCnt := keyGenCnt(state)+1]
    ELSE a=OUT_CPUError(CPU_DECRYPT_ERROR) %TODO: may be incorrect
	 AND s=state
    ENDIF
	
  %% TPM Command Definitions - Note that all commands used by the TPM
  %% have the TPM suffix to distinguish from operations on tpm state.
  %% Commands thus far are defined as state transforming or output
  %% generating.  This does not exclude the eventuality of doing both.

  %% No-op - not a real TPM command
  TPM_Noop : [tpmAbsOutput -> State] =
    (LAMBDA (a:tpmAbsOutput): state((LAMBDA(s:tpmAbsState) : (a,s))));

  %% TPM is off - not a real TPM command
  TPM_Off : State = put(OUT_Nothing,tpmUnknown);

  %% Power up the TPM and hit the TPM_Init signal
  TPM_Init : State = put(OUT_Init(TPM_SUCCESS),tpmPostInit);

  init_post : THEOREM
    FORALL (state:tpmAbsState) :
      LET (a,s) = runState(TPM_Init)(state) IN
       	  a=OUT_Init(TPM_SUCCESS) AND
       	  s=tpmPostInit

  %% Save the TPM state in preparation for restore at startup
  TPM_SaveState : State =
    modify(OUT_SaveState(TPM_SUCCESS),
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_SaveState)))
  
  %% Save state actually saves the correct information.
  %% proved - Fri Sep 14 11:20:25 CDT 2012
  save_state_post : THEOREM
    FORALL (s0:(afterStartup?)) : 
      LET (a,s) = runState(TPM_SaveState)(s0) IN
       LET save = restore(s) IN
        valid?(save)
	AND keys(save) = keys(s0)
	AND ek(save) = ek(s0)
	AND srk(save) = srk(s0)
	AND FORALL (i:PCRINDEX) : 
	      IF pcrReset(pcrAttrib(permData(save))(i))
	         THEN pcrs(save)(i) = resetOne
		 ELSE pcrs(save)(i) = pcrs(s0)(i)
	      ENDIF
	AND permFlags(save) = permFlags(s0)
	AND permData(save) = permData(s0)
	AND a=OUT_SaveState(TPM_SUCCESS)

  %% Start up the TPM after TPM_Init
  TPM_Startup(st:TPM_STARTUP_TYPE) : State =
    modify(OUT_Startup(TPM_SUCCESS),
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Startup(st))));

  %% TPM_Startup post condition covering three major cases: clear, restore
  %% state and deactivate.
  %% proved - Sat Sep 15 09:58:36 CDT 2012
  startup_post : THEOREM
    FORALL (s0:(afterInit?), f:TPM_STARTUP_TYPE) : 
      LET (a,s) = runState(TPM_Startup(f))(s0) IN
       LET save = restore(s) IN
        CASES f OF
          TPM_ST_CLEAR : s = tpmStartup,
	  TPM_ST_STATE : valid?(save) AND wellFormedRestore?(save) =>
	                      keys(save) = keys(s)
			      AND ek(save) = ek(s)
			      AND srk(save) = srk(s)
			      AND FORALL (i:PCRINDEX) : 
	      		      	    IF pcrReset(pcrAttrib(permData(save))(i))
	         		    THEN pcrs(save)(i) = resetOne
		 		    ELSE pcrs(save)(i) = pcrs(s)(i)
	      			    ENDIF
			      AND permFlags(save) = permFlags(s)
			      AND permData(save) = permData(s),
	  TPM_ST_DEACTIVATED : postInitialize(stanyFlags(s))
        ENDCASES
	AND a=OUT_Startup(TPM_SUCCESS)

  %% Prove that the only command that can run and do anyting folling a
  %% TPM_Init is TPM_Startup.  If anything else tries to run, nothing happens. 
  %% Note the use of an "anything" command in the first command sequence.
  startup_after_init: THEOREM 
    FORALL (s:tpmAbsState,a:tpmAbsOutput,c:tpmAbsInput) :
      NOT ABS_Startup?(c) =>
        LET (a0,s0) = runState(TPM_Init 
	    	      >> state(LAMBDA (s:tpmAbsState) : 
		      	 	      	(a,executeCom(s,c))))(s) IN
          LET (a1,s1) = runState(TPM_Init)(s) IN
	      s0=s1


  %% Prove that senter after power up results in reset PCRs followed by sinit
  %% measurement.
  %% proved - Tue Jun 12 15:31:12 CDT 2012
  resetMonad: THEOREM 
    FORALL (hv:HV, state:tpmAbsState) :
      LET (a,s) = runState(
      	          TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
      		  >> CPU_senter
      		  >> CPU_sinit)
      		  (state)
      IN s = changeLocalityState(
               changeLocalityState(
                 extendState(
                   extendState(pcrsResetSenterState(tpmStartup),0,sinitHash),
			0,mleHash)))
      AND a = OUT_Error(TPM_SUCCESS)

  % grind, decompose-equality
  unique_error: LEMMA 
    FORALL (b0,b1:ReturnCode) : OUT_Error(b0)=OUT_Error(b1) iff b0=b1;

  TPM_SetOwnerInstall(state:bool) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_SetOwnerInstall(state))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_SetOwnerInstall(state))));

  set_owner_install_post: THEOREM FORALL (state:(afterStartup?),b:bool) :
    LET (a,s) = runState(
		 TPM_SetOwnerInstall(b))
		 (state) IN
    IF not(invalidAuth?(s`permData`ownerAuth)) 
    THEN a=OUT_SetOwnerInstall(TPM_SUCCESS) AND s=state
    ELSIF state`stclearFlags`physicalPresence
    THEN a=OUT_SetOwnerInstall(TPM_SUCCESS) AND 
    	 s=state WITH [`permFlags`ownership:=b]
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;

  
  TPM_OwnerSetDisable(d:bool,i:authIn) : State = 
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_OwnerSetDisable(d,i))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerSetDisable(d,i))));

  owner_set_disable_post:THEOREM FORALL (state:(afterStartup?),b:bool,i:authIn):
    LET (a,s) = runState(
		 TPM_OwnerSetDisable(b,i))
		 (state) IN
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
    	a=OUT_OwnerSetDisable(o1,TPM_SUCCESS) AND 
    	s=state WITH [`permFlags`disable:=b]


  TPM_PhysicalEnable : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalEnable)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalEnable)));

  physical_enable_post: THEOREM FORALL (state:(afterStartup?)) :
    LET (a,s) = runState(
		 TPM_PhysicalEnable)
		 (state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_PhysicalEnable(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags`disable:=FALSE]
    ENDIF;


  TPM_PhysicalDisable : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalDisable)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalDisable)));

  physical_disable_post: THEOREM FORALL (state:(afterStartup?)) :
    LET (a,s) = runState(
		 TPM_PhysicalDisable)
		 (state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_PhysicalDisable(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags`disable:=TRUE]
    ENDIF;


  TPM_PhysicalSetDeactivated(st:bool) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalSetDeactivated(st))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalSetDeactivated(st))));

  physical_set_deactivated_post:THEOREM FORALL (state:(afterStartup?),st:bool) :
    LET (a,s) = runState(
		 TPM_PhysicalSetDeactivated(st))
		 (state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_PhysicalSetDeactivated(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags`disable:=st]
    ENDIF;


  TPM_SetTempDeactivated(i:authIn) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_SetTempDeactivated(i))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_SetTempDeactivated(i))));

  set_temp_deactivated_post: THEOREM FORALL (state:(afterStartup?),i:authIn) :
    LET (a,s) = runState(
		 TPM_SetTempDeactivated(i))
		 (state) IN
    IF not state`permFlags`operator
    THEN a=OUT_Error(TPM_NOOPERATOR) AND s=state
    ELSIF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
    	a=OUT_SetTempDeactivated(o1,TPM_SUCCESS) AND
    	s=state WITH [`stclearFlags`deactivated:=TRUE]
    ENDIF;


  TPM_SetOperatorAuth(opAuth:(tpmSecret?)) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_SetOperatorAuth(opAuth))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_SetOperatorAuth(opAuth))));

  set_operator_auth_post:THEOREM FORALL(state:(afterStartup?),op:(tpmSecret?)) :
    LET (a,s) = runState(
		 TPM_SetOperatorAuth(op))
		 (state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_SetOperatorAuth(TPM_SUCCESS) AND
    	 s=state WITH [`permData`operatorAuth:=op
	 	      ,`permFlags`operator:=TRUE]
    ENDIF;


  %% Establish SRK
  TPM_TakeOwnership(ownerA,srkA:(tpmEncAuth?),srk:(tpmKey?),a:authIn) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : 
			executeCom(s,ABS_TakeOwnership(ownerA,srkA,srk,a))),
	(LAMBDA (s:tpmAbsState) : 
			outputCom(s,ABS_TakeOwnership(ownerA,srkA,srk,a))));
	 
  take_ownership_post: THEOREM FORALL (state:(afterStartup?),srk:(tpmKey?),
  	eOA,eSA:(tpmEncAuth?),aIn:authIn) : 
    LET (a,s) = runState(
		 TPM_TakeOwnership(eOA,eSA,srk,aIn))
		 (state) IN
    IF takeOwnership?(state,srk) 
    THEN LET A2=decrypt(private(state`ek),eSA),
    	     A1=decrypt(private(state`ek),eOA) IN
    	 LET asymkey=tpmStoreAsymkey(A2,
			migrationAuth(encDat(srk)),
			pubDataDigest(encDat(srk)),
			privKey(encDat(srk)),
			crs(encDat(srk))) IN
	 LET K1=tpmKey(key(srk),keyUsage(srk),keyFlags(srk),
		      authDataUsage(srk),algoParms(srk),
		      PCRInfo(srk),asymkey),
	     aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		    contAuthSess:=TRUE,resAuth:=A1#) IN
   	 a=OUT_TakeOwnership(K1,aOut,TPM_SUCCESS)
	 AND 
     	 s=state WITH [`srk:=K1
		      ,`permData(ownerAuth):=A1
		      ,`permFlags(readPubek):=FALSE]
    ELSIF i(state`permData`ownerAuth)/=INVALIDAUTH 
    	  THEN a=OUT_Error(TPM_OWNER_SET) AND s=state
    ELSIF not state`permFlags`ownership 
	  THEN a=OUT_Error(TPM_INSTALL_DISABLED) AND s=state 
    ELSIF not goodkey?(key(state`ek)) 
    	  THEN a=OUT_Error(TPM_NO_ENDORSEMENT) AND s=state 
    ELSIF not storage?(keyUsage(srk)) 
    	  THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(srk)) 
    	  THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF not RSA?(algoId(algoParms(srk))) 
    	  THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state 
    ELSIF s`permFlags`FIPS AND never?(authDataUsage(srk)) 
    	  THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;

  take_ownership_post2: THEOREM FORALL (state:(afterStartup?),srk:(tpmKey?),
  	eOA,eSA:(tpmEncAuth?),aIn:authIn) : 
    LET (a,s) = runState(
		 TPM_TakeOwnership(eOA,eSA,srk,aIn))
		 (state) IN
    not (takeOwnership?(state,srk)) =>
    not (a=OUT_Error(TPM_SUCCESS))


  % To be used with commands that use clear command: 
  %  TPM_OwnerClear, TPM_ForceClear, TPM_RevokeTrust
  clear_post(s,state:(afterStartup?),a,af,at:tpmAbsOutput,p:bool) : bool = 
        % 4. The TPM MUST NOT modify the following TPM_PERMANENT_DATA items
    %s`permData`endorsementKey = state`permData`endorsementKey AND	% 4a
    %s`permData`revMajor = state`permData`revMajor AND	       		% 4b
    %s`permData`revMinor = state`permData`revMinor AND			% 4c
    %s`permData`manuMaintPub = state`permData`manuMaintPub AND		% 4d
    %s`permData`auditMonotonicCounter = state`permData`auditMonotonicCounter AND
    %s`permData`monotonicCounter = state`permData`monotonicCounter AND	% 4f
    s`permData`pcrAttrib = state`permData`pcrAttrib AND		   	% 4g
    %s`permData`rngState = state`permData`rngState AND			% 4h
    s`permData`ekReset = state`permData`ekReset	   			% 4i
    %s`permData`lastFamilyID = state`permData`lastFamilyID AND		% 4j
    %s`permData`tpmDAASeed = state`permData`tpmDAASeed AND 		% 4k
    %s`permData`authDIR[0] = state`permData`authDIR[0] AND		% 4l
    %s`permData`daaProof = state`permData`daaProof AND 			% 4m
    %s`permData`daaBlobKey = state`permData`daaBlobKEY;			% 4n
    AND
    	 IF p
    	 THEN a=at AND s=state
	 ELSE a=af AND 
	      keys(s) = emptyset AND					% 3
	      s`permData`ownerAuth = tpmSecret(INVALIDAUTH) AND		% 5a
    	      %s`permData`srk =  AND 			  		% 5b
	      %s`permData`delegateKey =  AND				% 5c
	      %s`permData`delegateTable =  AND				% 5d
	      %s`permData`contextKey =  AND				% 5e
	      s`permData`tpmProof = tpmSecret(INVALIDPROOF) AND		% 5f
	      s`permData`operatorAuth = tpmSecret(INVALIDAUTH) AND	% 5g
	      s`permFlags = state`permFlags WITH
    		  [`disable:=disableDef					% 9a
		  ,`deactivated:=deactivatedDef				% 9b
		  ,`readPubek:=readPubekDef				% 9c
		  ,`disableOwnerClear:=disableOwnerClearDef		% 9d
		  ,`disableFullDALogicInfo:=disableFullDALogicInfoDef	% 9e
		  ,`allowMaintenance:=allowMaintenanceDef		% 9f
		  ,`readSRKPub:=readSRKPubDef				% 9g
		  ,`ownership:=TRUE					% 10a
		  ,`operator:=FALSE					% 10b
		  ,`maintenanceDone:=FALSE]				% 10b
	      %% TODO: AND LOTS MORE STUFF!
	 ENDIF
    % TODO: TPM_OwnerClear 3,6-8,11-14


  TPM_OwnerClear(a:authIn) : State = 
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_OwnerClear(a))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerClear(a))));

  owner_clear_post: THEOREM FORALL (state:(afterStartup?),a:authIn) : 
    LET(a,s) = runState(
	       TPM_OwnerClear(a))
	       (state) IN   
%     IF k=private(srk(s))
%     THEN 
      LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,resAuth:=ownerAuth(a)#) IN
      clear_post(s,state,
		 a,OUT_OwnerClear(a1,TPM_SUCCESS),OUT_Error(TPM_CLEAR_DISABLED),
		 state`permFlags`disableOwnerClear);
%     ELSE a=OUT_Error(TPM_AUTHFAIL) AND keys(s)=keys(state)
%     ENDIF


  TPM_ForceClear : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_ForceClear)),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ForceClear)));

  force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(
	       TPM_ForceClear)
	       (state) IN
    IF s`stclearFlags`physicalPresence
    THEN clear_post(s,state,
	       a,OUT_ForceClear(TPM_SUCCESS),OUT_Error(TPM_CLEAR_DISABLED),
	       state`stclearFlags`disableForceClear)
    ELSE a=OUT_Error(TPM_BAD_PRESENCE) and s=state
    ENDIF;


  TPM_DisableOwnerClear(a:authIn) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableOwnerClear(a))),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_DisableOwnerClear(a))));

  disable_owner_clear_post: THEOREM FORALL (state:(afterStartup?),a:authIn) : 
    LET(a,s) = runState(
    	       TPM_DisableOwnerClear(a))
	       (state) IN
      s=state with [`permFlags`disableOwnerClear:=TRUE] AND
      LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		       contAuthSess:=TRUE,resAuth:=ownerAuth(a)#) IN
      	  a=OUT_DisableOwnerClear(a1,TPM_SUCCESS);


  TPM_DisableForceClear : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableForceClear)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_DisableForceClear)));

  disable_force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(
    	       TPM_DisableForceClear)
	       (state) IN
      s`stclearFlags`disableForceClear = TRUE
      AND a = OUT_DisableForceClear(TPM_SUCCESS);


  TSC_PhysicalPresence(p:PHYSPRES) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalPresence(p))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalPresence(p))));

  physical_presence_post: THEOREM FORALL (state:(afterStartup?),p:PHYSPRES) : 
    LET(a,s) = runState(
    	       TSC_PhysicalPresence(p))
	       (state) IN
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
    THEN IF state`permFlags`physicalPresenceLifetimeLock
    	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)		
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2d
	 ELSE s=state WITH [`permFlags`physicalPresenceHWEnable:=
			IF member(HW_ENABLE,p) THEN TRUE		% 2e
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2f
			ELSE s`permFlags`physicalPresenceHWEnable ENDIF,
		      `permFlags`physicalPresenceCMDEnable:=
			IF member(CMD_ENABLE,p) THEN TRUE		% 2g
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2h
			ELSE s`permFlags`physicalPresenceCMDEnable ENDIF,
		      `permFlags`physicalPresenceLifetimeLock:=
			IF member(LIFETIME_LOCK,p) THEN TRUE		% 2i
			ELSE s`permFlags`physicalPresenceLifetimeLock ENDIF]
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 2j
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3a
	 ELSIF state`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3d
	 ELSIF state`stclearFlags`physicalPresenceLock
	 THEN  s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN s=state WITH [`stclearFlags`physicalPresence:=FALSE	% 3fi
	      	     ,`stclearFlags`physicalPresenceLock:=TRUE]		% 3fii
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
    	 ELSIF member(PRESENT,p)					% 3g
	 THEN s=state WITH [`stclearFlags`physicalPresence:=TRUE]	% 3gi
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN s=state WITH [`stclearFlags`physicalPresence:=FALSE]	% 3hi
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
	 ELSE s=state AND a=OUT_Error(TPM_BAD_PARAMETER) % should never get here
    	 ENDIF
    ELSE s=state AND a=OUT_Error(TPM_BAD_PARAMETER)			% 4
    ENDIF;

  TSC_ResetEstablishmentBit : State = 
    modifyOutput(
	(LAMBDA (s:tpmAbsState): executeCom(s,ABS_ResetEstablishmentBit)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ResetEstablishmentBit)));

  reset_establishment_post: THEOREM
    FORALL (state:(afterStartup?)) :
      LET (a,s) = runState(
      	  	  TSC_ResetEstablishmentBit)
		  (state) IN
    IF resetEstablishment?(state) 
    THEN a=OUT_ResetEstablishmentBit(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags(tpmEstablished):=FALSE]
    ELSE a=OUT_Error(TPM_BAD_LOCALITY) AND s=state
    ENDIF;


  %% Seal and output a blob (should be binary or data)
  TPM_Seal(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : State = %encAuth:(tpmSecret?)
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Seal(k,encAuth,pcrInfo,
						inData,a)));

  %% Seal a secret successfully
  seal_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),e:(tpmEncAuth?),%e:(tpmSecret?),
    	   p:(tpmPCRInfoLong?),d:tpmData,aIn:authIn) :
      LET (a,s) = runState(
     	 	  TPM_Seal(k,e,p,d,aIn))
 		  (state) IN
      IF not(storage?(keyUsage(k)) AND not(migratable(keyFlags(k))))
      THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ELSE LET sealInfo=tpmPCRInfoLong(state`stanyFlags`localityModifier,
				locAtRelease(p),
				creationPCRSelect(p),
				releasePCRSelect(p),
				tpmCompositeHash((#select:=creationPCRSelect(p),
						   pcrValue:=state`pcrs#)),
				digAtRelease(p)),
	       a1=decryptADIP(e,authHandle(aIn)) IN
	   a=OUT_Seal(tpmStoredData(sealInfo,
			tpmSealedData(a1,
				state`permData`tpmProof,
				SHA1(tpmStoredData(sealInfo,
							tpmNull,clear)),
				d,encrypted(key(k))),
			clear),
		(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,resAuth:=usageAuth(encDat(k)) #),
		TPM_SUCCESS)
      ENDIF
      AND s=state
 

  %% Unseal and output a blob (should be binary or data)
  TPM_Unseal(p:(tpmKey?),d:(tpmStoredData?),pa,da:authIn) : State = 
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Unseal(p,d,pa,da)));

  unseal_post: THEOREM
    FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmStoredData?),pa,da:authIn) :
      LET (a,s) = runState(
                  TPM_Unseal(p,d,pa,da))
		  (state) IN
      LET S2=tpmStoredData(sealInfo(d),tpmNull,clear),
      	  H2=tpmCompositeHash((#select:=releasePCRSelect(sealInfo(d)),
				pcrValue:=s`pcrs#)) IN
      IF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))))
      	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ELSIF not(clear?(crs(decrypt(key(p),d))))
      	 THEN a=OUT_CPUError(CPU_DECRYPT_ERROR) %  TODO: correct?
      ELSIF not(tpmProof(encData(d))=s`permData`tpmProof AND 
	    storedDigest(encData(d))=SHA1(S2))
	 THEN a=OUT_Error(TPM_NOTSEALED_BLOB) 
      ELSIF not(locAtRelease(sealInfo(S2))=s`stanyFlags`localityModifier)
	 THEN a=OUT_Error(TPM_BAD_LOCALITY)
      ELSIF not(H2=digAtRelease(sealInfo(S2)))
      	 THEN a=OUT_Error(TPM_WRONGPCRVAL)
      ELSE LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(p))#) IN
    	 a=OUT_Unseal(data(encData(d)),b,b,TPM_SUCCESS)
      ENDIF
      AND s=state

  unseal_prev_post: THEOREM
    FORALL (state:(afterStartup?),j,k:(tpmKey?),e:(tpmEncAuth?),%e:(tpmSecret?),
    	   p:(tpmPCRInfoLong?),d:tpmData,a,ap,ad:authIn) :
      LET (a,s) = runState(
      	  	  TPM_Seal(k,e,p,d,a)
		  >>= (LAMBDA (a:tpmAbsOutput) : 
		       CASES a OF
		         OUT_Seal(sd,ao,m) : TPM_Unseal(j,sd,ap,ad) 
			 ELSE TPM_Noop(a)
		       ENDCASES))
		  (state) IN  
	seal?(k) AND unseal?(j) AND key(j)=private(k) AND
	locAtRelease(p)=localityModifier(stanyFlags(state)) AND
	digAtRelease(p)=tpmCompositeHash((#select:=releasePCRSelect(p),
						pcrValue:=state`pcrs#))
	   =>  LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
	       	   resAuth:=usageAuth(encDat(j))#) IN 
	a=OUT_Unseal(d,b,b,TPM_SUCCESS)
	AND s=state


  %% UnBind encrypted blob (decrypt)
  TPM_UnBind(keyHandle:(tpmKey?),inData:(tpmBoundData?),a:authIn) : State = 
     output(LAMBDA (s:tpmAbsState):outputCom(s,ABS_UnBind(keyHandle,inData,a)));

  %% UnBind an encrypted blob successfully
  unBind_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),d:(tpmBoundData?),a:authIn) : 
      LET (a,s) = runState(
		  TPM_UnBind(k,d,a))
		  (state) IN
      LET d1=decrypt(private(k),d) IN
      IF not(legacy?(keyUsage(k)) OR bind?(keyUsage(k)))
      	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ELSIF not(clear?(crs(d1)))
      	 THEN a=OUT_CPUError(CPU_DECRYPT_ERROR)
      ELSE LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#) IN 
	   	a=OUT_UnBind(payloadData(d),b,TPM_SUCCESS)
      ENDIF
      AND s=state

	
  Tspi_Data_Bind(k:(tpmKey?),d:tpmData) : State = 
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Data_Bind(k,d)));

%   dataBindOut(s:tpmAbsState,k:(tpmKey?),d:tpmData) : tpmAbsOutput = 
%     OUT_Data_Bind(tpmBoundData(d,encrypted(key(k),clear)),CPU_SUCCESS);


  %% UnBind an encrypted blob successfully
  unBind_prev_post: THEOREM 
    FORALL (state:(afterStartup?),d:tpmData,k:(tpmKey?),a:authIn) : 
      LET (a,s) = runState(
		  Tspi_Data_Bind(k,d)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		      CASES a OF
		        OUT_Data_Bind(d1,m) : TPM_UnBind(k,d1,a) 
			ELSE TPM_Noop(a) 
		      ENDCASES)
 		  (state) IN 
	  unBind?(k) =>
	  LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#) IN 
	  a = OUT_UnBind(d,b,TPM_SUCCESS) 
	  AND s = state


  %% Wrap new key k with parent key
  TPM_CreateWrapKey(p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),a:authIn) : State = 
     modifyOutput(
	  (LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_CreateWrapKey(p,k,dUA,dMA,a))),
          (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateWrapKey(p,k,dUA,dMA,a)))
	      );

  create_wrap_key_post: THEOREM 
    FORALL (state:(afterStartup?),p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
    	   a:authIn) : 
      LET (a,s) = runState(
     	          TPM_CreateWrapKey(p,k,dUA,dMA,a))
		  (state) IN
    IF not storage?(keyUsage(p)) 
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(p)) AND not(migratable(keyFlags(k)))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF identity?(keyUsage(k)) or authChange?(keyUsage(k))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migrateAuthority(keyFlags(k))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF state`permFlags`FIPS AND
    	  (never?(authDataUsage(k)) OR legacy?(keyUsage(k)))
       THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSIF (storage?(keyUsage(k)) OR migrate?(keyUsage(k))) AND
    	  not(RSA?(algoId(algoParms(k))))
       THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
    ELSE LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)),
    	     b=(#nonceEven:=EVEN,nonceOdd:=ODD,
		 contAuthSess:=FALSE,resAuth:=usageAuth(encDat(p))#),
	     migAuth:(tpmSecret?)=IF migratable(keyFlags(k)) 
	     			  THEN DM1 ELSE state`permData`tpmProof ENDIF,
	     h=tpmCompositeHash((#select:=creationPCRSelect(PCRInfo(k)),
					pcrValue:=state`pcrs#)) IN
	 LET encData=tpmStoreAsymkey(DU1,migAuth,pubDataDigest(encDat(k)),
			inverse(state`keyGenCnt),encrypted(key(p))),
	     pcrs=tpmPCRInfoLong(state`locality,
				locAtRelease(PCRInfo(k)),
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				h,digAtRelease(PCRInfo(k))) IN
	     a=OUT_CreateWrapKey(tpmKey(state`keyGenCnt,
					keyUsage(k),
					keyFlags(k),
					authDataUsage(k),
					algoParms(k),
					pcrs,
					encData),
				b,TPM_SUCCESS)
      	 AND s=state WITH [`keyGenCnt:=keyGenCnt(state)+1]
    ENDIF


  %% Install key k in a TPM
  TPM_LoadKey2(p,k:(tpmKey?),a:authIn):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_LoadKey2(p,k,a))),
	   (LAMBDA (s:tpmAbsState):outputCom(s,ABS_LoadKey2(p,k,a))));

  % A key is installed if it is wrapped with SRK
  % TODO: loadKey2State
  load_key_post: THEOREM 
    FORALL (state:(afterStartup?),p,k:(tpmKey?),i:authIn) :
      LET (a,s) = runState(
    		    TPM_LoadKey2(p,k,i))
		    (state) IN
    IF not storage?(keyUsage(p)) 
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND
    	 s=state
    ELSIF not(clear?(crs(decrypt(key(p),encDat(k)))))  	     % TODO CHECK
    THEN a=OUT_CPUError(CPU_DECRYPT_ERROR) AND
	 s=state
    ELSE LET aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		   	resAuth:=ownerAuth(i)#) IN
    	 CASES keyUsage(k) OF
	 identity: IF migratable(keyFlags(k))=FALSE
	 	   THEN IF migratable(keyFlags(k))=0 AND 
		   	   migrationAuth(encDat(k))/=tpmProof(permData(state))
			THEN a=OUT_Error(TPM_FAIL) AND
			     s=state
			ELSIF FIPS(permFlags(state)) AND
			      (never?(authDataUsage(k)) OR legacy?(keyUsage(k)))
			THEN a=OUT_Error(TPM_NOTFIPS) AND
			     s=state
			ELSE a=OUT_LoadKey2(k,aOut,TPM_SUCCESS) AND
		   	     s=state with [`keys:=loadKey(k,p,
						state`keys,state`pcrs)]
			ENDIF
	 	   ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE) AND
			s=state
	 	   ENDIF,
	 authChange: a=OUT_Error(TPM_INVALID_KEYUSAGE) AND
	 	     s=state
	 ELSE IF migratable(keyFlags(k))=0 AND 
		 migrationAuth(encDat(k))/=tpmProof(permData(state))
	      THEN a=OUT_Error(TPM_FAIL) AND
	      	   s=state
	      ELSIF FIPS(permFlags(state)) AND (never?(authDataUsage(k)) OR 
	      	    			   legacy?(keyUsage(k)))
	      THEN a=OUT_Error(TPM_NOTFIPS) AND
	      	   s=state
	      ELSE a=OUT_LoadKey2(k,aOut,TPM_SUCCESS) AND
	      	   s=state with [`keys:=loadKey(k,p,state`keys,
					state`pcrs)]
	      ENDIF
	 ENDCASES
    ENDIF;

  load_key_pred_test: THEOREM
    FORALL (state:(afterStartup?),p,k:(tpmKey?),aIn:authIn) :
      LET (a,s) = runState(
    		    TPM_LoadKey2(p,k,aIn))
		    (state) IN
	IF loadKey2?(state,p,k)
	THEN LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		       contAuthSess:=TRUE,resAuth:=ownerAuth(aIn)#) IN
	     a=OUT_LoadKey2(k,aOut,TPM_SUCCESS) AND 
	     IF key(p)=key(TPM_KH_SRK)
	     	THEN s=state WITH [`keys:=add(key(k),state`keys)]
	     ELSIF member(key(p),state`keys)
	     	THEN s=state WITH [`keys:=add(key(k),state`keys)]
	     ELSE s=state 
	     ENDIF
	ELSE IF not storage?(keyUsage(p))  
	     THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
	     ELSIF not(clear?(crs(decrypt(key(p),encDat(k))))) %todo check
	     THEN a=OUT_CPUError(CPU_DECRYPT_ERROR)
	     ELSIF identity?(keyUsage(k)) AND migratable(keyFlags(k))
	     THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
	     ELSIF authChange?(keyUsage(k))
	     THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
	     ELSIF not(migratable(keyFlags(k))) AND 
	     	   migrationAuth(encDat(k))/=tpmProof(permData(state))
	     THEN a=OUT_Error(TPM_FAIL)
	     ELSIF FIPS(permFlags(state)) AND (never?(authDataUsage(k)) OR
	     	   legacy?(keyUsage(k)))
	     THEN a=OUT_Error(TPM_NOTFIPS)
	     ELSE a=OUT_Error(TPM_SUCCESS)
	     ENDIF 
	     AND s=state
	ENDIF

  load_key_post2: THEOREM
    FORALL (state:(afterStartup?),p,k:(tpmKey?),aIn:authIn) :
      LET (a,s) = runState(
    		    TPM_LoadKey2(p,k,aIn))
		    (state) IN
    not (loadKey2?(state,p,k)) =>
    not (a=OUT_Error(TPM_SUCCESS))

  %% A key is installed if it is wrapped with an installed key
  %% proved - Tue Jun 12 15:38:22 CDT 2012
  load_key_post3: THEOREM 
    FORALL (state:(afterStartup?),p,j,k:(tpmKey?),aIn:authIn) :
      LET (a,s) = runState(
      	  	  TPM_LoadKey2(srk(state),k,aIn)
		  >> TPM_LoadKey2(k,j,aIn))
		  (state) IN
	loadKey2?(state,srk(state),k) AND loadKey2?(state,k,j) 
	AND srk(state) = TPM_KH_SRK
		=> member(key(j),s`keys);

  load_key_prev_post: THEOREM 
    FORALL (state:(afterStartup?),k,p:(tpmKey?),x:nat,dUA,dMA:(tpmEncAuth?),
    	   i:authIn,d:PCRVALUES) :
      LET (a,s) = runState(
      	  	  TPM_CreateWrapKey(p,k,dUA,dMA,i)
		  >>= CPU_saveOutput(x)
		  >>= (LAMBDA (a:tpmAbsOutput) :
		         CASES a OF
		         OUT_CreateWrapKey(wk,a,m) : TPM_LoadKey2(p,wk,i)
			 ELSE TPM_Noop(a)
			 ENDCASES))
		  (state) IN
      OUT_CreateWrapKey?(s`memory(x)) AND
      createWrapKey?(p,k) AND loadKey2?(state,p,wrappedKey(s`memory(x))) => 
      LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		       contAuthSess:=TRUE,resAuth:=ownerAuth(i)#) IN
      a=OUT_LoadKey2(wrappedKey(s`memory(x)),aOut,TPM_SUCCESS) 
      AND
      s=state WITH[`keyGenCnt:=state`keyGenCnt+1
      	      	  ,`keys:=IF member(key(p),state`keys) OR key(p)=key(TPM_KH_SRK)
      	     	   	   THEN addKey(wrappedKey(s`memory(x)),state`keys)
	     		   ELSE state`keys
	     		   ENDIF
      	      	  ,`memory:=s`memory]


%   %%install nested wrapped keys?
%   nested_wrapped_keys_post: THEOREM 
%     FORALL (state:(afterStartup?),p,k1,k2:(tpmKey?)) :
%       LET (a,s) = runState(
% 		  TPM_CreateWrapKey(p,k1)
% 		  >>= CPU_saveOutput(0)
% 		  >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       CASES a OF 
% 		         OUT_CreateWrapKey(wk,m) : TPM_LoadKey2(p,wk) 
% 			 ELSE TPM_Noop(a) 
% 		       ENDCASES)
% 		  >>= (LAMBDA (a:tpmAbsOutput) :
% 		       CASES a OF
% 		         OUT_LoadKey2(wk,m) : TPM_CreateWrapKey(wk,k2)
% 			 ELSE TPM_Noop(a)
% 		       ENDCASES)
% 		  >>= CPU_saveOutput(1)
% 		  >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       CASES a OF
% 		         OUT_CreateWrapKey(wk2,m) : TPM_LoadKey2(k1,wk2) 
% 			 ELSE TPM_Noop(a) 
% 		       ENDCASES))
% 		  (state) IN
% 	OUT_CreateWrapKey?(s`memory(0)) AND OUT_CreateWrapKey?(s`memory(1)) AND
% 	createWrapKey?(p,k1) AND createWrapKey?(k1,k2) AND 
% 	loadKey2?(p,wrappedKey(s`memory(0))) AND loadKey2?(k1,wrappedKey(s`memory(1)))=>
% 	a=OUT_LoadKey2(wrappedKey(s`memory(1)),TPM_SUCCESS)


  %% Install key k in a TPM
  TPM_GetPubKey(k:(tpmKey?),a:authIn):State =
    output((LAMBDA (s:tpmAbsState):outputCom(s,ABS_GetPubKey(k,a))));

  get_pub_key_post: THEOREM
   FORALL (state:(afterStartup?),k:(tpmKey?),a:authIn) :
    LET (a,s) = runState(
       	       TPM_GetPubKey(k,a))
	       (state) IN
    IF getPubKey?(state,k)
    THEN LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		       resAuth:=usageAuth(encDat(k))#) IN
	a=OUT_GetPubKey(tpmPubkey(algoParms(k),key(k)),aOut,TPM_SUCCESS)
    ELSIF not never?(authDataUsage(k)) 
    THEN a=OUT_Error(TPM_AUTHFAIL) 
    ELSIF s`permFlags`readSRKPub=FALSE
    THEN a=OUT_Error(TPM_INVALID_KEYHANDLE)
    ELSIF pcrIgnoredOnRead(keyFlags(k))=FALSE
    	  AND dig(digAtRelease(PCRInfo(k)))/=
    	      dig(digAtRelease(PCRInfo(k))) WITH [pcrValue:=s`pcrs]
    THEN a=OUT_Error(TPM_WRONGPCRVAL)
    ELSE a=OUT_Error(TPM_SUCCESS)  
    ENDIF
    AND s=state;

  get_pub_key_post2: THEOREM
   FORALL (state:(afterStartup?),k:(tpmKey?),a:authIn) :
    LET (a,s) = runState(
       	       TPM_GetPubKey(k,a))
	       (state) IN
    not getPubKey?(state,k) =>
    not (a=OUT_Error(TPM_SUCCESS))


  TPM_CreateMigrationBlob(pk:(tpmKey?),m:migrateScheme,mka:(tpmMigKeyAuth?),
	d:(tpmKey?),a1,a2:authIn) : State = 
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateMigrationBlob(pk,m,mka,d,a1,a2)));

  create_mig_blob_post: THEOREM 
   FORALL (state:(afterStartup?),pk:(tpmKey?),m:migrateScheme,
		mka:(tpmMigKeyAuth?),d:(tpmKey?),a1,a2:authIn) : 
    LET(a,s) = runState(
    	       TPM_CreateMigrationBlob(pk,m,mka,d,a1,a2))
	       (state) IN
    IF createMigBlob?(state,pk,m,mka,d)
    THEN LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=usageAuth(encDat(pk))#),
    	     a2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=usageAuth(encDat(key(mka)))#),
    	     d1:(tpmKey?)=decrypt(key(pk),d) IN
	 CASES m OF
	 migrate : a=OUT_CreateMigrationBlob(RAND,
				tpmXOR(OAEP(tpmMigrateAsymkey(usageAuth(encDat(d1)),
						pubDataDigest(encDat(d1)),
						privKey(encDat(d1))),
					    migrationAuth(encDat(d1)),privKey(encDat(d1))),
				       RAND,encrypted(key(key(mka)))),
				a1,a2,TPM_SUCCESS),
	 rewrap  : a=OUT_CreateMigrationBlob(0,rewrap(d,key(key(mka))),
		     		a1,a2,TPM_SUCCESS)
	 ELSE a=OUT_Error(TPM_BAD_PARAMETER)
	 ENDCASES	
    ELSIF not storage?(keyUsage(pk))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not checkMigKeyAuth?(s,mka)
    THEN a=OUT_Error(TPM_AUTHFAIL)
    ELSE a=OUT_Error(TPM_BAD_PARAMETER)
    ENDIF
    AND s=state;


  TPM_ConvertMigrationBlob(p:(tpmKey?),inData:(tpmMigrateAsymkey?),r:int,
	a:authIn) : State =
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_ConvertMigrationBlob(p,inData,r,a)));

  convert_mig_blob_post: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmMigrateAsymkey?),
		r:int,a:authIn) :
    LET (a,s) = runState(
    	      	TPM_ConvertMigrationBlob(p,d,r,a))
		(state) IN
    IF storage?(keyUsage(p))
    THEN LET d1=decrypt(key(p),d),
    	     pHash=tpmSecret(1),
	     k1=partPrivKey(d) IN
	 LET d2=tpmStoreAsymkey(usageAuth(d),pHash,pubDataDigest(d),k1,
			encrypted(key(p))),
	     a1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(p))#) IN
	 a=OUT_ConvertMigrationBlob(d2,a1,TPM_SUCCESS)
    ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF 
    AND s=state;
  

  TPM_AuthorizeMigrationKey(migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : State=
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_AuthorizeMigrationKey(migKey,migScheme,a)));

  authorize_migration_key_post: THEOREM 
   FORALL (state:(afterStartup?),k:(tpmKey?),scheme:(tpmMigScheme?),ai:authIn):
    LET(a,s) = runState(
    	       TPM_AuthorizeMigrationKey(k,scheme,ai))
	       (state) IN
      a=OUT_AuthorizeMigrationKey(
		tpmMigKeyAuth(k,scheme,
			SHA1(concat(k,concat(scheme,s`permData`tpmProof))),
			clear),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(ai)#),
		TPM_SUCCESS)
      AND s=state


  TPM_MigrateKey(migKey,pubKey:(tpmKey?),data:tpmData,a:authIn) : State =
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_MigrateKey(migKey,pubKey,data,a)));

  migrate_key_post: THEOREM 
   FORALL (state:(afterStartup?),mk,k:(tpmKey?),d:tpmData,ai:authIn) : 
    LET(a,s) = runState(
    	       TPM_MigrateKey(mk,k,d,ai))
	       (state) IN
    IF migrate?(keyUsage(mk))
    THEN a = OUT_MigrateKey(encrypt(key(k),decrypt(key(mk),d)),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(mk))#),
		TPM_SUCCESS)
    ELSE a = OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF
    AND s=state;

  TPM_CMK_SetRestrictions(r:(tpmCMKDelegate?),i:authIn) : State = 
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_CMK_SetRestrictions(r,i))),
	   (LAMBDA (s:tpmAbsState):outputCom(s,ABS_CMK_SetRestrictions(r,i))));

  cmk_set_restr_post: THEOREM
   FORALL (state:(afterStartup?),r:(tpmCMKDelegate?),i:authIn) : 
    LET(a,s) = runState(
    	       TPM_CMK_SetRestrictions(r,i))
	       (state) IN
   IF CMKSetRestr?(state,r,i)
   THEN LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i)#) IN
        a=OUT_CMK_SetRestrictions(a,TPM_SUCCESS) AND
   	s=state WITH [`permData(restrictDelegate):=r]
   ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE) AND
   	s=state
   ENDIF;

  TPM_CMK_ApproveMA(m:(tpmDigest?),i:authIn) : State = 
    output(LAMBDA (s:tpmAbsState):outputCom(s,ABS_CMK_ApproveMA(m,i)));

  cmk_approve_ma_post: THEOREM
   FORALL (state:(afterStartup?),migAuth:(tpmDigest?),i:authIn) : 
    LET(a,s) = runState(
    	         TPM_CMK_ApproveMA(migAuth,i))
	       (state) IN
    a=OUT_CMK_ApproveMA(
	tpmHMAC(tpmCMKMAApproval(migAuth),state`permData`tpmProof),
	(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(i)#),
	TPM_SUCCESS) AND
    s=state;
  
  TPM_CMK_CreateKey(p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),a:(tpmDigest?),
	m:(tpmDigest?),i:authIn) : State = 
    output(LAMBDA (s:tpmAbsState):outputCom(s,ABS_CMK_CreateKey(p,d,k,a,m,i)));

  cmk_create_key_post: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
   	  b:(tpmDigest?),m:(tpmDigest?),i:authIn) : 
    LET(a,s) = runState(
    	       TPM_CMK_CreateKey(p,d,k,b,m,i))
	       (state) IN
    IF CMKCreateKey?(state,p,k,m,b) 
    THEN LET DU1=decryptADIP(d,authHandle(i)),				% 14
    	     ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 15
			resAuth:=usageAuth(encDat(p))#),
	     pcr=tpmPCRInfoLong(s`stanyFlags`localityModifier,		% 18d
				locAtRelease(PCRInfo(k)), 
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				tpmCompositeHash((#
					select:=creationPCRSelect(PCRInfo(k)),
					pcrValue:=s`pcrs#)),		% 18c
				digAtRelease(PCRInfo(k))),
	     M2=tpmCMKMigAuth(m,					% 17di
             		      SHA1(tpmPubkey(algoParms(k),key(k)))) IN	% 17dii
	 LET enc=tpmStoreAsymkey(DU1,					% 17a
%	     			 tpmHMAC(M2,s`permData`tpmProof),	% 17e
 				 tpmSecret(1),
% 				 %TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				 pubDataDigest(encDat(k)),
				 privKey(encDat(k)),
				 encrypted(key(p))) IN		% 19
    	 LET wrappedKey=tpmKey(key(k),					% 13,17
	     		       keyUsage(k),
			       keyFlags(k),
			       authDataUsage(k),
			       algoParms(k),
			       pcr,					% 18
			       enc) IN
	 a=OUT_CMK_CreateKey(wrappedKey,ao,TPM_SUCCESS)
    ELSIF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND
    	  migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k)))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not(validateMigrateAuthority?(s,m,b))
    THEN a=OUT_Error(TPM_MA_AUTHORITY)
    ELSIF not(validateKeyParams?(k))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)			
    ELSIF not(checkFIPS?(s,k))
    THEN a=OUT_Error(TPM_NOTFIPS)
    ELSIF not(checkKey?(k))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY)
    ELSE a=OUT_Error(TPM_SUCCESS)
    ENDIF
    AND s=state;

  cmk_create_key_post2: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
   	  b:(tpmDigest?),m:(tpmDigest?),i:authIn) : 
    LET(a,s) = runState(
    	       TPM_CMK_CreateKey(p,d,k,b,m,i))
	       (state) IN
    not CMKCreateKey?(state,p,k,m,b) =>
    not (a=OUT_Error(TPM_SUCCESS))

  TPM_CMK_CreateTicket(v:(tpmPubkey?),d:(tpmDigest?),l:tpmData,i:authIn):State=
    output(LAMBDA (s:tpmAbsState):outputCom(s,ABS_CMK_CreateTicket(v,d,l,i)));

  cmk_create_ticket_post: THEOREM
   FORALL (state:(afterStartup?),v:(tpmPubkey?),d:(tpmDigest?),l:tpmData,
   	  i:authIn) : 
    LET(a,s) = runState(
    	       TPM_CMK_CreateTicket(v,d,l,i))
	       (state) IN
    IF CMKCreateTicket?(v,d)	
    THEN a=OUT_CMK_CreateTicket(tpmHMAC(tpmCMKSigTicket(SHA1(v),d)
				       ,state`permData`tpmProof),
			        (#nonceEven:=EVEN,nonceOdd:=ODD,
			          contAuthSess:=TRUE,resAuth:=ownerAuth(i)#),
			        TPM_SUCCESS)
    ELSIF not(validateKeyAlgo?(v))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY)	
    ELSIF not(checkSig(pubKey(v),d))
    THEN a=OUT_Error(TPM_BAD_SIGNATURE)
    ELSE a=OUT_Error(TPM_SUCCESS)
    ENDIF
    AND s=state;

  cmk_create_ticket_post2: THEOREM
   FORALL (state:(afterStartup?),v:(tpmPubkey?),d:(tpmDigest?),l:tpmData,
   	  i:authIn) : 
    LET(a,s) = runState(
    	       TPM_CMK_CreateTicket(v,d,l,i))
	       (state) IN
    not CMKCreateTicket?(v,d) =>
    not (a=OUT_Error(TPM_SUCCESS));

  TPM_CMK_CreateBlob(p:(tpmKey?),t:(tpmMigScheme?),m:(tpmMigKeyAuth?),
	k:(tpmDigest?),l:(tpmMSAComposite?),r:(tpmCMKAuth?),d:(tpmDigest?),
	e:(tpmStoreAsymkey?),i:authIn):State=
    output(LAMBDA (s:tpmAbsState):outputCom(s,
			ABS_CMK_CreateBlob(p,t,m,k,l,r,d,e,i)));

  cmk_create_blob_post: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),t:(tpmMigScheme?),
   	  m:(tpmMigKeyAuth?),k:(tpmDigest?),l:(tpmMSAComposite?),
	  r:(tpmCMKAuth?),d:(tpmDigest?),e:(tpmStoreAsymkey?),i:authIn) : 
    LET(a,s) = runState(
    	       TPM_CMK_CreateBlob(p,t,m,k,l,r,d,e,i))
	       (state) IN
    IF CMKCreateBlob?(state,p,t,m,k,l,e,i) 
    THEN LET d1:(tpmStoreAsymkey?)=decrypt(key(p),e) IN
    	 LET K1=privKey(d1),
    	     K2=privKey(d1) IN 
    	 LET M1=tpmMigrateAsymkey(usageAuth(d1),pubDataDigest(d1),K2) IN
    	 LET o1=OAEP(M1,SHA1(concat(SHA1(l),k)),K1),
    	     r1=RAND,
    	     ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(p))#) IN    
    	 a=OUT_CMK_CreateBlob(r1,tpmXOR(o1,r1,encrypted(key(key(m))))
		              ,ao,TPM_SUCCESS)
    ELSIF t/=scheme(m)
    THEN a=OUT_Error(TPM_BAD_MODE)
    ELSIF migratable(keyFlags(p))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY)
    ELSIF migrationAuth(decrypt(key(p),e))/=
		tpmHMAC(tpmCMKMigAuth(SHA1(l),k),state`permData`tpmProof)
    THEN a=OUT_Error(TPM_MA_AUTHORITY)
    ELSIF restrictMigrate?(migScheme(scheme(m))) AND 
    	  not(RSA?(algoId(algoParms(key(m)))))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY)
    ELSIF not(restrictMigrate?(migScheme(scheme(m))) OR 
    	      restrictApprove?(migScheme(scheme(m))))
    THEN a=OUT_Error(TPM_BAD_PARAMETER)
    ELSE a=OUT_Error(TPM_SUCCESS)
    ENDIF
    AND s=state;

  cmk_create_blob_post2: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),t:(tpmMigScheme?),
   	  m:(tpmMigKeyAuth?),k:(tpmDigest?),l:(tpmMSAComposite?),
	  r:(tpmCMKAuth?),d:(tpmDigest?),e:(tpmStoreAsymkey?),i:authIn) : 
    LET(a,s) = runState(
    	       TPM_CMK_CreateBlob(p,t,m,k,l,r,d,e,i))
	       (state) IN
    not CMKCreateBlob?(state,p,t,m,k,l,e,i) =>
    not a=OUT_Error(TPM_SUCCESS);

  TPM_CMK_ConvertMigration(p:(tpmKey?),r:(tpmCMKAuth?),t:(tpmDigest?),
	m:(tpmKey?),l:(tpmMSAComposite?),n:int,i:authIn) : State =
    output(LAMBDA (s:tpmAbsState):outputCom(s,
			ABS_CMK_ConvertMigration(p,r,t,m,l,n,i)));
 
  cmk_convert_migration_post : THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),r:(tpmCMKAuth?),t:(tpmDigest?),
   	   m:(tpmKey?),l:(tpmMSAComposite?),n:int,i:authIn) :
    LET (a,s) = runState(
    	      	TPM_CMK_ConvertMigration(p,r,t,m,l,n,i))
		(state) IN
    LET d1=decrypt(key(p),encDat(m)) IN
    LET o1=tpmXOR(d1,n,clear) IN
    LET m1=OAEPdecode(o1),
	migratedPubKey=tpmPubkey(algoParms(m),key(m)) IN
    LET k1=partPrivKey(m(m1)),
        M2=tpmCMKMigAuth(SHA1(l),SHA1(migratedPubKey)) IN
    LET d2=tpmStoreAsymkey(usageAuth(m(m1)),
		tpmSecret(1),
		% tpmHMAC(M2,state`permData`tpmProof),
		pubDataDigest(m(m1)),k1,
		encrypted(key(p))) IN
    LET parentPubKey=tpmPubkey(algoParms(p),key(p)) IN
    IF CMKConvertMigration?(state,p,r,m,l,n) 
    THEN LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,
		contAuthSess:=TRUE,resAuth:=usageAuth(encDat(p))#) IN
    	 a=OUT_CMK_ConvertMigration(d2,ao,TPM_SUCCESS)
    ELSIF not(storage?(keyUsage(p)))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF pHash(m1)/=SHA1(concat(SHA1(l),SHA1(migratedPubKey)))	
    THEN a=OUT_Error(TPM_SHA_ERROR)
    ELSIF migratable(keyFlags(p))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY)
    ELSIF destKey(r)/=SHA1(parentPubKey)
    THEN a=OUT_Error(TPM_MA_DESTINATION)
    ELSIF not(privKey(encDat(m))=privKey(d2) AND
    	      pubDataDigest(encDat(m))=pubDataDigest(d2) AND
	      usageAuth(encDat(m))=usageAuth(d2))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY)
    ELSIF not(migratable(keyFlags(m))) OR
    	  not(migrateAuthority(keyFlags(m)))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF sourceKey(r)/=SHA1(migratedPubKey)
    THEN a=OUT_Error(TPM_MA_SOURCE)
    ELSE a=OUT_Error(TPM_SUCCESS)
    ENDIF
    AND s=state;

%%TODO: for some reason, this proof takes forever. FIX
%   cmk_convert_migration_post2 : THEOREM
%    FORALL (state:(afterStartup?),p:(tpmKey?),r:(tpmCMKAuth?),t:(tpmDigest?),
%    	   m:(tpmKey?),l:(tpmMSAComposite?),n:int,i:authIn) :
%     LET (a,s) = runState(
%     	      	TPM_CMK_ConvertMigration(p,r,t,m,l,n,i))
% 		(state) IN
%     not (CMKConvertMigration?(state,p,r,m,l,n)) =>
%     not (a=OUT_Error(TPM_SUCCESS));

  
  %% Generate and output a signature
  TPM_Sign(k:(tpmKey?),areaToSign:tpmData) : State = 
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Sign(k,areaToSign)));
	   
  sign_post: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),b:tpmData) :
      LET(a,s) = runState(
     		  TPM_Sign(k,b))
		  (state) IN
	IF legacy?(keyUsage(k)) or signing?(keyUsage(k))
	THEN a = OUT_Sign(sign(key(k),b),TPM_SUCCESS)
	ELSE a = OUT_Error(TPM_INVALID_KEYUSAGE)
	ENDIF
	AND s = state;

  sign_pred_test : THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),b:tpmData) :
      LET(a,s) = runState(
     		  TPM_Sign(k,b))
		  (state) IN
	IF sign?(state,k,b)
	THEN a = OUT_Sign(sign(key(k),b),TPM_SUCCESS)
	ELSE a = OUT_Error(TPM_INVALID_KEYUSAGE)
	ENDIF
	AND s = state;


  TPM_CreateEndorsementKeyPair(n:(tpmNonce?),k:(tpmKey?)) : State =
     %% TODO: Perm Data stuff with RNG
     modifyOutput(
	(LAMBDA(s:tpmAbsState):executeCom(s,ABS_CreateEndorsementKeyPair(n,k))),
        (LAMBDA(s:tpmAbsState):outputCom(s,ABS_CreateEndorsementKeyPair(n,k))));

  create_endorsement_key_pair_post: THEOREM
   FORALL (state:(afterStartup?),k:(tpmKey?),n:(tpmNonce?)) : 
    LET (a,s) = runState(
      	  	TPM_CreateEndorsementKeyPair(n,k))
		(state) IN
    IF key(ek(state))=badkey 
    THEN a=OUT_CreateEndorsementKeyPair(k,
		SHA1(concat(k,n)),TPM_SUCCESS) AND
	 s=state WITH [`ek := privateKey(k),
      	     	       `permFlags(CEKPUsed) := TRUE,
		       `permFlags(enableRevokeEK) := FALSE]
    ELSE a=OUT_Error(TPM_DISABLED_CMD) AND 
	 s=state
    ENDIF;


  TPM_CreateRevocableEK(a:(tpmNonce?),k:(tpmKey?),g:bool,i:(tpmNonce?)) :State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_CreateRevocableEK(a,k,g,i))),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_CreateRevocableEK(a,k,g,i))));

  create_revocable_ek_post: THEOREM
   FORALL (state:(afterStartup?),a,i:(tpmNonce?),k:(tpmKey?),g:bool) : 
    LET (a,s) = runState(
      	  	  TPM_CreateRevocableEK(a,k,g,i))
		  (state) IN
    IF key(ek(state)) = badkey
    THEN a=OUT_CreateRevocableEK(tpmPubkey(algoParms(k),key(k)),
				SHA1(concat(k,a)),
				s`permData`ekReset,
				TPM_SUCCESS) AND
	 s=state WITH [`ek := privateKey(k),
      	     	       	 `permFlags(CEKPUsed) := TRUE,
		   	 `permFlags(enableRevokeEK) := TRUE,	
			 `permData(ekReset):=IF g THEN tpmNonce(RAND) 
						ELSE i ENDIF ]
    ELSE a=OUT_Error(TPM_DISABLED_CMD) AND 
	 s=state
    ENDIF;


  TPM_RevokeTrust(r:(tpmNonce?)) : State = 
    modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_RevokeTrust(r))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_RevokeTrust(r)))
	    );
	    
  revoke_trust_post : THEOREM
   FORALL (state:(afterStartup?),EKReset:(tpmNonce?)) : 
    LET (a,s) = runState(
      	  	TPM_RevokeTrust(EKReset))
		(state) IN
    IF revokeTrust?(state,EKReset)
    THEN a=OUT_RevokeTrust(TPM_SUCCESS) AND
	 LET s1=clear(state) IN
	     s=s1 WITH [`permFlags(nvLocked):=FALSE,
	     	        `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),
				authDataUsage(s`ek),algoParms(s`ek),
			      	PCRInfo(s`ek),encDat(s`ek))]
    ELSIF not state`permFlags`enableRevokeEK
    THEN a=OUT_Error(TPM_PERMANENTEK) AND s=state
    ELSIF state`permData`ekReset/=EKReset
    THEN a=OUT_Error(TPM_AUTHFAIL) AND s=state
    ELSIF not s`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_MODE) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;

  revoke_trust_post2 : THEOREM
   FORALL (state:(afterStartup?),EKReset:(tpmNonce?)) : 
    LET (a,s) = runState(
      	  	TPM_RevokeTrust(EKReset))
		(state) IN
    not revokeTrust?(state,EKReset) =>
    not a=OUT_Error(TPM_SUCCESS)


  TPM_ReadPubek(n:(tpmNonce?)) : State =
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ReadPubek(n)));

  read_pub_ek_post: THEOREM
    FORALL (state:(afterStartup?),n:(tpmNonce?)) : 
      LET (a,s) = runState(
      	  	  TPM_ReadPubek(n))
		  (state) IN
    a=IF readPubek?(state,n)
      THEN LET pubEndoK=ek(state) IN
      	   OUT_ReadPubek(pubEndoK,
		SHA1(concat(pubEndoK,n)),
		TPM_SUCCESS)
      ELSIF not state`permFlags`readPubek
      THEN OUT_Error(TPM_DISABLED_CMD)
      ELSIF not goodkey?(key(ek(state)))
      THEN OUT_Error(TPM_NO_ENDORSEMENT)
      ELSE OUT_Error(TPM_SUCCESS)
      ENDIF
    AND s=state;

  read_pub_ek_post2: THEOREM
    FORALL (state:(afterStartup?),n:(tpmNonce?)) : 
      LET (a,s) = runState(
      	  	  TPM_ReadPubek(n))
		  (state) IN
    not readPubek?(state,n) =>
    not a=OUT_Error(TPM_SUCCESS);

  read_pub_ek_take_ownership: THEOREM
    FORALL (state:(afterStartup?),n:(tpmNonce?),srk:(tpmKey?),
  	eOA,eSA:(tpmEncAuth?),i:authIn) :  
      LET (a,s) = runState(
      	  	  TPM_TakeOwnership(eOA,eSA,srk,i)
		  >> TPM_ReadPubek(n))
		  (state) IN
    takeOwnership?(state,srk)=>
      a=OUT_Error(TPM_DISABLED_CMD);




  TPM_OwnerReadInternalPub(k:(tpmKey?),a:authIn) : State =
     output(
	LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerReadInternalPub(k,a)));

  owner_read_internal_pub_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),ai:authIn) : 
      LET (a,s) = runState(
      	  	  TPM_OwnerReadInternalPub(k,ai))
		  (state) IN
      LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(ai)#) IN
      IF key(k)=ekKeyVal OR key(k)=srkKeyVal 
      THEN a=OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,
			TPM_SUCCESS)
      ELSE a=OUT_Error(TPM_BAD_PARAMETER)
      ENDIF
      AND s=state



  %% Make a new identity and output it
  TPM_MakeIdentity(e:(tpmEncAuth?),d:(tpmDigest?),k:(tpmKey?),a1,a2:authIn) : 
  	State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,ABS_MakeIdentity(e,d,k,a1,a2))),
        (LAMBDA (s:tpmAbsState):outputCom(s,ABS_MakeIdentity(e,d,k,a1,a2))));

  make_identity_post: THEOREM 
   FORALL (state:(afterStartup?),e:(tpmEncAuth?),d:(tpmDigest?),k:(tpmKey?),
		i1,i2:authIn) :
    LET (a,s) = runState(
     	 	TPM_MakeIdentity(e,d,k,i1,i2))
		(state) IN
    IF makeIdentity?(state,k)
    THEN LET A1=decryptADIP(e,authHandle(i2)),
    	     o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=usageAuth(encDat(state`srk))#),
	     o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=ownerAuth(i2)#) IN
      	 LET pcr=tpmPCRInfoLong(makeIdentityLocality,
			locAtRelease(PCRInfo(k)),
			creationPCRSelect(PCRInfo(k)),
			releasePCRSelect(PCRInfo(k)),
			tpmCompositeHash((#select:=creationPCRSelect(PCRInfo(k))
					,pcrValue:=pcrs(state)#)),
			digAtRelease(PCRInfo(k))),
	     encData=tpmStoreAsymkey(A1,
			s`permData`tpmProof,
			pubDataDigest(encDat(k)),
			privKey(encDat(k)),
			encrypted(key(state`srk))) IN
         LET waik=tpmKey(keyGenCnt(state),
			keyUsage(k),
			keyFlags(k),
			authDataUsage(k),
			algoParms(k),
			pcr,
			encData) IN
	 LET idBind=tpmIdContents(d,waik,signed(private(waik))) IN
	 a=OUT_MakeIdentity(waik,idBind,o1,o2,TPM_SUCCESS) AND
	 s=state WITH [`keyGenCnt := keyGenCnt(state)+1]
    ELSIF state`permFlags`FIPS AND never?(authDataUsage(k))
    THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSIF not identity?(keyUsage(k))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(k))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;
      
  make_identity_post2 : THEOREM
   FORALL (state:(afterStartup?),e:(tpmEncAuth?),d:(tpmDigest?),k:(tpmKey?),
		i1,i2:authIn) :
    LET (a,s) = runState(
     	 	TPM_MakeIdentity(e,d,k,i1,i2))
		(state) IN
    not makeIdentity?(state,k) =>
     not a=OUT_Error(TPM_SUCCESS)

  make_cert : THEOREM
   FORALL (state:(afterStartup?)
   	  ,e:(tpmEncAuth?)
	  ,d:(tpmDigest?)
	  ,idk:(tpmKey?)
	  ,id:(tpmIdContents?)
	  ,i1,i2,i3,i4:authIn
	  ,x:nat) :
    LET (a,s) = runState(
 		TPM_MakeIdentity(e,d,idk,i1,i2)
		>>= CPU_saveOutput(x)
		>>= (LAMBDA (a:tpmAbsOutput) :
		    CASES a OF
		    	  OUT_MakeIdentity(k,i,o1,o2,m) : CA_certify(k,i)
			  ELSE TPM_Noop(a)
		    ENDCASES))
		(state) IN
    makeIdentity?(state,idk) AND 
     OUT_MakeIdentity?(s`memory(x)) AND 
     certify?(idKey(s`memory(x)),idBinding(s`memory(x))) 
    =>
     a=OUT_Certify(idKey(s`memory(x)),
		tpmAsymCAContents(tpmSessKey(keyGenCnt(state)+1,clear),
			digest(idBinding(s`memory(x))),
			encrypted(key(ekVal))),CPU_SUCCESS) 
     AND s=state WITH [`keyGenCnt:=state`keyGenCnt+2
       	       	      ,`memory:=s`memory]

  %% Use an AIK
  TPM_ActivateIdentity(a:(tpmKey?),b:(activateIdentityBlob?),
	a1,a2:authIn) : State =
     modifyOutput(
        (LAMBDA (s:tpmAbsState): executeCom(s,ABS_ActivateIdentity(a,b,a1,a2))),
        (LAMBDA (s:tpmAbsState): outputCom(s,ABS_ActivateIdentity(a,b,a1,a2))));

  %% Assure that activate idenity installs its AIK and returns K if AIK can
  %% be installed.
  activate_identity_post: THEOREM 
   FORALL (state:(afterStartup?),aik:(tpmKey?),blob:(activateIdentityBlob?),
		i1,i2:authIn) :
    LET (a,s) = runState(
                TPM_ActivateIdentity(aik,blob,i1,i2))
		(state) IN     
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(aik))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#) IN
    IF activateIdentity?(state,aik,blob)
    THEN a=CASES blob OF
    	   tpmAsymCAContents(k,d,c) : OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS),
    	   tpmEKBlob(b,c) : OUT_ActivateIdentity(sessK(b),o1,o2,TPM_SUCCESS)
    	   ENDCASES
    ELSIF not identity?(keyUsage(aik))
    THEN a=OUT_Error(TPM_BAD_PARAMETER)
    ELSE LET h1=tpmDigest(cons(tpmPubkey(algoParms(aik),key(aik)),null)),
    	     b1=decrypt(private(ekVal),blob) IN
	 CASES b1 OF
	 tpmAsymCAContents(k,d,crs) : a=OUT_CPUError(CPU_DECRYPT_ERROR),
	 tpmEKBlob(b,crs) : 
	 	CASES b OF
	 	tpmEKBlobActivate(k,d,p) : 
		  LET C1=tpmCompositeHash((#select:=pcrSelect(p),
				pcrValue:=pcrs(state)#)) IN
		  IF h1/=d 
		  THEN a=OUT_Error(TPM_BAD_PARAMETER)
		  ELSIF not null?(pcrSelect(p)) AND C1/=digAtRelease(p)
		  THEN a=OUT_Error(TPM_WRONGPCRVAL) 
		  ELSE a=OUT_Error(TPM_BAD_LOCALITY)
		  ENDIF
		ELSE a=OUT_Error(TPM_BAD_TYPE)
		ENDCASES
	ELSE a=OUT_Error(TPM_BAD_PARAMETER)
	ENDCASES
    ENDIF
    AND s=state

  activate_identity_post2 : THEOREM
   FORALL (state:(afterStartup?),aik:(tpmKey?),blob:(activateIdentityBlob?),
		i1,i2:authIn) :
    LET (a,s) = runState(
     	 	TPM_ActivateIdentity(aik,blob,i1,i2))
		(state) IN
    not activateIdentity?(state,aik,blob) =>
     not a=OUT_Error(TPM_SUCCESS)

  cert_activate : THEOREM
    FORALL(state:(afterStartup?),aik:(tpmKey?),c:(tpmIdContents?),i1,i2:authIn,
		x:nat):
      LET (a,s) = runState(
      	  	  CA_certify(aik,c)
		  >>= CPU_saveOutput(x)
		  >>= (LAMBDA (a:tpmAbsOutput) :
		       CASES a OF
		       OUT_Certify(k,d,m) : TPM_ActivateIdentity(k,d,i1,i2)
		       ELSE TPM_Noop(a)	
		       ENDCASES))
		  (state) IN
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(aik))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#) IN
    certify?(aik,c) AND
     OUT_Certify?(s`memory(x)) AND
     activateIdentity?(s,k(s`memory(x)),dat(s`memory(x)))
    =>
    a=OUT_ActivateIdentity(sessK(dat(s`memory(x))),o1,o2,TPM_SUCCESS) AND
     s=state WITH [`keyGenCnt:=1+keyGenCnt(state)
              	  ,`memory:=updateLoc(state`memory,x,
                             OUT_Certify(aik,tpmAsymCAContents
                                          (tpmSessKey(keyGenCnt(state),clear),
                                           digest(c),
                                           encrypted(key(ekVal))),
                                         CPU_SUCCESS))]

  make_cert_activate_identity: THEOREM 
   FORALL (state:(afterStartup?)
   	  ,e:(tpmEncAuth?)
	  ,d:(tpmDigest?)
	  ,k:(tpmKey?)
	  ,i1,i2,i3,i4:authIn
	  ,x,y:nat) :
    LET (a,s) = runState(
 		TPM_MakeIdentity(e,d,k,i1,i2)
		>>= CPU_saveOutput(x)
		>>= (LAMBDA (a:tpmAbsOutput) :
		    CASES a OF
		    	  OUT_MakeIdentity(k,i,o1,o2,m) : CA_certify(k,i)
			  ELSE TPM_Noop(a)
		    ENDCASES)
		>>= CPU_saveOutput(y)
		>>= (LAMBDA (a:tpmAbsOutput) : 
		    CASES a OF
		    	  OUT_Certify(j,d,m) : TPM_ActivateIdentity(j,d,i3,i4)
			  ELSE TPM_Noop(a)
		    ENDCASES))
		(state) IN
    makeIdentity?(state,k) AND 
    	OUT_MakeIdentity?(s`memory(x)) AND
    certify?(idKey(s`memory(x)),idBinding(s`memory(x))) AND
    	OUT_Certify?(s`memory(y)) AND
	wellFormedRestore?(s`restore) AND
    activateIdentity?(tpmRestore(s`restore),idKey(s`memory(x)),
	dat(s`memory(y))) 
    => 
    LET o3=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(idKey(s`memory(x))))#),
	o4=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i4)#) IN
    a=OUT_ActivateIdentity(sessK(dat(s`memory(y))),o3,o4,TPM_SUCCESS) AND
    s=state WITH [`memory:=s`memory
    	    	 ,`keyGenCnt:=state`keyGenCnt+2]


  %% Extend PCR n with hash value h.
  TPM_Extend(n:PCRINDEX,h:HV):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Extend(n,h))),
           (LAMBDA (s:tpmAbsState):outputCom(s,ABS_Extend(n,h))));
  
  extend_post : THEOREM
   FORALL (state:(afterStartup?),h:HV,n:PCRINDEX) : 
    LET (a,s) = runState(
      	  	TPM_Extend(n,h))
		(state) IN
    LET L1=s`stanyFlags`localityModifier,
    	P1=pcrExtendLocal(state`permData`pcrAttrib(n)),
	H1=pcrsExtend(state`pcrs,n,h) IN
    IF extend?(state,n,h)
    THEN IF state`permFlags`disable OR state`stclearFlags`deactivated
    	 THEN a=OUT_Extend(reset,TPM_SUCCESS) AND 
    	      s=state WITH [`pcrs:=H1]
    	 ELSE a=OUT_Extend(extend(state`pcrs(n),h),TPM_SUCCESS) AND 
    	      s=state WITH [`pcrs:=H1]
	 ENDIF
    ELSIF n>23 OR n<0
    THEN a=OUT_Error(TPM_BADINDEX) AND
    	 s=state
    ELSIF not member(L1,P1)
    THEN a=OUT_Error(TPM_BAD_LOCALITY) AND
    	 s=state 
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;


  extend_post2 : THEOREM
   FORALL (state:(afterStartup?),h:HV,n:PCRINDEX) : 
    LET (a,s) = runState(
      	  	TPM_Extend(n,h))
		(state) IN
    LET L1=s`stanyFlags`localityModifier,
    	P1=pcrExtendLocal(state`permData`pcrAttrib(n)),
	H1=pcrsExtend(state`pcrs,n,h) IN
    not extend?(state,n,h) =>
    not a=OUT_Error(TPM_SUCCESS)
  

  %% Extend is antisymmetric if the hash values used for extension are
  %% not equal.  In this example we use the LET form to define
  %% commands directly with monad functions defined in StateMonad.pvs
  antisymmetryMonad: THEOREM 
   FORALL (state:(afterStartup?),hv0,hv1:HV,n:PCRINDEX) :
    LET f1:State =
        modify(OUT_Nothing,
               (LAMBDA (s:tpmAbsState):
		 s WITH [`pcrs:=pcrsExtend(pcrs(s),n,hv0)])),
      	f2:State =
        modify(OUT_Nothing,
               (LAMBDA (s:tpmAbsState):
		 s WITH [`pcrs:=pcrsExtend(pcrs(s),n,hv1)])) IN
    hv0/=hv1 =>
      runState(
        f2 >>= (LAMBDA (x:tpmAbsOutput): f1))(tpmStartup)
      /=
      runState(
        f1 >>= (LAMBDA (x:tpmAbsOutput): f2))(tpmStartup);

  %% Extending a reset PCR is antisymmetric if the two values are not equal
  %% Let form used to defined commands for bind.  Will use command forms
  %% later in antisymmetryMonad3
  antisymmetryMonad2: THEOREM 
   FORALL (state:(afterStartup?),hv0,hv1:HV,n:PCRINDEX) :
    LET f1:State=TPM_Extend(n,hv0),
      	f2:State=TPM_Extend(n,hv1) IN
    extend?(state,n,hv0) AND extend?(state,n,hv1) AND
    not(state`stclearFlags`deactivated OR state`permFlags`disable) AND
    %IF flags are set, the result will be same (OUT_Extend(reset,TPM_SUCCESS))
    hv0/=hv1 =>
      runState(f2 >> f1)(state)
      /=
      runState(f1 >> f2)(state)

  %% Extending a reset PCR is antisymmetric if the two values are not equal.
  %% No let form - commands appear directly in bind
  %% Theorem is now false when PCRs other than PCR0 are included.
  antisymmetryMonad3: THEOREM 
   FORALL (state:(afterStartup?),hv0,hv1:HV,n:PCRINDEX) :
    extend?(state,n,hv0) AND extend?(state,n,hv1) AND
    not(state`stclearFlags`deactivated OR state`permFlags`disable) AND
    %IF flags are set, the result will be same (OUT_Extend(reset,TPM_SUCCESS))
    hv0/=hv1 =>
       runState(TPM_Extend(n,hv1)
	     >> TPM_Extend(n,hv0))
	     (state)
     /=
       runState(TPM_Extend(n,hv0)
	     >> TPM_Extend(n,hv1))
	     (state)


  %% Output PCR(i)
  TPM_PcrRead(i:PCRINDEX) : State = 
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PCRRead(i)));

  pcr_read_post: THEOREM
    FORALL (state:(afterStartup?),i:PCRINDEX) : 
      LET(a,s) = runState(
     		  TPM_PcrRead(i))
		  (state) IN
    IF i > 23 OR i < 0
    THEN a=OUT_Error(TPM_BADINDEX)
    ELSE a=OUT_PCRRead(state`pcrs(i),TPM_SUCCESS)
    ENDIF
    AND s=state;


  %% Generate and output a quote
  TPM_Quote(k:(tpmKey?),n:(tpmNonce?),pm:PCR_SELECTION,i:authIn) : State = 
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Quote(k,n,pm,i)));

  %% If nonces don't match, quotes don't match.  We don't care about this
  %% if the a quote cannot be produced.
  %% proved - Fri Jun 22 16:55:16 CDT 2012
  bad_nonce: THEOREM
    FORALL (s:(afterStartup?),k:(tpmKey?),n1,n2:(tpmNonce?),pm:PCR_SELECTION,
		i:authIn) :
      n1/=n2 AND quote?(k)
      =>
       runState(
         TPM_Quote(k,n1,pm,i))
	 (s)
       /=
       runState(
	 TPM_Quote(k,n2,pm,i))
	 (s);


  %% Bad Signing Key - Man in the Middle Attack - we don't care about this
  %% if either key won't produce a quote.
  %% proved - Fri Jun 22 16:55:56 CDT 2012
  bad_signing_key: THEOREM
    FORALL (s:(afterStartup?),n:(tpmNonce?),pm:PCR_SELECTION,k0,k1:(tpmKey?),
		i:authIn) :
          private(k0) /= private(k1)  AND
	  quote?(k0) AND quote?(k1)
          =>
      runState(TPM_Quote(k0,n,pm,i))(s)
      /= runState(TPM_Quote(k1,n,pm,i))(s);

  %% Bad PCRs - If different pcrs selected, different quote is output
  bad_pcrs: THEOREM
    FORALL (s:(afterStartup?),n:(tpmNonce?),p0,p1:PCR_SELECTION,k:(tpmKey?),
		i:authIn) :
      quote?(k) AND p0/=p1
      =>
      runState(TPM_Quote(k,n,p0,i))(s)
      /=
      runState(TPM_Quote(k,n,p1,i))(s) 

     
  %% Output after going through tpm commands is same as grabbing pcrs
  %% proved - Fri Jun 22 16:56:08 CDT 2012
  %% TODO: problem: quote isn't getting correct pcrs input since that's saved in intermediate state. somehow update this or add as param to TPM_Extend?
  check_PCRS: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),hv:HV,pm:PCR_SELECTION,
		n:(tpmNonce?),ind:PCRINDEX,i:authIn,x:nat) :
      LET (a,s)=runState(
        	TPM_Extend(ind,hv) 
		%>>= CPU_saveOutput(x)
		>> TPM_Quote(k,n,pm,i))
		(state) IN
    extend?(state,ind,hv) AND quote?(k) =>
    a=OUT_Quote(map(s`pcrs,pm),
		tpmQuote(tpmCompositeHash((#select:=pm,pcrValue:=s`pcrs#)),
			   %pcrValue:=pcrsExtend(state`pcrs,ind,hv)#)),
			 n,
			 signed(private(k))),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#),
		TPM_SUCCESS) AND 
    s=state WITH [`pcrs:=pcrsExtend(state`pcrs,ind,hv)
    	    	 ,`memory:=s`memory]

  %% Prove that quote generation returns the correct PCR.  This theorem
  %% needs to be updated with something cleaner.
  %% proven - Wed Jul 11 10:40:28 EDT 2012
  quote_post: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),n:(tpmNonce?),p:PCR_SELECTION,
		i:authIn) :
        LET (a,s) = runState(
      	    	    TPM_Quote(k,n,p,i))
		    (state) IN 
	IF not quote?(k)
	THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
	ELSE LET H1=tpmCompositeHash((#select:=p,pcrValue:=s`pcrs#)),
	     	 pcrData=getPCRs(s`pcrs,p) IN
        a=OUT_Quote(pcrData,
		    tpmQuote(H1,n,signed(private(k))),
		    (#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#),
		    TPM_SUCCESS)
	ENDIF
	AND s=state;

  % (rewrite-msg-off)      
  quote_with_prev_key: THEOREM
   FORALL (state:(afterStartup?),pk,k:(tpmKey?),n:(tpmNonce?),pm:PCR_SELECTION,
    	   dUA,dMA:(tpmEncAuth?),i1,i2:authIn,x:nat) :
    LET (a,s) = runState(
		TPM_CreateWrapKey(pk,k,dUA,dMA,i1)
		>>=CPU_saveOutput(x)
		>>= (LAMBDA (a:tpmAbsOutput) : 
		     CASES a OF 
		       OUT_CreateWrapKey(wk,a,m) : TPM_Quote(wk,n,pm,i2) 
		       ELSE TPM_Noop(a) 
		     ENDCASES))
		(state) IN
    OUT_CreateWrapKey?(s`memory(x)) => 
      LET key=wrappedKey(s`memory(x)) IN
 	createWrapKey?(pk,k) AND quote?(key) 
	 => 
        a=OUT_Quote(map(s`pcrs,pm),
	            tpmQuote(tpmCompositeHash((#select:=pm,pcrValue:=s`pcrs#)),
			     n,
			     signed(private(key))),
		    (#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(key))#),
		    TPM_SUCCESS)
	

  %% Prove that skipping SENTER is detectable by showing the quote following
  %% a command differs when SENTER is excluded.
  %% proved - Tue Jun 12 15:34:24 CDT 2012
  no_senter: THEOREM 
    FORALL (state:tpmAbsState,k:(tpmKey?),hv:HV,n:(tpmNonce?),
		pm:PCR_SELECTION,ind:PCRINDEX,i:authIn) :
      runState(
	TPM_Init
      	>> TPM_Startup(TPM_ST_CLEAR)
      	>> CPU_senter
      	>> CPU_sinit
      	>> TPM_Extend(ind,hv)
      	>> TPM_Quote(k,n,pm,i))
      	(state)
      /=
      runState(
	TPM_Init
	>> TPM_Extend(ind,hv)
	>> TPM_Quote(k,n,pm,i))
	(state)

  %% TPMs will not lie about who they are.  If the AIK cannot be installed
  %% then no quote will be generated
  %% proved - Wed Jul 11 11:28:46 EDT 2012
%   aik_binding: THEOREM
%     FORALL (aik:(tpmKey?),b:(tpmNonce?),pm:PCR_SELECTION,state:tpmAbsState) :
%       LET (a,s) = runState(
%                   TPM_Init
% 		  >> TPM_Startup(TPM_ST_CLEAR)
% 		  >> CPU_senter
% 		  >> CPU_sinit
% 		  >> TPM_Quote(aik,b,pm))
% 		  (state) IN
%        NOT checkKeyRoot(aik,srk(s)) => 
%        a=OUT_Error(TPM_INVALID_KEYUSAGE);


  TPM_PCR_Reset(pcrSelection:PCR_SELECTION):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_PCR_Reset(pcrSelection))),
           (LAMBDA (s:tpmAbsState):outputCom(s,ABS_PCR_Reset(pcrSelection))));

  pcr_reset_post : THEOREM
   FORALL(state:(afterStartup?),select:PCR_SELECTION) :
    LET (a,s) = runState(
    	      	TPM_PCR_Reset(select))
		(state) IN
    IF null?(select)							% 1b
    THEN a=OUT_Error(TPM_INVALID_PCR_INFO) AND				% 1c
    	 s=state
    ELSE LET num=validatePCRVals(state,select) IN
      	 COND
      	 num=0 -> a=OUT_PCR_Reset(TPM_SUCCESS) AND
	       	  s=state WITH [`pcrs:=pcrsResetSelection(state`pcrs,select)],
      	 num=1 -> a=OUT_Error(TPM_NOTRESETABLE) AND
	       	  s=state,
      	 num=2 -> a=OUT_Error(TPM_NOTLOCAL) AND
	       	  s=state,
	 ELSE -> a=OUT_Error(TPM_SUCCESS)
      	 ENDCOND
    ENDIF;

  % TODO: need validatePCRs theorem
  pcr_reset_post2 : THEOREM
   FORALL(state:(afterStartup?),select:PCR_SELECTION) :
    LET (a,s) = runState(
    	      	TPM_PCR_Reset(select))
		(state) IN
    not null?(select) =>
    not a=OUT_Error(TPM_SUCCESS)


  TPM_ChangeAuth(p:(tpmKey?),n:(tpmEncAuth?),d:tpmData,i1,i2:authIn) : State =
    output((LAMBDA (s:tpmAbsState):outputCom(s,ABS_ChangeAuth(p,n,d,i1,i2))));

  change_auth_post : THEOREM
   FORALL(state:(afterStartup?),p:(tpmKey?),n:(tpmEncAuth?),d:tpmData,
		i1,i2:authIn):
    LET (a,s) = runState(
    	      	TPM_ChangeAuth(p,n,d,i1,i2))
		(state) IN
    IF tpmKey?(d) OR tpmStoredData?(d)
    THEN LET decryptAuth=decryptADIP(n,authHandle(i1)) IN
	 IF not storage?(keyUsage(p))	   
	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)				% 8
	 ELSE LET b1=decrypt(key(p),d),					% 9
	      	  o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=usageAuth(encDat(p))#),
	      	  o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=ownerAuth(i2)#) IN
	      CASES b1 OF	       					% 10
	      tpmStoreAsymkey(u,m,v,k,c) : 
		a=OUT_ChangeAuth(tpmStoreAsymkey(
				changeAuthOut2(u,decryptAuth,i2),	% 10,11
				m,v,k,encrypted(key(p))),		% 12
				o1,o2,TPM_SUCCESS),
	      tpmSealedData(a,f,s,d,c) : 
		a=OUT_ChangeAuth(tpmSealedData(
				changeAuthOut2(a,decryptAuth,i2),	% 10,11
				f,s,d,encrypted(key(p))),		% 12
				o1,o2,TPM_SUCCESS)
	      ELSE a=OUT_Error(TPM_INVALID_STRUCTURE)			% 10a
	      ENDCASES
	 ENDIF
    ELSE a=OUT_Error(TPM_INVALID_STRUCTURE)			% TODO: check
    ENDIF


   %% Simple verification of the quote generation process from init
   %% through generation of the appraiser's quote.  Yay.  This is what
   %% I was after!!
   %%
   %% Memory map:  
   %% 0 -> identity
   %% 1 -> CA cert
   %% 2 -> TPM quote
   %%
   %% Note that the identity is not used in building the final
   %% appraiser's quote
   %% proved Sat Jul 14 11:19:56 CDT 2012
%    cert_and_quote_with_prev_key : THEOREM
%    FORALL (state:(afterStartup?)
%    	  ,n:(tpmNonce?)
% 	  ,pm:PCR_SELECTION
% 	  ,e:(tpmEncAuth?)
% 	  ,idKey:(tpmKey?)
% 	  ,caDig:(tpmDigest?)
% 	  ,i1,i2,i3,i4,i5:authIn) :
%     LET (a,s) = runState(
%     	      	TPM_MakeIdentity(e,caDig,idKey,i1,i2)
% 		>>= CPU_saveOutput(0)
% 		>>= (LAMBDA (a:tpmAbsOutput) : 
% 		     CASES a OF
% 		     OUT_MakeIdentity(aik,bind,o1,o2,m) : CA_certify(aik,bind)
% 		     ELSE TPM_Noop(a)
% 		     ENDCASES)
%  		>>= CPU_saveOutput(1)
% 		>>= (LAMBDA (a:tpmAbsOutput) : 
% 		     CASES a OF
% 		     OUT_Certify(j,d,m) : TPM_ActivateIdentity(j,d,i3,i4)
% 		     ELSE TPM_Noop(a)
% 		     ENDCASES)
% 		>> CPU_read(0)
% 		>>= (LAMBDA (a:tpmAbsOutput) : 
% 		     CASES a OF
% 		     OUT_MakeIdentity(aik,bind,o1,o2,m) : TPM_Quote(aik,n,pm,i5)
% 		     ELSE TPM_Noop(a)
% 		     ENDCASES)
% 		>>= CPU_saveOutput(2)
% 		>> CPU_BuildQuoteFromMem(2,0))
% 		(state) IN
% 	makeIdentity?(state,idKey)
% 	AND OUT_MakeIdentity?(s`memory(0)) 
% 	AND OUT_Quote?(s`memory(2))
% 	AND private(idKey)=key(idKey(s`memory(0)))
% 	AND caDig=idBinding(s`memory(0)) =>
% 	LET pcrs = getPCRs(s`pcrs,pm) IN
% 	a=OUT_FullQuote(tpmQuote(tpmCompositeHash((#select:=pm,
% 					pcrValue:=s`pcrs#)),
% 				 n,
% 				 signed(private(idKey),clear)),
% 			tpmIdContents(caDig,idKey,signed(private(idKey),clear)),
% 			CPU_SUCCESS)
	   
END tpm
