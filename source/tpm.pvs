%%
%% ----
%% TPM Theory
%%
%% Author: Perry Alexander, Brigid Halling
%% Date: Mon Nov 28 01:09:39 CST 2011
%%
%% Description: Basic model of a TPM using a monadic state model
%% 
%% Dependencies:
%%  StateMonad.pvs
%%  ReturnCodes.pvs
%%  memory.pvs 
%%  StclearFlags.pvs
%%  startupData.pvs
%%  PermanentData.pvs
%%  StanyData.pvs
%%  StanyFlags.pvs
%%  key.pvs
%%  data.pvs
%%  keyData.pvs
%%  pcr.pvs	
%%  authdata.pvs
%%  PermanentFlags.pvs
%%
%% Todo: (key - => pending, + => done)
%% ----

%% Standard Error IDs
%%  0 = "Bad identity record"
%%  1 = "Bad input key"
%%  2 = "bad session key"
%%  4 = "bad quote parts"
%%  5 = "Clear Disabled"

tpm[HV:TYPE+] : THEORY

  BEGIN

%   ASSUMING
%   % Assume that different blobs always have different hashes
%     unique_hash: ASSUMPTION
%       FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
%   ENDASSUMING

  K : TYPE = nat;

  IMPORTING ReturnCodes;
  IMPORTING startupData[K,HV];

  %% random number
%  RAND : (RNG?);

  OAEPdecode(d:tpmData) : tpmData =%(tpmMigrateAsymkey?) = 
    IF d/=badData AND OAEP?(d)
    THEN m(d)
    ELSE badData
    ENDIF

  %% State monad output type
  tpmAbsOutput : DATATYPE
  BEGIN
    OUT_Nothing : OUT_Nothing?
    OUT_Error(m:ReturnCode) : OUT_Error?
    OUT_CPUError(m:cpuReturn) : OUT_CPUError?
    OUT_Data_Bind(boundData:(encrypted?),m:cpuReturn) : OUT_Data_Bind?
    OUT_Certify(k:(tpmKey?),dat:(encrypted?),m:cpuReturn) : OUT_Certify?
    	% added k here for proofs... helps when sequencing.
	% potentially look for better way to do this.
    OUT_FullQuote(quote:(tpmQuote?),idBind:(signed?),m:cpuReturn) 
    	: OUT_FullQuote?
  %% Admin Startup and State (3)
    OUT_Init(m:ReturnCode) : OUT_Init?
    OUT_Startup(m:ReturnCode) : OUT_Startup?
    OUT_SaveState(m:ReturnCode) : OUT_SaveState?
  %% Admin Testing (4)
%     OUT_SelfTestFull
%     OUT_ContinueSelfTest
%     OUT_GetTestResult
  %% Admin Opt-in (5)
    OUT_SetOwnerInstall(m:ReturnCode) : OUT_SetOwnerInstall?
    OUT_OwnerSetDisable(o1:authOut,m:ReturnCode) : OUT_OwnerSetDisable?
    OUT_PhysicalEnable(m:ReturnCode) : OUT_PhysicalEnable?
    OUT_PhysicalDisable(m:ReturnCode) : OUT_PhysicalDisable?
    OUT_PhysicalSetDeactivated(m:ReturnCode) : OUT_PhysicalSetDeactivated?
    OUT_SetTempDeactivated(a:authOut,m:ReturnCode) : OUT_SetTempDeactivated?
    OUT_SetOperatorAuth(m:ReturnCode) : OUT_SetOperatorAuth?
  %% Admin Ownership (6)
    OUT_TakeOwnership(srk:(tpmKey?),a:authOut,m:ReturnCode) : OUT_TakeOwnership?
    OUT_OwnerClear(a:authOut,m:ReturnCode) : OUT_OwnerClear? 
    OUT_ForceClear(m:ReturnCode) : OUT_ForceClear? 
    OUT_DisableOwnerClear(a:authOut,m:ReturnCode) : OUT_DisableOwnerClear? 
    OUT_DisableForceClear(m:ReturnCode) : OUT_DisableForceClear? 
    OUT_PhysicalPresence(m:ReturnCode) : OUT_PhysicalPresence?
    OUT_ResetEstablishmentBit(m:ReturnCode) : OUT_ResetEstablishmentBit?
  %% Capability Commands (7)
%     OUT_GetCapability
%     OUT_SetCapability
%     OUT_GetCapabilityOwner
  %% Auditing (8)
%     OUT_GetAuditDigest
%     OUT_GetAuditDigestSigned
%     OUT_SetOrdinalAuditStatus
  %% Administrative Functions - Management (9)
%     OUT_FieldUpgrade
%     OUT_SetRedirection
%     OUT_ResetLockValue
  %% Storage Functions (10)
    OUT_Seal(sealedData:(tpmStoredData?),a:authOut,m:ReturnCode) : OUT_Seal?
    OUT_Unseal(secret:tpmData,a,da:authOut,m:ReturnCode) : OUT_Unseal?
    OUT_UnBind(boundData:tpmData,a:authOut,m:ReturnCode) : OUT_UnBind?
    OUT_CreateWrapKey(wrappedKey:(tpmKey?),a:authOut,m:ReturnCode) : 
    	OUT_CreateWrapKey?
    OUT_LoadKey2(inkeyHandle:(tpmKey?),a:authOut,m:ReturnCode) : OUT_LoadKey2?
    OUT_GetPubKey(pubKey:(tpmPubkey?),a:authOut,m:ReturnCode) : OUT_GetPubKey?
%    OUT_Sealx(sealedData:(tpmStoredData?),a:authOut,m:ReturnCode) : OUT_Sealx?
  %% Migration (11)
    OUT_CreateMigrationBlob(random:(RNG?),blobData:(encrypted?),a1,a2:authOut,
	m:ReturnCode) : OUT_CreateMigrationBlob?
    OUT_ConvertMigrationBlob(convertData:tpmData,a:authOut,
	m:ReturnCode) : OUT_ConvertMigrationBlob? %(encrypted?)
    OUT_AuthorizeMigrationKey(autData:(tpmMigKeyAuth?),a:authOut,m:ReturnCode):
    	OUT_AuthorizeMigrationKey?
    OUT_MigrateKey(migData:(encrypted?),a:authOut,m:ReturnCode) :OUT_MigrateKey?
    OUT_CMK_SetRestrictions(a:authOut,m:ReturnCode) : OUT_CMK_SetRestrictions?
    OUT_CMK_ApproveMA(approveData:(tpmDigest?),a:authOut,m:ReturnCode) : 
        OUT_CMK_ApproveMA?
    OUT_CMK_CreateKey(wk:(tpmKey?),a:authOut,m:ReturnCode) : OUT_CMK_CreateKey?
    OUT_CMK_CreateTicket(sigTic:(tpmDigest?),a:authOut,m:ReturnCode) : 
        OUT_CMK_CreateTicket?
    OUT_CMK_CreateBlob(random:(RNG?),data:tpmData,a:authOut,m:ReturnCode) :
        OUT_CMK_CreateBlob?
    OUT_CMK_ConvertMigration(data:tpmData,a:authOut,m:ReturnCode) : 
        OUT_CMK_ConvertMigration?
  %% Maintenance Functions (optional) (12)
%     OUT_CreateMaintenanceArchive
%     OUT_LoadMaintenanceArchive
%     OUT_KillMaintenanceFeature
%     OUT_LoadManuMaintPub
%     OUT_ReadManuMaintPub
  %% Cryptographic Functions (13)
    OUT_SHA1Start(m:ReturnCode) : OUT_SHA1Start?
    OUT_SHA1Update(m:ReturnCode) : OUT_SHA1Update?
    OUT_SHA1Complete(hv:(tpmDigest?),m:ReturnCode) : OUT_SHA1Complete?
    OUT_SHA1CompleteExtend(hv:(tpmDigest?),d:(tpmDigest?),m:ReturnCode) : 
      	OUT_SHA1CompleteExtend?				  
    OUT_Sign(sig:tpmData,m:ReturnCode) : OUT_Sign?
    OUT_GetRandom(br:(RNG?),m:ReturnCode) : OUT_GetRandom?
    OUT_StirRandom(m:ReturnCode) : OUT_StirRandom?
    OUT_CertifyKey(c:(tpmCertifyInfo?),od:(signed?),o1,o2:authOut,m:ReturnCode):
    	OUT_CertifyKey?
  %% Endorsement Key Handling (14)
    OUT_CreateEndorsementKeyPair(pubEk:(tpmKey?),checksum:(tpmDigest?),
	m:ReturnCode) : OUT_CreateEndorsementKeyPair?
    OUT_CreateRevocableEK(pubEK:(tpmPubkey?),checksum:(tpmDigest?),
	outputEKreset:(tpmNonce?),m:ReturnCode) : OUT_CreateRevocableEK?
    OUT_RevokeTrust(m:ReturnCode) : OUT_RevokeTrust?
    OUT_ReadPubek(pubEk:(tpmKey?),checksum:(tpmDigest?),m:ReturnCode) : 
    	OUT_ReadPubek?
    OUT_OwnerReadInternalPub(k:(tpmPubkey?),a:authOut,m:ReturnCode) : 
    	OUT_OwnerReadInternalPub?
  %% Identity Creation and Activation (15)
    OUT_MakeIdentity(idKey:(tpmKey?),idBinding:tpmData,a1,a2:authOut,
	m:ReturnCode) : OUT_MakeIdentity?
    OUT_ActivateIdentity(symmKey:(tpmSessKey?),a1,a2:authOut,m:ReturnCode) : 
   	OUT_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
    OUT_Extend(outDigest:(tpmDigest?),m:ReturnCode) : OUT_Extend?
    OUT_PCRRead(outDigest:(tpmDigest?),m:ReturnCode) : OUT_PCRRead?
    OUT_Quote(pcrData:(tpmPCRComposite?),sigD:(signed?),a:authOut,m:ReturnCode):
    	OUT_Quote?
    OUT_PCR_Reset(m:ReturnCode) : OUT_PCR_Reset?
%    OUT_Quote2() : OUT_Quote2
  %% Changing AuthData (17)
    OUT_ChangeAuth(data:(encrypted?),o1,o2:authOut,m:ReturnCode):OUT_ChangeAuth?
    OUT_ChangeAuthOwner(o1:authOut,m:ReturnCode) : OUT_ChangeAuthOwner?
  %% Authorizaton Sessions (18)
%     OUT_OIAP(auth:(tpmAuthData?),even:(tpmNonce?),m:ReturnCode) : OUT_OIAP?
%     OUT_OSAP(auth:(tpmAuthData?),e,eOSAP:(tpmNonce?),m:ReturnCode) : OUT_OSAP?
%     OUT_DSAP
%     OUT_SetOwnerPointer(m:ReturnCode) : OUT_SetOwnerPointer?
  %% Delegation Commands (19)
%     OUT_Delegate_Manage(rD:tpmData,a:authOut,m:ReturnCode):OUT_Delegate_Manage?
%     OUT_Delegate_CreateKeyDelegation(b:(tpmDelegatekeyBlob?),a:authOut,
% 	m:ReturnCode) : OUT_Delegate_CreateKeyDelegation?
%     OUT_Delegate_CreateOwnerDelegation(b:(tpmDelegateOwnerBlob?),a:authOut,
% 	m:ReturnCode) : OUT_Delegate_CreateOwnerDelegation?
%     OUT_Delegate_LoadOwnerDelegation(a:authOut,m:ReturnCode) : 
%     	OUT_Delegate_LoadOwnerDelegation?
%     OUT_Delegate_ReadTable(fT:(tpmFamilyTableEntry?),dT:(tpmDelegateIndex?),
% 	m:ReturnCode) : OUT_Delegate_ReadTable?
%     OUT_Delegate_UpdateVerification(oD:(tpmDelegateKeyBlob?),a:authOut,
% 	m:ReturnCode) : OUT_Delegate_UpdateVerification?
%     OUT_Delegate_VerifyDelegation(m:ReturnCode) : OUT_Delegate_VerifyDelegation?
  %% Non-volatile Storage (20)
%     OUT_NV_DefineSpace(a:authOut,m:ReturnCode) : OUT_NV_DefineSpace?
%     OUT_NV_WriteValue(a:authOut,m:ReturnCode) : OUT_NV_WriteValue?
%     OUT_NV_WriteValueAuth(a:authOut,m:ReturnCode) : OUT_NV_WriteValueAuth?
%     OUT_NV_ReadValue(d:tpmData,a:authOut,m:ReturnCode) : OUT_NV_ReadValue?
%     OUT_NV_ReadValueAuth(d:tpmData,a:authOut,m:ReturnCode):OUT_NV_ReadValueAuth?
  %% Session Management (21)
%     OUT_KeyControlOwner(a:authOut,m:ReturnCode) : OUT_KeyControlOwner?
%     OUT_SaveContext(cb:(tpmContextBlob?),m:ReturnCode) : OUT_SaveContext?
%     OUT_LoadContext(h:(tpmHandle?),m:ReturnCode) : OUT_LoadContext?
  %% Eviction (22)
    OUT_FlushSpecific(m:ReturnCode) : OUT_FlushSpecific?
  %% Timing Ticks (23)
%     OUT_GetTicks(cT:(tpmCurrentTicks?),m:ReturnCode) : OUT_GetTicks?
%     OUT_TickStampBlob(ct:(tpmCurrentTicks?),sig:(signed?),a:authOut,
% 	m:ReturnCode) : OUT_TickStampBlob?
  %% Transport Sessions (24)
%     OUT_EstablishTransport(tH:(tpmTransHandle?),l:(tpmModifierIndicator?),
% 	cT:(tpmCurrentTicks?),a:authOut,m:ReturnCode) : OUT_EstablishTransport?
%     OUT_ExecuteTransport(ct:int,l:(tpmModifierIndicator?),wR:tpmData,
% 	a:authOut,m:ReturnCode) : OUT_ExecuteTransport?
%     OUT_ReleaseTransportSigned(l:(tpmModifierIndicator?),cT:(tpmCurrentTicks?),
% 	sig:(signed?),a1,a2:authOut,m:ReturnCode) : OUT_ReleaseTransportSigned?
  %% Monotonic Counter (25)
%     OUT_CreateCounter(cid:(tpmCountId?),cv:(tpmCounterValue?),a:authOut,
% 	m:ReturnCode) : OUT_CreateCounter?
%     OUT_IncrementCounter(c:(tpmCounterValue?),a:authOut,m:ReturnCode) : 
%       	OUT_IncrementCounter?
%     OUT_ReadCounter(c:(tpmCounterValue?),m:ReturnCode) : OUT_ReadCounter?
%     OUT_ReleaseCounter(a:authOut,m:ReturnCode) : OUT_ReleaseCounter?
%     OUT_ReleaseCounterOwner(a:authOut,m:ReturnCode) : OUT_ReleaseCounterOwner?
  %% DAA Commands (26)
    OUT_DAA_Join(outputData:tpmData,a:authOut,m:ReturnCode) : OUT_DAA_Join?
    OUT_DAA_Sign(outputData:tpmData,a:authOut,m:ReturnCode) : OUT_DAA_Sign?
  %% Depreciated Commands (27)
  %% Deleted Commands (28)
  END tpmAbsOutput;

  % grind, decompose-equality
  unique_error: LEMMA 
    FORALL (b0,b1:ReturnCode) : OUT_Error(b0)=OUT_Error(b1) iff b0=b1;

  % assumption 
  sigQuote: LEMMA 
    FORALL (out:(OUT_Quote?)) :  
        tpmQuote?(signData(sigD(out)));


  IMPORTING memory[tpmAbsOutput,OUT_Nothing];
  

  %% State monad input type.  All inputs are in the form of a command with
  %% parameters.
  tpmAbsInput : DATATYPE
  BEGIN
  %% Admin Startup and State commands (3)
    ABS_Reset : ABS_Reset? %unimplemented
    ABS_Init : ABS_Init? 
    ABS_Startup(startupType : TPM_STARTUP_TYPE) : ABS_Startup?
    ABS_SaveState : ABS_SaveState?
  %% Admin Opt-in (5)
    ABS_SetOwnerInstall(state:bool) : ABS_SetOwnerInstall?
    ABS_OwnerSetDisable(disableState:bool,i:authIn) : ABS_OwnerSetDisable?
    ABS_PhysicalEnable : ABS_PhysicalEnable?
    ABS_PhysicalDisable : ABS_PhysicalDisable?
    ABS_PhysicalSetDeactivated(state:bool) : ABS_PhysicalSetDeactivated?
    ABS_SetTempDeactivated(i:authIn) : ABS_SetTempDeactivated?
    ABS_SetOperatorAuth(opAuth:(tpmSecret?)) : ABS_SetOperatorAuth?
  %% Admin Ownership Commands (6)
    ABS_TakeOwnership(oA,sA:(encrypted?),srk:(tpmKey?),a:authIn) : 
    	ABS_TakeOwnership?
    ABS_OwnerClear(a:authIn) : ABS_OwnerClear? 
    ABS_ForceClear : ABS_ForceClear? 
    ABS_DisableOwnerClear(a:authIn) : ABS_DisableOwnerClear? 
    ABS_DisableForceClear : ABS_DisableForceClear? 
    ABS_PhysicalPresence(p:PHYSPRES) : ABS_PhysicalPresence?
    ABS_ResetEstablishmentBit : ABS_ResetEstablishmentBit?
  %% Protected Storage Commands (10)
    ABS_Seal(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : ABS_Seal?	%encAuth:(tpmAuthData?)
    ABS_Unseal(parent:(tpmKey?),inData:(tpmStoredData?),a,da:authIn) : 
    	ABS_Unseal?   
    ABS_UnBind(key:(tpmKey?),inData:(encrypted?),a:authIn) : ABS_UnBind?
    ABS_CreateWrapKey(parentH,keyInfo:(tpmKey?),dUA,dMA:(tpmEncAuth?),a:authIn):
	ABS_CreateWrapKey?
    ABS_LoadKey2(parent,inKey:(tpmKey?),a:authIn): ABS_LoadKey2? 
    ABS_GetPubKey(key:(tpmKey?),a:authIn): ABS_GetPubKey? 
    ABS_Sealx(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : ABS_Sealx?
  %% Migration Commands (11)
    ABS_CreateMigrationBlob(p:(tpmKey?),m:(tpmMigScheme?),mKA:(tpmMigKeyAuth?),
	encData:(encrypted?),a1,a2:authIn) : ABS_CreateMigrationBlob?
    ABS_ConvertMigrationBlob(parent:(tpmKey?),inData:(encrypted?),
	random:(RNG?),a:authIn) : ABS_ConvertMigrationBlob?
    ABS_AuthorizeMigrationKey(migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : ABS_AuthorizeMigrationKey?
    ABS_MigrateKey(ma,pub:(tpmKey?),inData:(encrypted?),a:authIn) : 
        ABS_MigrateKey?
    ABS_CMK_SetRestrictions(restr:(tpmCMKDelegate?),i:authIn) : 
        ABS_CMK_SetRestrictions?
    ABS_CMK_ApproveMA(migAuth:(tpmDigest?),i:authIn) : ABS_CMK_ApproveMA?
    ABS_CMK_CreateKey(p:(tpmKey?),dataUsageAuth:(tpmEncAuth?),k:(tpmKey?),
        migAuthApp:(tpmDigest?),migAuthDig:(tpmDigest?),i:authIn) : 
        ABS_CMK_CreateKey?
    ABS_CMK_CreateTicket(verifKey:(tpmPubkey?),signedData:(tpmDigest?),
        sigVal:tpmData,i:authIn) : ABS_CMK_CreateTicket?
    ABS_CMK_CreateBlob(p:(tpmKey?),t:(tpmMigScheme?),mkAuth:(tpmMigKeyAuth?),
        psk:(tpmDigest?),msaList:(tpmMSAComposite?),restrTicket:(tpmCMKAuth?),
        sigTicket:(tpmDigest?),encData:(encrypted?),i:authIn) : 
	ABS_CMK_CreateBlob?
    ABS_CMK_ConvertMigration(p:(tpmKey?),restrTick:(tpmCMKAuth?),
        sigTick:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),
	rand:(RNG?),i:authIn) : ABS_CMK_ConvertMigration?
  %% Cryptographic Commands (13)
    ABS_SHA1Start : ABS_SHA1Start?
    ABS_SHA1Update(hd:tpmData) : ABS_SHA1Update?
    ABS_SHA1Complete(hd:tpmData) : ABS_SHA1Complete?
    ABS_SHA1CompleteExtend(p:PCRINDEX,hd:tpmData) : ABS_SHA1CompleteExtend?
    ABS_Sign(keyHandle:(tpmKey?),areaToSign:tpmData) : ABS_Sign?
    ABS_GetRandom : ABS_GetRandom?
    ABS_StirRandom(i:nat) : ABS_StirRandom?
    ABS_CertifyKey(c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) : ABS_CertifyKey?
  %% Endorsement Key Handling (14)
    ABS_CreateEndorsementKeyPair(antiReplay:(tpmNonce?),keyInfo:(tpmKey?)) : 
    	ABS_CreateEndorsementKeyPair?
    ABS_CreateRevocableEK(antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	genReset:bool,inputEKreset:(tpmNonce?)) : ABS_CreateRevocableEK?
    ABS_RevokeTrust(EKReset:(tpmNonce?)) : ABS_RevokeTrust?
    ABS_ReadPubek(n:(tpmNonce?)) : ABS_ReadPubek?
    ABS_OwnerReadInternalPub(k:(tpmKey?),a:authIn) : ABS_OwnerReadInternalPub?
  %% Identity Creation and Activation (15)
    ABS_MakeIdentity(idAuth:(tpmEncAuth?),CADigest:(tpmDigest?),idKey:(tpmKey?),
	a1,a2:authIn) : ABS_MakeIdentity?
    ABS_ActivateIdentity(aik:(tpmKey?),b:(encrypted?),a1,a2:authIn):
    	ABS_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
    ABS_Extend(pcrNum:PCRINDEX,d:HV) : ABS_Extend?
    ABS_PCRRead(ind:PCRINDEX) : ABS_PCRRead?
    ABS_Quote(aik:(tpmKey?),nonce:(tpmNonce?),pm:PCR_SELECTION,i:authIn) : 
    	ABS_Quote?
    ABS_PCR_Reset(pcrSelect:PCR_SELECTION) : ABS_PCR_Reset?
  %% Changing AuthData (17)
    ABS_ChangeAuth(p:(tpmKey?),newA:(tpmEncAuth?),d:(encrypted?),i1,i2:authIn) :
    	ABS_ChangeAuth?
    ABS_ChangeAuthOwner(newA:(tpmEncAuth?),i:authIn) : ABS_ChangeAuthOwner?
  %% Authorizaton Sessions (18)
    ABS_OIAP : ABS_OIAP?
    ABS_OSAP(oOSAP:(tpmNonce?)) : ABS_OSAP?
  %% Eviction (22)
    ABS_FlushSpecific(h:tpmData) : ABS_FlushSpecific?
  %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    ABS_save(i:nat,v:tpmAbsOutput) : ABS_save?
    ABS_read(i:nat) : ABS_read?
    ABS_Data_Bind(k:(tpmKey?),d:tpmData) : ABS_Data_Bind?
    ABS_buildQuoteFromMem(q,i:nat) : ABS_buildQuoteFromMem?
  %% CA Commands
    ABS_certify(aik:(tpmKey?),certReq:(signed?)) : ABS_certify?
  %% Invented, imaginary Commands
    noopCom : noopCom?
  END tpmAbsInput;

  %% sinit blob instance for measurement
  %sinit : B;
  sinitHash : HV;

  %% mle blob instance for measurement
  %mle : B;
  mleHash : HV;


  %% Initial key values not generated by TPM
  ekKeyVal : K = 1;
  srkKeyVal : K = 2;
  caKeyVal : K = 3;

  %% Initial key count value for initializing TPM
  initKeyVal : K = 100;
  initSessKeyVal : K = 50;

  %% Key definitions that make ek and srk values asymmetric keys.
  %% TODO: I mostly just made this stuff up... needs to be checked and changed
  ekVal:(tpmKey?) = tpmKey(ekKeyVal,
			   storage,				% 5.8.1
			   keyFlagsF,
			   always,
			   keyParmsDef,
			   %encr_alg is MGF1			% 5.8.1
			   pcrInfoLongDefault,
			   storeAsymkeyDefault(ekKeyVal,ekKeyVal));
  srkVal:(tpmKey?) = tpmKey(srkKeyVal,storage,keyFlagsF,	
			    always,keyParmsDef,
			    pcrInfoLongDefault,
			    storeAsymkeyDefault(srkKeyVal,ekKeyVal));
  caVal:(tpmKey?) = tpmKey(caKeyVal,storage,keyFlagsF,
			   always,keyParmsDef,
			   pcrInfoLongDefault,
			   storeAsymkeyDefault(caKeyVal,ekKeyVal)); 
			   % Certificate Authority key

  %% Abstract TPM State with keys, PCR array and locality
  tpmAbsState : TYPE = [# restore : restoreStateData
                        , memory : mem
                        , srk : (tpmKey?)	%TODO: where should this be?
                        , ek : (tpmKey?)	%TODO: where should this be?
                        , keyGenCnt : K
                        , keys : KEYSET
                        , pcrs : PCRVALUES	% stClearData`PCR?
                        , locality : LOCALITY
                        , permFlags : PermFlags
                        , permData : PermData
                        , stanyFlags : StanyFlags
                        , stanyData : StanyData
                        , stclearFlags : StclearFlags
                        , stclearData : StclearData
                        , outData : list[tpmData] %%TURN INTO LIST
		        , randCnt : K
                        #];

  %% Well formedness condition for abstract states.  Currently unused, but we
  %% should show that forall commands, well formed input generates well formed
  %% output.

  wellFormed?(s:tpmAbsState):bool = wellFormedRestore?(restore(s));

  IMPORTING StateMonad[tpmAbsOutput,tpmAbsState];

  %% Define some common TPM states and state operations
  
  %% Unknown state
  tpmUnknown : tpmAbsState

  tpmDefault : (wellFormed?) = (#
                         pcrs:=pcrsPower
                         , locality:=4
			 , keys:=(#vals:=emptyset,keys:=emptyset#)
			 , srk:=invalidKey
			 , ek:=TPM_KH_EK
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsDefault
			 , permData:=permDataDefault
			 , stanyFlags:=stanyFlagsDefault
			 , stanyData:=stanyDataDefault
			 , stclearFlags:=stclearFlagsDefault % TODO: check
			 , stclearData :=stclearDataDefault  % TODO: check
			 , outData := null
			 , randCnt := 0
			 #);

  removeKeysStartup(ks:KEYSET) : KEYSET = addKey(TPM_KH_EK,ks) %%TODO!!
  %TODO!!
%     LAMBDA (k:privKVAL) :
%       IF parentPCRStatus OR isVolatile
%       THEN flushSpecificOut(keyHandle)
%       ELSE noop %TODO
%       ENDIF

  %% Power on state after init is raised by hardware.
  tpmPostInit : (wellFormed?) = tpmDefault WITH 
  	      		      	  [`stanyFlags(postInitialize):=TRUE]

  %% Standard initial state following startup command with the TPM_ST_CLEAR
  %% option set.  Note that this should be checked against the spec before
  %% asserting goodness. 
  tpmStartup(s:tpmAbsState) : (wellFormed?) = 				% 2
    tpmDefault WITH [%TODO
    	       	     %Sess RT_CONTEXT,RT_AUTH,RT_DAA,RT_TRANS invalid 	% 2a
    	       	     %stclearData`PCR default 			  	% 2b
		     `stclearFlags(physicalPresence):=
			physicalPresenceDef				% 2ci
		    ,`stclearFlags(physicalPresenceLock):=
			physicalPresenceLockDef				% 2cii
		    ,`stclearFlags(disableForceClear):=
			disableForceClearDef				% 2ciii
		    % TODO? auditDigest					% 2d
		    ,`stclearFlags(deactivated):=s`permFlags`deactivated% 2e
		    ,`stanyData(contextNonceSession):=tpmNonceZero	% 2fi
		    ,`stanyData(contextCount):=0			% 2fii
		    ,`stanyData(contextList):=0				% 2fiii
		    ,`stclearData(contextNonceKey):=tpmNonceZero	% 2gi
		    %,`stclearData(countId):=0				% 2gii
		    ,`stclearData(ownerReference):=key(TPM_KH_OWNER)	% 2giii
		    ,`stclearFlags(bGlobalLock):=FALSE			% 2hi
		    ,`keys:=removeKeysStartup(s`keys)			% 2i
		    ,`restore:=tpmRestoreUnknown %TODO			% 5
		    ,`stanyFlags(postInitialize):=FALSE]		% 6
  	       		  

  %% Generate a new state from restore data.  Basically this is a clear
  %% restart with pcrs, keys, and pcr flags coming from the restore
  %% data.  Note that this function assumes valid data and will behave
  %% badly otherwise
  tpmRestore(rd:(wellFormedRestore?)) : (wellFormed?) = (#
                         pcrs:=pcrs(rd)
			 , locality:=4
			 , keys:=keys(rd)
			 , srk:=srkVal
			 , ek:=ekVal
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=rd
			 , permFlags:=permFlags(rd)
			 , permData:=permData(rd)
			 , stanyFlags:=stanyFlags(rd)
			 , stanyData:=stanyData(rd)
			 , stclearFlags:=stclearFlagsDefault
			 , stclearData :=stclearDataDefault
			 , outData := null
			 , randCnt := 0
                         #)

 
  %% Predicate to determine if startup has occured.  Used as types
  %% (afterInit?) is the set of states occuring immediately after TPM_Init
  %% (afterStartup?) is the set of states occuring immediately after
  %% TPM_Startup
  afterInit?(s:tpmAbsState):bool = postInitialize(stanyFlags(s));
  afterStartup?(s:tpmAbsState):bool = NOT postInitialize(stanyFlags(s));

  %% Standard operations on TPM state definition above.  All such
  %% functions end with State to indicate they operate on the state
  %% value rather than on the TPM monad.  Note that key set and pcr
  %% manipulation functions are defined externally in key.pvs and
  %% pcr.pvs respectively

  %% Reset PCRs as performed by SENTER.
  pcrsResetSenterState(s:tpmAbsState) : tpmAbsState =
    s WITH [`pcrs := pcrsSenter(pcrs(s),pcrAttrib(permData(s)))];

  %% Decrease locality value
  changeLocalityState(s:tpmAbsState) : tpmAbsState =
    s WITH [`locality := IF locality(s) > 0
                         THEN locality(s) - 1
			 ELSE 0
			 ENDIF];
    
  %% Generate a new key
  genKeyState(s:tpmAbsState) : tpmAbsState =
    s WITH [`keyGenCnt := keyGenCnt(s)+1];

  gen_key_state : THEOREM FORALL (state:tpmAbsState,i:nat) : 
    LET s=genKeyState(state WITH [`keyGenCnt:=i]) IN
	keyGenCnt(s)=i+1;

  %% Increment randCnt to get next random number
  randState(s:tpmAbsState) : tpmAbsState =
    s WITH [`randCnt := randCnt(s)+1];

  rand_state : THEOREM FORALL (state:tpmAbsState,i:nat) : 
    LET s=randState(state WITH [`randCnt:=i]) IN
	randCnt(s)=i+1;

%  saveStateKeys(s:tpmAbsState) : KEYSET = 
%     IF parentPCRStatus THEN Keep					% 5
%     ELSIF TPM_KEY_CONTROL_OWNER_EVICT THEN Keep			% 6
%     ELSIF %The contents of any key that is currently loaded MAY be preserved
% 	  keep all							% 7

  saveState(s:tpmAbsState) : tpmAbsState =
    % TODO PCRs								% 1
    % TODO auditDigest							% 2
    % TODO sessions							% 8
    s WITH [`restore:=saveState(keys(s)					% 5,6,7
                               ,ek(s)
		      	       ,srk(s)
			       ,keyGenCnt(s)
		      	       ,pcrs(s)
		      	       ,permFlags(s)
		      	       ,permData(s)
			       ,stanyFlags(s)
			       ,stanyData(s)
			       ,stclearFlags(s)				% 4
			       ,stclearData(s)				% 3
		      		)];

  setOwnerInstallState(s:tpmAbsState,state:bool) : tpmAbsState = 
    IF not(invalidAuth?(s`permData`ownerAuth)) 				% 1
    THEN s
    ELSIF s`stclearFlags`physicalPresence				% 2
    THEN s WITH [`permFlags`ownership:=state]
    ELSE s
    ENDIF;

  setOwnerInstallOut(s:tpmAbsState,state:bool) : tpmAbsOutput =
    IF not(invalidAuth?(s`permData`ownerAuth)) 				% 1
    THEN OUT_SetOwnerInstall(TPM_SUCCESS)	
    ELSIF s`stclearFlags`physicalPresence				% 2
    THEN OUT_SetOwnerInstall(TPM_SUCCESS)
    ELSE OUT_Error(TPM_INSTALL_DISABLED) %TODO: double check
    ENDIF;

  ownerSetDisableState(s:tpmAbsState,disableState:bool,i:authIn) : tpmAbsState =
    % Authenticate command as coming form TPM Owner. If unsuccessful 
    % THEN OUT_Error(TPM_AUTHFAIL)					% 1
    s WITH [`permFlags`disable:=disableState]				% 2

  ownerSetDisableOut(s:tpmAbsState,disableState:bool,i:authIn) : tpmAbsOutput =
    % Authenticate command as coming form TPM Owner. If unsuccessful 
    % THEN OUT_Error(TPM_AUTHFAIL)					% 1
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
    OUT_OwnerSetDisable(o1,TPM_SUCCESS);
    
  physicalEnableState(s:tpmAbsState) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=FALSE]				% 2
    ENDIF;
    
  physicalEnableOut(s:tpmAbsState) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalEnable(TPM_SUCCESS)
    ENDIF;

  physicalDisableState(s:tpmAbsState) : tpmAbsState = 
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=TRUE]				% 2
    ENDIF;

  physicalDisableOut(s:tpmAbsState) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalDisable(TPM_SUCCESS)
    ENDIF;

  physicalSetDeactivatedState(s:tpmAbsState,state:bool) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=state]				% 2
    ENDIF;

  physicalSetDeactivatedOut(s:tpmAbsState,state:bool) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalSetDeactivated(TPM_SUCCESS)
    ENDIF;

  setTempDeactivatedState(s:tpmAbsState,i:authIn) : tpmAbsState =
    IF not s`permFlags`operator						% 1a
    THEN s
    ELSIF % Validate command and params using ownerAuth(i) else		% 1b
    	 % OUT_Error(TPM_AUTHFAIL)
    	 not s`stclearFlags`physicalPresence				% 2
    THEN s
    ELSE s WITH [`stclearFlags`deactivated:=TRUE]			% 3
    ENDIF;

  setTempDeactivatedOut(s:tpmAbsState,i:authIn) : tpmAbsOutput =
    IF not s`permFlags`operator						% 1a
    THEN OUT_Error(TPM_NOOPERATOR)
    ELSIF % Validate command and params using ownerAuth(i) else		% 1b
    	 % OUT_Error(TPM_AUTHFAIL)
    	 not s`stclearFlags`physicalPresence				% 2
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
 	OUT_SetTempDeactivated(o1,TPM_SUCCESS)
    ENDIF;

  setOperatorAuthState(s:tpmAbsState,opAuth:(tpmSecret?)) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permData`operatorAuth:=opAuth				% 2
    	   	,`permFlags`operator:=TRUE]				% 3
    ENDIF;

  setOperatorAuthOut(s:tpmAbsState,opAuth:(tpmSecret?)) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_SetOperatorAuth(TPM_SUCCESS)
    ENDIF;


  takeOwnership?(s:tpmAbsState,k:(tpmKey?),oa,sa:(encrypted?)) : bool =
    COND
      i(s`permData`ownerAuth)/=INVALIDAUTH -> FALSE,			% 1
      not s`permFlags`ownership -> FALSE,				% 2
      not goodkey?(key(s`ek)) -> FALSE,					% 3
      %not OIAP?(authHandle) -> FALSE,					% 4
      %not protocolID = TPM_PID_OWNER -> FALSE,				% 5
      %  not length(A1)=20bytes -> FALSE,	     			% 6
      %not command, params using A1, ownerAuth -> FALSE,		% 7
      not storage?(keyUsage(k)) -> FALSE,   				% 8a
      migratable(keyFlags(k)) -> FALSE,					% 8b
      not RSA?(algoId(algoParms(k))) -> FALSE,				% 8c
      not SHA1_MGF1?(encScheme(algoParms(k))) -> FALSE,			% 8d    
      not none?(sigScheme(algoParms(k))) -> FALSE,			% 8e
      %length(parms(algoParms(k)))<2048 -> FALSE,			% 8f
      %expSize(parms(algoParms(k)))/=0 -> FALSE,			% 8g
      s`permFlags`FIPS AND never?(authDataUsage(k))-> FALSE,		% 8h
      ELSE -> TRUE
    ENDCOND;

  takeOwnershipState(s:tpmAbsState,encOwnerA,encSrkA:(encrypted?),
	k:(tpmKey?),a:authIn) : tpmAbsState =
    COND
      NOT takeOwnership?(s,k,encOwnerA,encSrkA) -> s,			% 1-8
      ELSE -> LET A2=decrypt(encSrkA,private(s`ek),s`keys),		% 10
      	      	  A1=decrypt(encOwnerA,private(s`ek),s`keys) IN		% 6
	      LET asymkey=tpmStoreAsymkey(A2,	 			% 10c
			    migrationAuth(encData(encDat(k))),
			    pubDataDigest(encData(encDat(k))),
			    private(k)) IN %TODO
	      LET K1=tpmKey(key(k),keyUsage(k),keyFlags(k),
				authDataUsage(k),algoParms(k),		% 9
		      		PCRInfo(k),encrypt(asymkey,0)) IN %TODO!
	      s WITH [`srk:=K1						% 11
		     ,`permData(ownerAuth):=A1				% 12
		     % TODO: 
		     %,`permData(contextKey)?				% 13
		     %,`permData(delegateKey)?				% 14
		     ,`permData(tpmProof):=tpmSecret(n(RNG(s`randCnt)))	% 15
		     ,`permFlags(readPubek):=FALSE			% 17
		     ,`outData:=cons(K1,outData(s))
		     ,`randCnt:=randCnt(s)+1]
    ENDCOND;

  takeOwnershipOut(s:tpmAbsState,encOwnerA,encSrkA:(encrypted?),
	k:(tpmKey?),a:authIn) : tpmAbsOutput =
    LET A1=decrypt(encOwnerA,private(s`ek),s`keys),			% 6
        A2=decrypt(encSrkA,private(s`ek),s`keys) IN 			% 10
    IF NOT takeOwnership?(s,k,encOwnerA,encSrkA)
    THEN IF i(s`permData`ownerAuth)/=INVALIDAUTH % TODO: CHECK 
      	 THEN OUT_Error(TPM_OWNER_SET)					% 1
     	 ELSIF not s`permFlags`ownership 
      	 THEN OUT_Error(TPM_INSTALL_DISABLED)				% 2
     	 ELSIF not goodkey?(key(s`ek)) 
      	 THEN OUT_Error(TPM_NO_ENDORSEMENT)				% 3
%% TODO:
%   	 ELSIF not OIAP?(a`authHandle) 
% 	 THEN OUT_Error(TPM_AUTHFAIL)					% 4
%   	 ELSIF not protocolID = TPM_PID_OWNER 
% 	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 5
% 	 ELSIF not length(A1)=20bytes 
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 6
%   	 ELSIF not command, params using A1, ownerAuth 
% 	 THEN OUT_Error(TPM_AUTHFAIL)					% 7
     	 ELSIF not storage?(keyUsage(k)) 
	 THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 8a
     	 ELSIF migratable(keyFlags(k)) 
	 THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 8b
     	 ELSIF NOT RSA?(algoId(algoParms(k))) 
	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8c
  	 ELSIF not SHA1_MGF1?(encScheme(algoParms(k))) 
	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8d    
  	 ELSIF not none?(sigScheme(algoParms(k))) 
	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8e
%   	 ELSIF length(parms(algoParms(k)))<2048 
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8f
%   	 ELSIF expSize(parms(algoParms(k)))/=0
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8g
     	 ELSIF s`permFlags`FIPS AND never?(authDataUsage(k))
	 THEN OUT_Error(TPM_NOTFIPS)					% 8h
% 	 ELSIF not length(A2)=20bytes 
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 10b
     	 ELSE OUT_Error(TPM_SUCCESS) % should never reach here
    	 ENDIF 
    ELSE %takeOwnership?(s,k)
        LET asymkey=tpmStoreAsymkey(A2,					% 10c
			migrationAuth(encData(encDat(k))),
			pubDataDigest(encData(encDat(k))),
			private(k)) IN
        % Structure containing all params of new SRK. srkPub.encData is set to 0
        LET K1=tpmKey(key(k),keyUsage(k),keyFlags(k),
		      authDataUsage(k),algoParms(k),
		      PCRInfo(k),encrypt(asymkey,0)),  %TODO!		% 9
	    aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			    contAuthSess:=TRUE,resAuth:=A1#) IN		% 18
    	    OUT_TakeOwnership(K1,aOut,TPM_SUCCESS)			% 16
    ENDIF;


  clear(s:tpmAbsState) : tpmAbsState = %not fully implemented
    s WITH [`keys:=(#vals:=emptyset,keys:=emptyset#) 
	   ,`permData(ownerAuth):=tpmSecret(INVALIDAUTH)		% 5a
      	   ,`srk:=tpmKey(0,keyUsage(s`srk),keyFlags(s`srk),
			 authDataUsage(s`srk),algoParms(s`srk),
			 PCRInfo(s`srk),encDat(s`srk))			% 5b
	   %,`permData(delegateKey):=badkey				% 5c
	   %,`permData(delegateTable):=invalid				% 5d
	   %,`permData(contextKey):=badkey				% 5e
	   ,`permData(tpmProof):=tpmSecret(INVALIDPROOF)		% 5f
	   ,`permData(operatorAuth):=tpmSecret(INVALIDAUTH)		% 5g
	   %,`permData(noOwnerNVWrite):=0				% 6a
	   %,`permData(ordinalAuditStatus):=default			% 6b
	   %,`permData(restrictDelegate):=default			% 6c
	   ,`stanyData:=stanyDataDefault				% 7
	   %TODO : nonces shall be reset, lists invalidated
	   ,`stclearData:=stclearDataDefault 
	   			WITH [`PCR:=PCR(stclearData(s))]	% 8
	   %TODO:nonces shall be reset, lists invalidated, defPhysPresence=0
	   ,`permFlags(disable):=disableDef				% 9a
	   ,`permFlags(deactivated):=deactivatedDef			% 9b
	   ,`permFlags(readPubek):=readPubekDef				% 9c
	   ,`permFlags(disableOwnerClear):=disableOwnerClearDef		% 9d
	   ,`permFlags(disableFullDALogicInfo):=disableFullDALogicInfoDef% 9e
	   ,`permFlags(allowMaintenance):=allowMaintenanceDef		% 9f
	   ,`permFlags(readSRKPub):=readSRKPubDef			% 9g
      	   ,`permFlags(ownership):=TRUE					% 10a
	   ,`permFlags(operator):=FALSE					% 10b
	   ,`permFlags(maintenanceDone):=FALSE				% 10c
	   %,`permData(monotonicCounter):= release all values		% 11
	   % TODO: 12-14
      	   ]

  ownerClearState(s:tpmAbsState,a:authIn) : tpmAbsState =
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> s,
      s`permFlags`disableOwnerClear -> s,				% 2
      ELSE -> clear(s)		      	 				% 3-14
    ENDCOND;

  ownerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> TPM_Error(TPM_AUTHFAIL),
      disableOwnerClear(permFlags(s)) -> OUT_Error(TPM_CLEAR_DISABLED),	% 2 
      ELSE -> LET a:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			     contAuthSess:=FALSE,resAuth:=ownerAuth(a)#) IN
      	      OUT_OwnerClear(a,TPM_SUCCESS)				% 3-14
    ENDCOND;

  forceClearState(s:tpmAbsState) : tpmAbsState = 
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN s								% 2
    	 ELSE clear(s)							% 3
    	 ENDIF
    ELSE s								% 1
    ENDIF
  
  forceClearOut(s:tpmAbsState) : tpmAbsOutput =
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN OUT_Error(TPM_CLEAR_DISABLED)   	 	  	      	% 2
    	 ELSE OUT_ForceClear(TPM_SUCCESS)				% 3
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PRESENCE)					% 1
    ENDIF

  disableOwnerClearState(s:tpmAbsState,a:authIn) : tpmAbsState = 
  % 1. TPM verifies authHandle properly authorizes owner
    s WITH [`permFlags(disableOwnerClear):=TRUE];			% 2

  disableOwnerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=TRUE,resAuth:=ownerAuth(a)#) IN
    OUT_DisableOwnerClear(a1,TPM_SUCCESS)				
    % TODO: 3. When this flag is TRUE... Prove this?

  disableForceClearState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`stclearFlags(disableForceClear):=TRUE];			% 1

  disableForceClearOut(s:tpmAbsState) : tpmAbsOutput = 
    OUT_DisableForceClear(TPM_SUCCESS)

  physicalPresenceState(s:tpmAbsState,p:PHYSPRES) : tpmAbsState =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN s								% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN s								% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN s								% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN s								% 2d
	 ELSE s WITH [`permFlags`physicalPresenceHWEnable:=
			IF member(HW_ENABLE,p) THEN TRUE		% 2e
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2f
			ELSE s`permFlags`physicalPresenceHWEnable ENDIF,
		      `permFlags`physicalPresenceCMDEnable:=
			IF member(CMD_ENABLE,p) THEN TRUE		% 2g
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2h
			ELSE s`permFlags`physicalPresenceCMDEnable ENDIF,
		      `permFlags`physicalPresenceLifetimeLock:=
			IF member(LIFETIME_LOCK,p) THEN TRUE		% 2i
			ELSE s`permFlags`physicalPresenceLifetimeLock ENDIF]
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN s								% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN s								% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN s								% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN s								% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN s								% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE		% 3fi
	      	     ,`stclearFlags`physicalPresenceLock:=TRUE]		% 3fii
    	 ELSIF member(PRESENT,p)					% 3g
	 THEN s WITH [`stclearFlags`physicalPresence:=TRUE]		% 3gi
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE]		% 3hi
	 ELSE s % should never get to this case.
    	 ENDIF
    ELSE s								% 4
    ENDIF

  physicalPresenceOut(s:tpmAbsState,p:PHYSPRES) : tpmAbsOutput =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2d
	 ELSE OUT_PhysicalPresence(TPM_SUCCESS)				% 2j
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)	% 3
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3fiii
    	 ELSIF member(PRESENT,p) 					% 3g
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSE OUT_Error(TPM_BAD_PARAMETER) % should never get here
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PARAMETER)					% 4
    ENDIF
  
  resetEstablishment?(s:tpmAbsState) : bool = 
    s`locality=3 or s`locality=4;

  resetEstablishmentBitState(s:tpmAbsState) : tpmAbsState = 
    IF resetEstablishment?(s)						% 1
    THEN s WITH [`permFlags(tpmEstablished):=FALSE]			% 2
    ELSE s
    ENDIF

  resetEstablishmentBitOut(s:tpmAbsState) : tpmAbsOutput = 
    IF resetEstablishment?(s)						% 1
    THEN OUT_ResetEstablishmentBit(TPM_SUCCESS)				% 3
    ELSE OUT_Error(TPM_BAD_LOCALITY)					%TODO
    ENDIF
  
  seal?(k:(tpmKey?)) : bool =
    storage?(keyUsage(k)) AND not(migratable(keyFlags(k)))
    
  sealState(s:tpmAbsState,kH:(tpmKey?),enc:(tpmEncAuth?),p:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : tpmAbsState =
    IF not seal?(kH)
    THEN s								% 3,4
    ELSE LET h2=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(p),% 11bvi 
				   s`pcrs)) IN
    	 LET s1=tpmStoredData(tpmPCRInfoLong(				% 11
				s`stanyFlags`localityModifier,		% 11viii
				locAtRelease(p),			% 11bv
				creationPCRSelect(p),			% 11bii
				releasePCRSelect(p),			% 11biii
				h2,					% 11bvii
				digAtRelease(p))			% 11biv
			     ,tpmNull					% 9
			     ) IN
	     % decrypting encAuth according to the ADIP indicated by authHandle
	 LET a1=decryptADIP(enc,authHandle(a)), % TODO: incorrect	% 12
	     h3:(tpmDigest?)=SHA1(s1) IN	  			% 14c
    	 LET S2=tpmSealedData(a1,		 			% 14,e
			      s`permData`tpmProof,			% 14b
			      h3,					% 14d
    	     		      inData) IN				% 14g
	% Validate the size(S2) can be encrypted by kH,TPM_BAD_DATASIZE % 15
	 LET S3=encrypt(S2,key(kH)) IN					% 16
	 LET S1=tpmStoredData(sealInfo(s1),S3)  	  		% 11,19
    	     IN s WITH [`outData:=cons(S1,outData(s))]			% 20
    ENDIF

  % Output secret sealed with asymmetric key 
  % crs(S1) encrypts S2
  sealOut(s:tpmAbsState,kH:(tpmKey?),enc:(tpmEncAuth?),p:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : tpmAbsOutput = 
    % Validate the authorization to use the key pointed to by kH	% 1
    % IF inDataSize = 0 THEN OUT_Error(TPM_BAD_PARAMETER)     		% 2
    IF not seal?(kH)
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 3,4
    % TODO: Determine version of pcrInfo				% 5
    ELSE LET h2=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(p),	% 11bvi 
				   s`pcrs)) IN
    	 LET s1=tpmStoredData(tpmPCRInfoLong(				% 11
				s`stanyFlags`localityModifier,		% 11viii
				locAtRelease(p),			% 11bv
				creationPCRSelect(p),			% 11bii
				releasePCRSelect(p),			% 11biii
				h2,					% 11bvii
				digAtRelease(p))			% 11biv
			     ,tpmNull					% 9
			     ) IN
	     % decrypting encAuth according to the ADIP indicated by authHandle
	 LET a1=decryptADIP(enc,authHandle(a)), % TODO: incorrect	% 12
	     h3:(tpmDigest?)=SHA1(s1) IN	  			% 14c
    	 LET S2=tpmSealedData(a1,		 			% 14,e
			      s`permData`tpmProof,			% 14b
			      h3,					% 14d
    	     		      inData) IN				% 14g
	% Validate the size(S2) can be encrypted by kH,TPM_BAD_DATASIZE % 15
	 LET S3=encrypt(S2,key(kH)) IN					% 16
	 LET S1=tpmStoredData(sealInfo(s1),S3),  	  		% 11,19
	     A:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,				% 17
			resAuth:=usageAuth(encData(encDat(kH)))#)
    	     IN OUT_Seal(S1,A,TPM_SUCCESS)				% 20
    ENDIF

  unseal?(s:tpmAbsState,p:(tpmKey?),d:(tpmStoredData?)) : bool =
    LET d1=decrypt(encrData(d),private(p),s`keys),			% 5
	S2=tpmStoredData(sealInfo(d),tpmNull),				% 4
	h2=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(sealInfo(d)),
			      s`pcrs)) IN				% 7bii
    storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND		% 2,3
    tpmSealedData?(d1) AND	   			   		% 5
    not(not(tpmProof(d1)=tpmProof(s`permData) AND			% 6b
        SHA1(S2)=storedDigest(d1))) AND	      				% 6e,f
    locAtRelease(sealInfo(S2))=localityModifier(s`stanyFlags) AND	% 7biii 
    h2=digAtRelease(sealInfo(S2))			      		% 7c

  unsealState(s:tpmAbsState,parent:(tpmKey?),inData:(tpmStoredData?),
	pa,da:authIn) : tpmAbsState = 
    LET d1=decrypt(encrData(inData),private(parent),s`keys),	  	% 5
	S2=tpmStoredData(sealInfo(inData),tpmNull),			% 4
	h2=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(sealInfo(inData)),
			      s`pcrs)) IN				% 7bii
    IF not unseal?(s,parent,inData)
    THEN s
    ELSE s WITH [`outData:=cons(sealedData(d1),outData(s))]		% 20
    ENDIF

  % Output secret unsealed with an asymmetric key and PCRs 
  unsealOut(s:tpmAbsState,parent:(tpmKey?),inData:(tpmStoredData?),
	pa,da:authIn) : tpmAbsOutput = 
    % Validate that pa authorizes the use of the key in p TPM_AUTHFAIL	% 1
    LET d1=decrypt(encrData(inData),private(parent),s`keys),	  	% 5
	S2=tpmStoredData(sealInfo(inData),tpmNull),			% 4
	h2=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(sealInfo(inData)),
			      s`pcrs)) IN				% 7bii
    IF not(storage?(keyUsage(parent)) AND	  			% 2
       	   not(migratable(keyFlags(parent))))				% 3
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not tpmSealedData?(d1)					% 5
    THEN OUT_Error(TPM_NOTSEALED_BLOB)
    ELSIF not(tpmProof(d1)=tpmProof(s`permData) AND			% 6b
       	  		SHA1(S2)=storedDigest(d1))			% 6e,f
       % TODO: 6g,
    THEN OUT_Error(TPM_NOTSEALED_BLOB)					% 6h
    ELSIF not locAtRelease(sealInfo(S2))=localityModifier(s`stanyFlags) % 7biii
    THEN OUT_Error(TPM_BAD_LOCALITY)
    ELSIF not h2=digAtRelease(sealInfo(S2))				% 7c
    THEN OUT_Error(TPM_WRONGPCRVAL)
    % validate authorization to use d1 by checking the HMAC calculation using 
    % authData(d1) as the shared secret matches the ownerAuth(da) TPM_AUTHFAIL 
    % on mismatch     	  	 		    		  	% 8
    % TODO: authdata stuff						% 9
    ELSE let a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
    	     resAuth:=usageAuth(encData(encDat(parent)))#) IN	% TODO: made up
    	 OUT_Unseal(sealedData(d1),a,a,TPM_SUCCESS) 		      % 10,11,12
    ENDIF;
  
  unBind?(k:(tpmKey?)) : bool =
    legacy?(keyUsage(k)) OR bind?(keyUsage(k))				% 3
  
  unBindState(s:tpmAbsState,k:(tpmKey?),d:(encrypted?),a:authIn) : tpmAbsState =
    LET d1=decrypt(d,private(k),s`keys) IN    	   	      	 	% 4  
    IF not unBind?(k) 
    THEN s
    ELSIF not tpmBoundData?(d1) OR
          (not SHA1_MGF1?(encScheme(algoParms(k))) AND			% 5
	       legacy?(keyUsage(k)))
    THEN s WITH [`outData:=cons(d1,outData(s))]
    ELSE s WITH [`outData:=cons(payloadData(d1),outData(s))]
    ENDIF;

  % Output decrypted key
  unBindOut(s:tpmAbsState,k:(tpmKey?),d:(encrypted?),a:authIn):tpmAbsOutput=
    % if inDataSize=0 OUT_Error(TPM_BAD_PARAMETER)			% 1
    % validate the AuthData to use the key pointed to by k		% 2
    LET d1=decrypt(d,private(k),s`keys),     	   	      	 	% 4
    	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#) IN 
    IF not unBind?(k)							% 3
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not tpmBoundData?(d1) OR
          (not SHA1_MGF1?(encScheme(algoParms(k))) AND			% 5
	       legacy?(keyUsage(k)))
    THEN OUT_UnBind(d1,a,TPM_SUCCESS)					% 6,7
    ELSE OUT_UnBind(payloadData(d1),a,TPM_SUCCESS)			% 6,7
    ENDIF  	    

  checkFIPS?(s:tpmAbsState,k:(tpmKey?)) : bool =
    IF s`permFlags`FIPS AND
       	   (%keySize(k) < 1024 OR
    	    never?(authDataUsage(k)) OR
	    legacy?(keyUsage(k)))	
    THEN FALSE
    ELSE TRUE
    ENDIF

  checkKey?(k:(tpmKey?)) : bool = 
    not((storage?(keyUsage(k)) or migrate?(keyUsage(k)))		% 8
    	 AND not RSA?(algoId(algoParms(k)))				% 8i
       )
%     IF (storage?(keyUsage(k)) or migrate?(keyUsage(k)))		% 8
%     	AND not RSA?(algoId(algoParms(k)))				% 8i
%   	  AND not SHA1_MGF1?(encScheme(algoParms(srkParms))) 		% 8ii
%   	  AND not SS_NONE?(sigScheme(algoParms(srkParms))) 		% 8iii
%   	  AND length(parms(algoParms(srkParms)))/=2048 			% 8iv
%   	  AND expSize(parms(algoParms(srkParms)))/=0			% 8v
%     THEN FALSE
%     ELSE TRUE
%     ENDIF

  createWrapKey?(p,k:(tpmKey?)):bool = 
    storage?(keyUsage(p)) AND						% 4
    IF migratable(keyFlags(p)) AND not(migratable(keyFlags(k)))		% 5
    THEN FALSE 
    ELSE IF identity?(keyUsage(k)) OR authChange?(keyUsage(k))		% 6a
    	 THEN FALSE
	 ELSE not(migrateAuthority(keyFlags(k)))			% 6b
	 ENDIF
    ENDIF;

  createWrapKeyState(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsState =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN s
    ELSIF not checkFIPS?(s,k)					% 7
       THEN s
    ELSIF not checkKey?(k)						% 8
       THEN s
    % Determine version of key						% 9
    ELSE LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),		% 10
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)) IN		% 11
	LET h=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(PCRInfo(k)),
			      s`pcrs)) IN				% 15d
	LET encData=encrypt(tpmStoreAsymkey(DU1,			% 14a
	    			IF migratable(keyFlags(k)) THEN DM1	% 14b
				ELSE s`permData`tpmProof ENDIF, 	% 14c
				%TODO: next line is incorrect?
				pubDataDigest(encData(encDat(k))),
				inverse(s`keyGenCnt))
			   ,key(p)),
	    pcrs=tpmPCRInfoLong(s`locality,				% 15e	
				locAtRelease(PCRInfo(k)),		% 15c
				creationPCRSelect(PCRInfo(k)),		% 15c
				releasePCRSelect(PCRInfo(k)),		% 15c
				h,					% 15d
				digAtRelease(PCRInfo(k))) IN		% 15c
    	 genKeyState(s) WITH [`outData:=cons(tpmKey(s`keyGenCnt,
							keyUsage(k),
				    			keyFlags(k),
				    			authDataUsage(k),
				    			algoParms(k),
				    			pcrs,		% 15c
				    			encData),
						outData(s))]
    ENDIF;

  % Generate a NEW RANDOM key pair.
  createWrapKeyOut(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsOutput =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not checkFIPS?(s,k)						% 7
       THEN OUT_Error(TPM_NOTFIPS)
    ELSIF not checkKey?(k)						% 8
       THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    % determine version of key						% 9
    ELSE 
    	 LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),		% 10
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)),		% 11
	     b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 12
			resAuth:=usageAuth(encData(encDat(p)))#) IN
	LET h=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(PCRInfo(k)),
			      s`pcrs)) IN				% 15d
	LET encData=encrypt(tpmStoreAsymkey(DU1,			% 14a
	    			IF migratable(keyFlags(k)) THEN DM1	% 14b
				ELSE s`permData`tpmProof ENDIF, 	% 14c
				%TODO: next line is incorrect?
				pubDataDigest(encData(encDat(k))),
				inverse(s`keyGenCnt))
			   ,key(p)),
	    pcrs=tpmPCRInfoLong(s`locality,				% 15e	
				locAtRelease(PCRInfo(k)),		% 15c
				creationPCRSelect(PCRInfo(k)),		% 15c
				releasePCRSelect(PCRInfo(k)),		% 15c
				h,					% 15d
				digAtRelease(PCRInfo(k))) IN		% 15c
      	   OUT_CreateWrapKey(tpmKey(s`keyGenCnt,			% 13,14
				    keyUsage(k),
				    keyFlags(k),
				    authDataUsage(k),
				    algoParms(k),
				    pcrs,				% 15c
				    encData),
			     b,TPM_SUCCESS)
    ENDIF
    

  validateEncrSigSchemes(k:(tpmKey?)) : bool = 
    validEncScheme(keyUsage(k),encScheme(algoParms(k))) AND 
    validSigScheme(keyUsage(k),sigScheme(algoParms(k)))

  checkKeyUsage(k:(tpmKey?)) : bool = 
    CASES keyUsage(k) OF
      storage : RSA?(algoId(algoParms(k))) AND				% 7gi
	 	     none?(sigScheme(algoParms(k))),			% 7giv
      migrate : RSA?(algoId(algoParms(k))) AND				% 7gi
	 	     none?(sigScheme(algoParms(k))),			% 7giv
      identity: RSA?(algoId(algoParms(k))) AND				% 7hi
	 	     none?(encScheme(algoParms(k)))			% 7hiv
      ELSE TRUE
      ENDCASES
  
  validateKeyConsistency(s:tpmAbsState,p,k:(tpmKey?),e:(tpmStoreAsymkey?)):nat= 
    IF migratable(keyFlags(k))=0 AND
    	 migrationAuth(e)/=tpmProof(permData(s)) 			% 7d
    THEN 4
    ELSIF not validateEncrSigSchemes(k)					% 7e  
    THEN 4				
    ELSIF FIPS(permFlags(s)) AND 
    	  (never?(authDataUsage(k)) OR legacy?(keyUsage(k))) 
    THEN 3								% 7f
    ELSIF not checkKeyUsage(k)						% 7g,h
    THEN 4
    %TODO if pcrInfo(k)=null then set internal indicator key not using pcrs% 7i
    ELSE 0 
    ENDIF

  validateLoadKey2(s:tpmAbsState,p,k:(tpmKey?)) : nat = 
    %Validate cmd & params using ownerAuth(a) and usageAuth(encDat(p))	% 1 
    IF not storage?(keyUsage(p)) 	      	  			% 2  
    THEN 1 	      				
    %If not designed to operate on key type(k) TPM_BAD_KEY_PROPERTY 	% 3
    ELSE LET d1=decrypt(encDat(k),private(p),s`keys) IN  		% 5
    %Reproduce pubDataDigest(encDat(k)) = pubDataDigest(d1)		% 6
    %TODO:IF migratable(keyFlags(k)) THEN verify consistency		% 7a
         CASES keyUsage(k) OF
    	 identity: IF migratable(keyFlags(k))=FALSE			% 7b
	 	   THEN validateKeyConsistency(s,p,k,d1)
	 	   ELSE 1  
		   ENDIF,
	 authChange: 1							% 7c
	 ELSE validateKeyConsistency(s,p,k,d1)
	 ENDCASES
    ENDIF;

  loadKey2?(state:tpmAbsState,p,k:(tpmKey?)) : bool = 
    validateLoadKey2(state,p,k)=0

  %% Install key operation on TPM state.
  loadKey2State(s:tpmAbsState,p,k:(tpmKey?),a:authIn) : tpmAbsState =
    IF validateLoadKey2(s,p,k)=0  
    THEN s with [`keys:=loadKey(k,p,keys(s),pcrs(s))
    	   	,`outData:=cons(k,outData(s))]
    ELSE s
    ENDIF;

  loadKey2Out(s:tpmAbsState,parentH,inKey:(tpmKey?),a:authIn) : tpmAbsOutput = 
    LET num=validateLoadKey2(s,parentH,inKey) IN	      		% 1-7
      COND 
      num=0 -> LET aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN % TODO: resAuth!
		OUT_LoadKey2(inKey,aOut,TPM_SUCCESS),			% 9
	       % TODO: 8,10-12
      num=1 -> OUT_Error(TPM_INVALID_KEYUSAGE),
      num=3 -> OUT_Error(TPM_NOTFIPS),
      ELSE  -> OUT_Error(TPM_FAIL) %TODO: madeup which error message to use
      ENDCOND;


  getPubKey?(s:tpmAbsState,key:(tpmKey?)) : bool = 
    %Validate cmd params using usageAuth(encDat(key)) TPM_AUTHFAIL	% 1a
    never?(authDataUsage(key)) AND s`permFlags`readSRKPub
    AND %pcrInfoSize(key)/=0						% 4
    (pcrIgnoredOnRead(keyFlags(key))					% 4a
    OR dig(digAtRelease(PCRInfo(key)))= 				% 4ai
    	tpmPCRComposite(select(dig(digAtRelease(PCRInfo(key)))),s`pcrs))
  
  getPubKeyState(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsState =
    IF not getPubKey?(s,k)
    THEN s
    ELSE LET pubKey=tpmPubkey(algoParms(k),key(k)) IN
    	 s WITH [`outData:=cons(pubKey,outData(s))]
    ENDIF;

  getPubKeyOut(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsOutput =
    %Validate cmd params using usageAuth(encDat(key)) TPM_AUTHFAIL	% 1a
    IF not never?(authDataUsage(k)) 
    THEN OUT_Error(TPM_AUTHFAIL)					% 2a
    ELSIF not(s`permFlags`readSRKPub)
    THEN OUT_Error(TPM_INVALID_KEYHANDLE)				% 3a	
    ELSIF %pcrInfoSize(key)/=0						% 4
    	  not(pcrIgnoredOnRead(keyFlags(k)))				% 4a
    	  AND dig(digAtRelease(PCRInfo(k)))/=				% 4ai
    	      tpmPCRComposite(select(dig(digAtRelease(PCRInfo(k)))),
			s`pcrs)	
    THEN OUT_Error(TPM_WRONGPCRVAL)
    %TODO: If specified, validate any locality requests			% 4aii
    ELSE LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#),
	     pubKey=tpmPubkey(algoParms(k),key(k)) IN
    	 OUT_GetPubKey(pubKey,aOut,TPM_SUCCESS)				% 5
    ENDIF;
    
%TODO: Sealx   
   sealxState(s:tpmAbsState,k:(tpmKey?),encAuth:(tpmEncAuth?),
	p:(tpmPCRInfoLong?),inData:tpmData,a:authIn) : tpmAbsState

%    sealxOut(s:tpmAbsStatek:(tpmKey?),encAuth:(tpmEncAuth?),p:(tpmPCRInfoLong?),
% 	inData:tpmData,a:authIn) : tpmAbsOutput = 
%    %Validate the authorization to use k					% 1
%    %IF inDataSize=0 THEN OUT_Error(TPM_BAD_PARAMETER)			% 2
%    IF not seal?(k)
%    THEN OUT_Error(TPM_INVALID_KEYUSAGE)					% 3,4
%    ELSE LET h2=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(p),		% 9f
% 				  s`pcrs)) IN
%    	LET S1=tpmStoredData(tpmPCRInfoLong(
% 				s`stanyFlags`localityModifier,		% 9h
% 				locAtRelease(p),			% 9e
% 				creationPCRSelect(p),			% 9b
% 				releasePCRSelect(p),			% 9c
% 				h2,					% 9g
% 				digAtRelease(p)),			% 9d
% 			     tpmNull,					% 6,7
% 			     clear)
% 	LET a1=decryptADIP(encAuth,authHandle(a)),			% 11
% 	    % TODO: 11 a,b, 13
% 	    % TODO: o1=decrypt(,inData)					% 14
% 	    h3=SHA1(S1) IN						% 15c
% 	LET S2=tpmSealedData(a1,					% 10,15e
% 	    		     s`permData`tpmProof,			% 15b
% 			     h3,					% 15d
% 			     o1,					% 15g
% 			     ) IN
% 	LET S3=tpmSealedData(
			     

  checkMigKeyAuth?(s:tpmAbsState,a:(tpmMigKeyAuth?)):bool =		% 5
    digest(a)=SHA1(concat(key(a),concat(scheme(a),s`permData`tpmProof)))
  
  createMigBlob?(s:tpmAbsState,p:(tpmKey?),m:(tpmMigScheme?),
	a:(tpmMigKeyAuth?),e:(encrypted?)) : bool = 
    storage?(keyUsage(p)) AND						% 2
    LET d1=decrypt(e,private(p),s`keys) IN				% 3
    tpmStoreAsymkey?(d1) AND						% 3
    checkMigKeyAuth?(s,a) AND						% 5
    CASES migScheme(m) OF
    	  migrate : TRUE,
	  rewrap  : TRUE
	  ELSE FALSE							% 8
    ENDCASES	

  createMigBlobState(s:tpmAbsState,p:(tpmKey?),migType:(tpmMigScheme?),
	mKeyAuth:(tpmMigKeyAuth?),encData:(encrypted?),a1,a2:authIn) :
	tpmAbsState = 
    LET d1=decrypt(encData,private(p),s`keys) IN			% 3
    IF createMigBlob?(s,p,migType,mKeyAuth,encData)
    THEN CASES migScheme(migType) OF
	       migrate: LET K1=privKey(d1),				% 6ai
	       		    K2=privKey(d1) IN				% 6aii
				% only supposed to be part of private key... 
	       		LET M1=tpmMigrateAsymkey(
				        usageAuth(d1),			% 6bii
					pubDataDigest(d1),		% 6biii
					K2) IN				% 6bv
			LET o1=OAEP(M1,migrationAuth(d1),K1),		% 6c
			    r1=RNG(s`randCnt) IN			% 6d
			LET x1=encrypt(tpmXOR(o1,r1)			% 6e
				      ,key(key(mKeyAuth))) IN 		% 6g
    	 		randState(s) WITH 
				[`outData:=cons(r1,cons(x1,outData(s)))],% 6f
	       rewrap : s WITH [`outData:=cons(encrypt(d1,key(key(mKeyAuth))),
					   cons(RNG(0),outData(s)))]	% 7
	       ELSE s							% 8
	 ENDCASES
    ELSE s
    ENDIF;

  createMigBlobOut(s:tpmAbsState,p:(tpmKey?),migType:(tpmMigScheme?),
	mKeyAuth:(tpmMigKeyAuth?),encData:(encrypted?),a1,a2:authIn) :
	tpmAbsOutput =
    %TODO: Validate ownerAuth(a1) authorizes use of p			% 1
    LET d1=decrypt(encData,private(p),s`keys),				% 3
    	ao1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(p)))#),
    	ao2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(key(mKeyAuth))))#) IN
    IF not storage?(keyUsage(p))       	      				% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not tpmStoreAsymkey?(d1)					% 3
    THEN OUT_Error(TPM_BAD_MIGRATION) %TODO: made up which error to use
    %Validate ownerAuth(a2) authorizes migration of d1, 		% 4
    % 	   	 must use migrationAuth(d1) as secret.
    ELSIF not checkMigKeyAuth?(s,mKeyAuth)				% 5
    THEN OUT_Error(TPM_AUTHFAIL)
    ELSE CASES migScheme(migType) OF
	       migrate: LET K1=privKey(d1),				% 6ai
	       		    K2=privKey(d1) IN				% 6aii
				% only supposed to be part of private key... 
	       		LET M1=tpmMigrateAsymkey(
				        usageAuth(d1),			% 6bii
					pubDataDigest(d1),		% 6biii
					K2) IN				% 6bv
			LET o1=OAEP(M1,migrationAuth(d1),K1),		% 6c
			    r1=RNG(s`randCnt) IN			% 6d
			LET x1=encrypt(tpmXOR(o1,r1)			% 6e
				      ,key(key(mKeyAuth))) IN 		% 6g
			OUT_CreateMigrationBlob(r1,			% 6f
				x1,
				ao1,ao2,
				TPM_SUCCESS),
	       rewrap : OUT_CreateMigrationBlob(RNG(0),			% 7b
				encrypt(d1,key(key(mKeyAuth))),		% 7a
				ao1,ao2,
				TPM_SUCCESS)
	       ELSE OUT_Error(TPM_BAD_PARAMETER)			% 8
	 ENDCASES
    ENDIF
	 
  convertMigBlob?(s:tpmAbsState,p:(tpmKey?),d:(encrypted?),r:(RNG?)) : bool =
    storage?(keyUsage(p)) AND
    LET d1=decrypt(d,private(p),s`keys) IN				% 3
    LET o1=unXOR(d1,r) IN						% 4
    LET m1=OAEPdecode(o1),%TODO: seed,pHash				% 5
	pHash:(tpmSecret?)=tpmSecret(1) IN 
    LET k1:privKVAL=partPrivKey(m1) IN %TODO:combine seed		% 6
    	tpmMigrateAsymkey?(m1) 		    		  		% 7a


  convertMigBlobState(s:tpmAbsState,parent:(tpmKey?),inData:(encrypted?),
	rand:(RNG?),a:authIn) : tpmAbsState =
    LET d1=decrypt(inData,private(parent),s`keys) IN			% 3
    IF not convertMigBlob?(s,parent,inData,rand) 
    THEN s
    ELSE LET o1=unXOR(d1,rand) IN					% 4
    	 LET m1=OAEPdecode(o1),						% 5
	     pHash:(tpmSecret?)=tpmSecret(1) IN
	 LET k1:privKVAL=partPrivKey(m1) IN %TODO:combine seed		% 6
	 	 IF not tpmMigrateAsymkey?(m1)
	 THEN s
	 ELSE LET d2=encrypt(tpmStoreAsymkey(%TPM_PT_ASYM,		% 7b
	     			usageAuth(m1),				% 7c
				pHash,					% 7d
				pubDataDigest(m1),			% 7e
				k1),					% 7f
			  key(parent)) IN 				% 8
	      s WITH [`outData:=cons(d2,outData(s))]
ENDIF
    ENDIF;

  convertMigBlobOut(s:tpmAbsState,parent:(tpmKey?),inData:(encrypted?),
	rand:(RNG?),a:authIn) : tpmAbsOutput =
    % TODO: Validate authData to use key in parent			% 1
    LET d1=decrypt(inData,private(parent),s`keys),			% 3
    	aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(parent)))#) IN
    IF not storage?(keyUsage(parent))					% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSE LET o1=unXOR(d1,rand) IN					% 4
	 LET m1=OAEPdecode(o1),%TODO: seed,pHash			% 5
	     pHash:(tpmSecret?)=tpmSecret(1) IN %TODO
 	 LET k1:privKVAL=partPrivKey(m1) IN %TODO:combine seed		% 6
 	 IF not tpmMigrateAsymkey?(m1) 		    		  	% 7a
 	 THEN OUT_Error(TPM_BAD_MIGRATION) %TODO: made up which error
	 ELSE LET d2=encrypt(tpmStoreAsymkey(%TPM_PT_ASYM,		% 7b
	     			usageAuth(m1),				% 7c
				pHash,					% 7d
				pubDataDigest(m1),			% 7e
				k1),					% 7f
			  key(parent)), 				% 8
	          aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
				contAuthSess:=TRUE,
				resAuth:=usageAuth(encData(encDat(parent)))#) IN
	      OUT_ConvertMigrationBlob(d2,aOut,TPM_SUCCESS)
	 ENDIF
    ENDIF
    
  authorizeMigKeyState(s:tpmAbsState,migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : tpmAbsState = 
    s WITH [`outData:=cons(tpmMigKeyAuth(migKey,			% 3,5
				migScheme,				% 6
				SHA1(concat(migKey,
					concat(migScheme,
						s`permData`tpmProof)))	% 7,8,9
				),
			outData(s))]
  
  authorizeMigKeyOut(s:tpmAbsState,migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : tpmAbsOutput = 
    % Check cryptographic strength of migrationKey >=2048RSA		% 1
    % Validate authdata to use the TPM by the TPM owner			% 2
%     IF TODO: not MGF1?(encScheme(algoParms(migKey)))	  		% 4
%     THEN OUT_Error(TPM_INAPPROPRIATE_ENC)
%     ELSE 
    	 OUT_AuthorizeMigrationKey(
		tpmMigKeyAuth(migKey,					% 3,5
			migScheme,					% 6
			SHA1(concat(migKey,
				concat(migScheme,s`permData`tpmProof))) % 7,8,9
		),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(a)#),
		TPM_SUCCESS)
%     ENDIF;

  migrateKey?(m:(tpmKey?)) : bool =
  	migrate?(keyUsage(m)) AND SHA1_MGF1?(encScheme(algoParms(m)))

  migrateKeyState(s:tpmAbsState,m,p:(tpmKey?),d:(encrypted?),a:authIn) : 
  	tpmAbsState =
    LET d1=decrypt(d,private(m),s`keys) IN
    IF not migrateKey?(m) 
    THEN s
    ELSE s WITH [`outData:=cons(encrypt(d1,key(p)),outData(s))]		% 4
    ENDIF;

  %% Decrypts the input packet (coming from TPM_CreateMigrationBlob) and then 
  %% re-encrypts it with the input public key. The output would then be sent to 
  %% TPM_ConvertMigrationBlob on the target TPM.
  migrateKeyOut(s:tpmAbsState,m,p:(tpmKey?),d:(encrypted?),a:authIn) : 
  	tpmAbsOutput =
    LET d1=decrypt(d,private(m),s`keys) IN 
    % Validate ownerAuth(a) authorizes use of m			  	% 1
    IF not migrate?(keyUsage(m))       	      				% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not SHA1_MGF1?(encScheme(algoParms(m)))			% 2
    THEN OUT_Error(TPM_INAPPROPRIATE_ENC)
    ELSE LET d1=decrypt(d,private(m),s`keys) IN
    	 OUT_MigrateKey(encrypt(d1,key(p)),				% 4
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(m)))#),
		TPM_SUCCESS)
    ENDIF

  CMKSetRestr?(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : bool =
    %permData(restrictDelegate) is used as follows:
    %sessionType = TPM_PID_DSAP AND			    		% 1
%        migrateAuthority(keyFlags(_)) %TODO: WHICH KEY?
%        AND (signing?(keyUsage(_)) AND r(delegateSigning)) OR	% 1a
%            (storage?(keyUsage(_)) AND r(delegateStorage)) OR
%            (bind?(keyUsage(_)) AND r(delegateBind)) OR
% 	   (legacy?(keyUsage(_)) AND r(delegateLegacy)) OR
% 	   (migrate?(keyUsage(_)) AND r(delegateMigrate))
	   TRUE;


  CMKSetRestrState(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : tpmAbsState =
    IF CMKSetRestr?(s,r,i)
    THEN %key can be used
    	 %Validate ordinal and parameters using TPM Owner authentication
	 %on error, OUT_Error(TPM_AUTHFAIL)
	 s WITH [`permData(restrictDelegate):=r]			% 2
    ELSE s
    ENDIF;

  CMKSetRestrOut(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : tpmAbsOutput =
    IF CMKSetRestr?(s,r,i)
    THEN %key can be used
    	 %TODO Validate ordinal and parameters using TPM Owner authentication
	 %on error, OUT_Error(TPM_AUTHFAIL)				% 1
	 LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i)#) IN
	 OUT_CMK_SetRestrictions(a,TPM_SUCCESS)				% 3
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF;

  CMKApproveMAState(s:tpmAbsState,migAuth:(tpmDigest?),i:authIn) : tpmAbsState =
    LET M2=tpmCMKMAApproval(migAuth) IN	     	 			% 2
    s WITH [`outData:=cons(tpmHMAC(M2,s`permData`tpmProof),outData(s))]

  CMKApproveMAOut(s:tpmAbsState,migAuth:(tpmDigest?),i:authIn) : tpmAbsOutput = 
    %TODO Validate AuthDat to use the TPM by TPM Owner			% 1
    LET M2=tpmCMKMAApproval(migAuth),	     	 			% 2
	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(i)#) IN
    OUT_CMK_ApproveMA(tpmHMAC(M2,s`permData`tpmProof),a,TPM_SUCCESS);	% 3

  validateMigrateAuthority?(s:tpmAbsState,m,a:(tpmDigest?)) : bool =
    LET M1=tpmCMKMAApproval(m) IN					% 8ai
    a=tpmHMAC(M1,s`permData`tpmProof)					% 8b

  validateKeyParams?(k:(tpmKey?)) : bool =
    not(identity?(keyUsage(k)) or authChange?(keyUsage(k)))		% 9

  CMKCreateKey?(s:tpmAbsState,p:(tpmKey?),k:(tpmKey?),m,a:(tpmDigest?)) : bool =
    storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND		% 4,5
    migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k))		% 6,7
    AND validateMigrateAuthority?(s,m,a) 				% 8  
    AND validateKeyParams?(k)						% 9
    AND checkFIPS?(s,k)							% 10
    AND checkKey?(k)							% 11

  CMKCreateKeyState(s:tpmAbsState,p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
    a:(tpmDigest?),m:(tpmDigest?),i:authIn) : tpmAbsState = 
    IF not CMKCreateKey?(s,p,k,m,a)
    THEN s
    ELSE LET DU1=decryptADIP(d,authHandle(i)),				% 14
	     pcr=tpmPCRInfoLong(s`stanyFlags`localityModifier,		% 18d
				locAtRelease(PCRInfo(k)), 
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				tpmCompositeHash(
					tpmPCRComposite(creationPCRSelect(
								PCRInfo(k)),
							s`pcrs)),	% 18c
				digAtRelease(PCRInfo(k))),
	     M2=tpmCMKMigAuth(m,					% 17di
             		      SHA1(tpmPubkey(algoParms(k),key(k)))) IN	% 17dii
	 LET enc=encrypt(tpmStoreAsymkey(DU1,				% 17a
	     			%tpmHMAC(M2,s`permData`tpmProof),	% 17e
 				tpmSecret(1),
% 				%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				pubDataDigest(encData(encDat(k))),
				private(k))
			   ,key(p)) IN					% 19
    	 LET wrappedKey=tpmKey(key(k),					% 13,17
	     		       keyUsage(k),
			       keyFlags(k),
			       authDataUsage(k),
			       algoParms(k),
			       pcr,					% 18
			       enc) IN
    	 s WITH [`outData:=cons(wrappedKey,outData(s))]
    ENDIF

  CMKCreateKeyOut(s:tpmAbsState,p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
    a:(tpmDigest?),m:(tpmDigest?),i:authIn) : tpmAbsOutput = 
    %TODO: Validate AuthData to use key pointed to by p. OUT_Error(TPM_AUTHFAIL)
    % Validate session type for p is OSAP				% 2
    % IF TPM not designed to create key of type requested in k, OUT_ERROR(TPM_BAD_KEY_PROPERTY) % 3
    IF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND	% 4,5
    migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k)))		% 6,7
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not(validateMigrateAuthority?(s,m,a))				% 8
    THEN OUT_Error(TPM_MA_AUTHORITY)
    ELSIF not(validateKeyParams?(k))					% 9
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				
    ELSIF not(checkFIPS?(s,k))						% 10
    THEN OUT_Error(TPM_NOTFIPS)
    ELSIF not(checkKey?(k))						% 11
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    %TODO 12
    ELSE LET DU1=decryptADIP(d,authHandle(i)),				% 14
    	     ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 15
			resAuth:=usageAuth(encData(encDat(p)))#),
	     pcr=tpmPCRInfoLong(s`stanyFlags`localityModifier,		% 18d
				locAtRelease(PCRInfo(k)), 
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				tpmCompositeHash(
					tpmPCRComposite(creationPCRSelect(
							PCRInfo(k)),
						s`pcrs)),		% 18c
				digAtRelease(PCRInfo(k))),
	     M2=tpmCMKMigAuth(m,					% 17di
             		      SHA1(tpmPubkey(algoParms(k),key(k)))) IN	% 17dii
	 LET enc=encrypt(tpmStoreAsymkey(DU1,				% 17a
	     			%tpmHMAC(M2,s`permData`tpmProof),	% 17e
 				tpmSecret(1),
% 				%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				pubDataDigest(encData(encDat(k))),
				private(k))
			   ,key(p)) IN					% 19
    	 LET wrappedKey=tpmKey(key(k),					% 13,17
	     		       keyUsage(k),
			       keyFlags(k),
			       authDataUsage(k),
			       algoParms(k),
			       pcr,					% 18
			       enc) IN
	 OUT_CMK_CreateKey(wrappedKey,ao,TPM_SUCCESS)
    ENDIF;

  validateKeyAlgo?(k:(tpmPubkey?)) : bool = 
    RSA?(algoId(algoParms(k)))
       %AND NONE?(encScheme(algoParms(verifKey)))
       %AND (SHA1?(sigScheme(algoParms(verifKey))) OR 
       % INFO?(sigScheme(algoParms(verifKey))))
  
  CMKCreateTicket?(k:(tpmPubkey?),signedData:(tpmDigest?)) : bool = 
    validateKeyAlgo?(k) AND
    checkSig?(pubKey(k),signedData)
    
  CMKCreateTicketState(s:tpmAbsState,verifKey:(tpmPubkey?)
    ,signedData:(tpmDigest?),sigVal:tpmData,i:authIn) : tpmAbsState = 
    IF not CMKCreateTicket?(verifKey,signedData)
    THEN s
    ELSE LET M2=tpmCMKSigTicket(SHA1(verifKey),signedData) IN		% 4
    	 s WITH [`outData:=cons(tpmHMAC(M2,s`permData`tpmProof),outData(s))]
    ENDIF;
    
  CMKCreateTicketOut(s:tpmAbsState,verifKey:(tpmPubkey?),signedData:(tpmDigest?)
    ,sigVal:tpmData,i:authIn) : tpmAbsOutput = 
    %TODO Validate Owner authentication					% 1
    IF not(validateKeyAlgo?(verifKey))					% 2
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)	%TODO: CHECK
    ELSIF not(checkSig?(pubKey(verifKey),signedData))			% 3
    THEN OUT_Error(TPM_BAD_SIGNATURE)
    ELSE LET M2=tpmCMKSigTicket(SHA1(verifKey),signedData),		% 4
    	     a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,%TODO: FLAG?
			resAuth:=ownerAuth(i)#) IN%TODO: CHANGED... DOUBLE CHECK
    	 OUT_CMK_CreateTicket(tpmHMAC(M2,s`permData`tpmProof),a,TPM_SUCCESS)%5,6
    ENDIF;


  CMKCreateBlob?(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      encData:(encrypted?)) : bool =
    LET d1=decrypt(encData,private(p),s`keys),				% 4
    	M2=tpmCMKMigAuth(SHA1(msaList),psk) IN				% 7a
    % Validate i authorizes use of key pointed to by p			% 1
    IF t=scheme(mkAuth)
    THEN FALSE								% 2
    ELSIF migratable(keyFlags(p))=TRUE
    THEN FALSE								% 3
    % Verify digest within mkAuth is legal for ths tpm and public key	% 5
    % Verify d1->payload = Migrate_restricted or migrate_external 	% 6
    % Verify mig authorities in msaList are authorized to migrate this key % 7
    ELSIF migrationAuth(d1)/=tpmHMAC(M2,s`permData`tpmProof)
    THEN FALSE								% 7b
    ELSE CASES migScheme(scheme(mkAuth)) OF
    	   restrictMigrate: 						% 8
	      %Verify intended migration destination is MA:
	      %IF member(SHA1(key(mkAuth)),migAuthDigest(msaList))	% 8a
	      %   RSA?(algoId(algoParms(key(mkAuth)))) 			% 8bi
	      %TODO							% 8biii
	      TRUE,
    	   restrictApprove:						% 9
	      %TODO: 9i
	      % LET V1=tpmCMKSigTicket(migAuthDigest(msaList),SHA1(resTic)
	      %IF member(,migAuthDigest(msaList)) 
	      %OUT_Error(TPM_MA_DESTINATION) OUT_Error(TPM_MA_SOURCE)
	      TRUE
	   ELSE FALSE							% 10
    	 ENDCASES
    ENDIF;

   
  CMKCreateBlobOut2(s:tpmAbsState,p:(tpmKey?),mkAuth:(tpmMigKeyAuth?),
      psk:(tpmDigest?),msaList:(tpmMSAComposite?),d1:(tpmStoreAsymkey?),
      i:authIn) : tpmAbsOutput =
    LET K1=privKey(d1),							% 11a
    	K2=privKey(d1) IN						% 11b
    LET M1=tpmMigrateAsymkey(usageAuth(d1),				% 12b
    			pubDataDigest(d1),				% 12c
			K2) IN						% 12e
    LET o1=OAEP(M1,							% 13a
		SHA1(concat(SHA1(msaList),psk)),			% 13b
		K1),							% 13c
        r1=RNG(s`randCnt) IN						% 14
    LET x1=tpmXOR(o1,r1),						% 15
    	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,%TODO: FLAG?
			resAuth:=usageAuth(encData(encDat(p)))#) IN
        OUT_CMK_CreateBlob(r1,						% 16
		encrypt(x1,key(key(mkAuth))),a,TPM_SUCCESS)		% 17
		
  CMKCreateBlobState(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      resTic:(tpmCMKAuth?),sigTic:(tpmDigest?),encData:(encrypted?),
      i:authIn) : tpmAbsState =
    LET d1=decrypt(encData,private(p),s`keys) IN
    IF CMKCreateBlob?(s,p,t,mkAuth,psk,msaList,encData)
    THEN LET a=CMKCreateBlobOut2(s,p,mkAuth,psk,msaList,d1,i) IN
    	 CASES a OF
	   OUT_CMK_CreateBlob(r,e,o1,m) : 
	   	randState(s) WITH [`outData:=cons(r,cons(e,outData(s)))]
	   ELSE s
	 ENDCASES
    ELSE s
    ENDIF;

  CMKCreateBlobOut(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      resTic:(tpmCMKAuth?),sigTic:(tpmDigest?),encData:(encrypted?),
      i:authIn) : tpmAbsOutput =
    LET d1=decrypt(encData,private(p),s`keys),				% 4
    	M2=tpmCMKMigAuth(SHA1(msaList),psk) IN				% 7a
    % TODO:
    % Validate i authorizes use of key pointed to by p			% 1
    IF t=scheme(mkAuth)							% 2
    THEN OUT_Error(TPM_BAD_MODE)
    ELSIF migratable(keyFlags(p))=TRUE					% 3
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    % TODO:
    % Verify digest within mkAuth is legal for ths tpm and public key	% 5
    % Verify d1->payload = Migrate_restricted or migrate_external 	% 6
    % Verify mig authorities in msaList are authorized to migrate this key % 7
    ELSIF migrationAuth(d1)/=tpmHMAC(M2,s`permData`tpmProof)
    THEN OUT_Error(TPM_MA_AUTHORITY)					% 7b
    ELSE CASES migScheme(scheme(mkAuth)) OF
    	   restrictMigrate: 						% 8
    	      % TODO:
	      %Verify intended migration destination is MA:
	      %IF member(SHA1(key(mkAuth)),migAuthDigest(msaList))	% 8a
	      %   RSA?(algoId(algoParms(key(mkAuth)))) 			% 8bi
	      %TODO							% 8biii
	      CMKCreateBlobOut2(s,p,mkAuth,psk,msaList,d1,i),
    	   restrictApprove:						% 9
	      %TODO: 9i
	      % LET V1=tpmCMKSigTicket(migAuthDigest(msaList),SHA1(resTic)
	      %IF member(,migAuthDigest(msaList)) 
	      %OUT_Error(TPM_MA_DESTINATION) OUT_Error(TPM_MA_SOURCE)
	      CMKCreateBlobOut2(s,p,mkAuth,psk,msaList,d1,i)
	   ELSE OUT_Error(TPM_BAD_PARAMETER)				% 10
    	 ENDCASES
    ENDIF;

  CMKConvertMigration?(s:tpmAbsState,p:(tpmKey?),r:(tpmCMKAuth?),m:(tpmKey?),
	l:(tpmMSAComposite?),o1:(OAEP?)) : bool =
    LET m1:(tpmMigrateAsymkey?)=OAEPdecode(o1),				% 5
	migratedPubKey=tpmPubkey(algoParms(m),key(m)) IN		% 6
    LET k1=partPrivKey(m1), %todo: should be seed & partprivkey		% 7
        M2=tpmCMKMigAuth(SHA1(l),SHA1(migratedPubKey)) IN		% 18
    LET d2=encrypt(tpmStoreAsymkey(usageAuth(m1),		     	% 8b
			%HMAC(M2,s`permData`tpmProof),			% 19
			tpmSecret(1),
			%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
			pubDataDigest(m1),k1)				% 8c,a
		   ,key(p)),						% 20
        parentPubKey=tpmPubkey(algoParms(p),key(p)) IN		   	% 12
    storage?(keyUsage(p)) AND						% 2
    pHash(o1)=SHA1(concat(SHA1(l),SHA1(migratedPubKey))) AND		% 6
    not(migratable(keyFlags(p))) AND				        % 9
    tpmMigrateAsymkey?(m1) AND	 					% 10
    destKey(r)=SHA1(parentPubKey) AND					% 13
    (private(m)=privKey(encData(d2)) AND
     pubDataDigest(encData(encDat(m)))=pubDataDigest(encData(d2)) AND
     usageAuth(encData(encDat(m)))=usageAuth(encData(d2))) AND		% 14
    migratable(keyFlags(m)) AND						% 15
    migrateAuthority(keyFlags(m)) AND					% 16
    sourceKey(r)=SHA1(migratedPubKey)					% 17

  CMKConvertMigrationState(s:tpmAbsState,p:(tpmKey?),resTic:(tpmCMKAuth?),
      sigTic:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),rand:(RNG?),
      i:authIn) : tpmAbsState =
    LET d1=decrypt(encDat(mk),private(p),s`keys) IN  			% 3
    LET o1=unXOR(d1,rand) IN    					% 4
    IF not CMKConvertMigration?(s,p,resTic,mk,msaList,o1)
    THEN s
    ELSE LET m1:(tpmMigrateAsymkey?)=OAEPdecode(o1),%TODO 		% 5
	          migratedPubKey=tpmPubkey(algoParms(mk),key(mk)) IN	% 6
    	 LET k1=partPrivKey(m1), %todo: should be seed & partprivkey	% 7
             M2=tpmCMKMigAuth(SHA1(msaList),SHA1(migratedPubKey)) IN	% 18
    	 LET d2=encrypt(tpmStoreAsymkey(usageAuth(m1),		  	% 8b
					%HMAC(M2,s`permData`tpmProof),	% 19
					tpmSecret(1),
					%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
					pubDataDigest(m1),k1),		% 8c,a
		   		key(p)) IN				% 20
	     s WITH [`outData:=cons(d2,outData(s))]
    ENDIF;

  CMKConvertMigrationOut(s:tpmAbsState,p:(tpmKey?),resTic:(tpmCMKAuth?),
      sigTic:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),rand:(RNG?),
      i:authIn) : tpmAbsOutput =
    %TODO: Validate authdata to use key in p				% 1
    LET d1=decrypt(encDat(mk),private(p),s`keys) IN  			% 3
    LET o1=unXOR(d1,rand) IN    					% 4
    LET m1:(tpmMigrateAsymkey?)=OAEPdecode(o1),%TODO 			% 5
	migratedPubKey=tpmPubkey(algoParms(mk),key(mk)) IN		% 6
    LET k1=partPrivKey(m1), %todo: should be seed & partprivkey		% 7
        M2=tpmCMKMigAuth(SHA1(msaList),SHA1(migratedPubKey)) IN		% 18
    LET d2=encrypt(tpmStoreAsymkey(usageAuth(m1),		     	% 8b
				%HMAC(M2,s`permData`tpmProof),		% 19
				tpmSecret(1),
				%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				pubDataDigest(m1),k1),			% 8c,a
		   key(p)) IN						% 20
    LET parentPubKey=tpmPubkey(algoParms(p),key(p)) IN			% 12
    	IF not(storage?(keyUsage(p)))					% 2
    	THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    	ELSIF pHash(o1)/=
			SHA1(concat(SHA1(msaList),SHA1(migratedPubKey)))% 6a
    	THEN OUT_Error(TPM_SHA_ERROR) %TODO
    	ELSIF migratable(keyFlags(p))					% 9
    	THEN  OUT_Error(TPM_BAD_KEY_PROPERTY)
    	ELSIF not tpmMigrateAsymkey?(m1)	
	THEN OUT_Error(TPM_BAD_MIGRATION) %TODO: made up which error	% 10
    	% TODO 11
    	ELSIF destKey(resTic)/=SHA1(parentPubKey)			% 13
    	THEN OUT_Error(TPM_MA_DESTINATION)
    	ELSIF not(private(mk)=privKey(encData(d2)) AND
    	       	  pubDataDigest(encData(encDat(mk)))=
				pubDataDigest(encData(d2)) AND
		  usageAuth(encData(encDat(mk)))=
				usageAuth(encData(d2)))			% 14
    	THEN OUT_Error(TPM_BAD_KEY_PROPERTY) %TODO
    	ELSIF not(migratable(keyFlags(mk))) OR				% 15
    	       	   not(migrateAuthority(keyFlags(mk)))			% 16
    	THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    	ELSIF sourceKey(resTic)/=SHA1(migratedPubKey)			% 17
    	THEN OUT_Error(TPM_MA_SOURCE)
    	ELSE LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(p)))#) IN % TODO
		  OUT_CMK_ConvertMigration(d2,a,TPM_SUCCESS)
    	ENDIF;

  %% Cryptographic Functions (13)
  SHA1CompleteState(s:tpmAbsState,hd:tpmData) : tpmAbsState =
    s WITH [`outData:=cons(SHA1(hd),outData(s))];

  SHA1CompleteOut(hd:tpmData) : tpmAbsOutput =
    OUT_SHA1Complete(SHA1(hd),TPM_SUCCESS)

  SHA1CompleteExtend?(s:tpmAbsState,p:PCRINDEX,inDigest:tpmData) : bool =
    LET L1=s`stanyFlags`localityModifier,
    	P1=pcrExtendLocal(s`permData`pcrAttrib(p)) IN
    (0<=p<=23) AND member(L1,P1);

  SHA1CompleteExtendState(s:tpmAbsState,p:PCRINDEX,hd:tpmData) : tpmAbsState =
    IF SHA1CompleteExtend?(s,p,hd)
    THEN LET H1:HV=mleHash IN %TODO
    	 s WITH [`pcrs := pcrsExtend(pcrs(s),p,H1)
	   	,`outData:=cons(tpmPCRValue(extend(s`pcrs(p),H1)),
				cons(SHA1(hd),outData(s)))]
    ELSE s
    ENDIF

  SHA1CompleteExtendOut(s:tpmAbsState,p:PCRINDEX,hd:tpmData) : tpmAbsOutput =
    IF 0<=p<=23
    THEN LET L1=s`stanyFlags`localityModifier,				% 7
             P1=pcrExtendLocal(s`permData`pcrAttrib(p)) IN
    	 IF not member(L1,P1)						% 8
	 THEN OUT_Error(TPM_BAD_LOCALITY)
	 ELSE LET H1:HV=mleHash IN %TODO				% 9
	      OUT_SHA1CompleteExtend(SHA1(hd),
			tpmPCRValue(extend(s`pcrs(p),H1)),		% 10
			TPM_SUCCESS)
	 ENDIF
    ELSE OUT_Error(TPM_BADINDEX)
    ENDIF

  sign?(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : bool = 
    signing?(keyUsage(key)) OR legacy?(keyUsage(key))

  signState(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : tpmAbsState=
    IF not sign?(s,key,areaToSign)
    THEN s
    ELSE s WITH[`outData:=cons(sign(areaToSign,private(key),s`keys),outData(s))]
    ENDIF;

  % Sign a blob if signing key isn't aik
  % TODO: add signature scheme (makes this more complicated) CHECK WITH SPEC
  signOut(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : tpmAbsOutput=
    IF signing?(keyUsage(key)) OR legacy?(keyUsage(key)) 
    THEN OUT_Sign(sign(areaToSign,private(key),s`keys),TPM_SUCCESS)
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF;

  getRandomState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`outData:=cons(RNG(s`randCnt),outData(s))];

  getRandomOut(s:tpmAbsState) : tpmAbsOutput = 
    OUT_GetRandom(RNG(s`randCnt),TPM_SUCCESS);


  stirRandomState(s:tpmAbsState,inData:nat) : tpmAbsState = 
    s WITH [`randCnt:=randCnt(s)+inData]

  stirRandomOut(s:tpmAbsState,inData:int) : tpmAbsOutput = 
    %If size(inData)>=256 OUT_Error(TPM_BAD_PARAMETER)
    OUT_StirRandom(TPM_SUCCESS);


  certifyKey?(s:tpmAbsState,c,k:(tpmKey?)) : bool = 
    IF identity?(keyUsage(c)) AND migratable(keyFlags(c))
    THEN FALSE					% 4a
    ELSIF not(signing?(keyUsage(c)) OR identity?(keyUsage(c)) OR
    	  	legacy?(keyUsage(c)))
    THEN FALSE				% 5
    ELSIF not(signing?(keyUsage(k)) OR storage?(keyUsage(k)) OR
    	  	identity?(keyUsage(k)) OR bind?(keyUsage(k)) OR
		legacy?(keyUsage(k)))
    THEN FALSE				% 6
    %TODO: Version 							% 7,8
    % pcrInfoSize(key)=0 => PCRInfo(k)=pcrInfoNull			% 9/10
    ELSIF pcrIgnoredOnRead(keyFlags(k))=FALSE				% 9a
    THEN LET dAR=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(PCRInfo(k)),
				   s`pcrs)) IN
	 IF dAR/=digAtRelease(PCRInfo(k))				% 9ai
	 THEN FALSE	
	 ELSE %If specified, validate any locality requests 
	      % On error OUT_Error(TPM_BAD_LOCALITY)			% 9aii
	      true				% 9b
	 ENDIF
    ELSE true					% 9b
    ENDIF

  certifyKeyOut2(c,k:(tpmKey?),ar:(tpmNonce?),i1,i2:authIn) : tpmAbsOutput =
    CASES k OF
      tpmKey(k,u,f,ad,al,p,e) : 
	LET H1=SHA1(k) IN %TODO						% 11
	LET C1=tpmCertifyInfo(u,f,ad,al,				% 9c
				H1,					% 12
				ar,					% 13
				FALSE,%TODO!				
				p) IN				    % 9civ,10
       LET m1=SHA1(C1),			 				% 15 
           o1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(c)))#), % TODO
           o2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#) IN %TODO
       OUT_CertifyKey(C1,signed(m1,private(c)),	%TODO FIX		% 14
			o1,o2,TPM_SUCCESS)
    ENDCASES

  certifyKeyState(s:tpmAbsState,c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) :
  	tpmAbsState = 
    IF not certifyKey?(s,c,k)
    THEN s
    ELSE LET out=certifyKeyOut2(c,k,n,i1,i2) IN
         CASES out OF
         OUT_CertifyKey(c,od,o1,o2,m) : 
       		s WITH [`outData:=cons(c,cons(od,outData(s)))]
         ENDCASES
    ENDIF

  certifyKeyOut(s:tpmAbsState,c,k:(tpmKey?),ar:(tpmNonce?),i1,i2:authIn) : 
  	tpmAbsOutput = 
    %TODO: Verify c has sig scheme of _SHA1 or _INFO			% 1
    %TODO: Verify command and key AuthData values			% 2
    %TODO: If not asym?(payload(k)) THEN OUT_ERROR(TPM_INVALID_KEYUSAGE)% 3
    IF identity?(keyUsage(c)) AND migratable(keyFlags(c))
    THEN OUT_Error(TPM_MIGRATEFAIL)					% 4a
    ELSIF not(signing?(keyUsage(c)) OR identity?(keyUsage(c)) OR
    	  	legacy?(keyUsage(c)))
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 5
    ELSIF not(signing?(keyUsage(k)) OR storage?(keyUsage(k)) OR
    	  	identity?(keyUsage(k)) OR bind?(keyUsage(k)) OR
		legacy?(keyUsage(k)))
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 6
    %TODO: Version 							% 7,8
    % pcrInfoSize(key)=0 => PCRInfo(k)=pcrInfoNull			% 9/10
    ELSIF pcrIgnoredOnRead(keyFlags(k))=FALSE				% 9a
    THEN LET dAR=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(PCRInfo(k)),
				   s`pcrs)) IN
	 IF dAR/=digAtRelease(PCRInfo(k))				% 9ai
	 THEN OUT_Error(TPM_WRONGPCRVAL)	
	 ELSE %If specified, validate any locality requests 
	      % On error OUT_Error(TPM_BAD_LOCALITY)			% 9aii
	      certifyKeyOut2(c,k,ar,i1,i2)				% 9b
	 ENDIF
    ELSE certifyKeyOut2(c,k,ar,i1,i2)					% 9b
    ENDIF

  createEKPairState(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?)) : tpmAbsState = 
    IF goodkey?(key(ek(s)))				       		% 1
    THEN s
    ELSE s WITH [`ek:=k							% 5
%     	   	,`permData(tpmDAASeed):=rand				% 6
% 		,`permData(daaProof):=rand				% 7
% 		,`permData(daaBlobKey):=rand				% 8
    	   	,`permFlags(CEKPUsed):=TRUE				% 9
		,`permFlags(enableRevokeEK):=FALSE			% 10
		,`outData:=cons(k,cons(SHA1(concat(k,r)),outData(s)))]
    ENDIF;

  % If ek doesn't exist, create a new ek from keyInfo
  createEKPairOut(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?)) : tpmAbsOutput = 
    IF goodkey?(key(s`ek))				     		% 1
    THEN OUT_Error(TPM_DISABLED_CMD)
    % Validate k parameters for key description?			% 2
%     ELSIF RSA?(algoId(algoParms(k))) AND length(k)<2048		% 2b
%     THEN OUT_Error(TPM
    ELSE LET checksum=SHA1(concat(k,r)) IN				% 4
    	 OUT_CreateEndorsementKeyPair(k,checksum,TPM_SUCCESS)		% 3
    ENDIF;

  createRevEKState(s:tpmAbsState,antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	generateReset:bool,inputEKreset:(tpmNonce?)) : tpmAbsState =
    IF goodkey?(key(s`ek))
    THEN s
    ELSE LET s1=createEKPairState(s,antiReplay,keyInfo),
    	     o1=createEKPairOut(s,antiReplay,keyInfo) IN
	 CASES o1 OF
	 OUT_CreateEndorsementKeyPair(e,c,m) :
    	 s1 WITH [`permFlags(enableRevokeEK):=TRUE			% 3
	     	 ,`permData(ekReset):=IF generateReset 
				      THEN tpmNonce(n(RNG(s`randCnt)))	% 3a
				      ELSE inputEKreset			% 3b
				      ENDIF
		,`outData:=cons(tpmPubkey(algoParms(e),key(e)),
				cons(c,cons(IF generateReset 
					  THEN tpmNonce(n(RNG(s`randCnt)))% 3a
			   		  ELSE inputEKreset ENDIF,	% 3b
					 outData(s))))
		,`randCnt:=randCnt(s)+1] % may not need it, but just in case
	ELSE s
	ENDCASES
    ENDIF;
    
  createRevEKOut(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?),genReset:bool,
	i:(tpmNonce?)) : tpmAbsOutput = 
    IF goodkey?(key(s`ek))						% 1
    THEN OUT_Error(TPM_DISABLED_CMD) 
    ELSE LET o1=createEKPairOut(s,r,k) IN				% 2
    	 CASES o1 OF
	 OUT_CreateEndorsementKeyPair(e,c,m) :
	 	OUT_CreateRevocableEK(tpmPubkey(algoParms(e),key(e)),c,	% 4
			IF genReset THEN tpmNonce(n(RNG(s`randCnt)))	% 3a
			   ELSE i ENDIF,				% 3b
			TPM_SUCCESS)
	ELSE o1								% 2
	ENDCASES
    ENDIF;

  revokeTrust?(s:tpmAbsState,ekReset:(tpmNonce?)) : bool =
    s`permFlags`enableRevokeEK AND s`permData`ekReset=ekReset AND
    	s`stclearFlags`physicalPresence

  revokeTrustState(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsState = 
    IF s`permFlags`enableRevokeEK AND ekReset(permData(s))=ekReset AND	% 1,2
       s`stclearFlags`physicalPresence					% 3
    THEN LET s1 = clear(s) IN						% 4
	 %TODO NV items with pubInfo->nvIndex D value must be deleted	% 4a
	 s1 WITH [`permFlags(nvLocked):=FALSE,				% 4b
% 	      	  `permData(tpmDAASeed):=,				% 5
% 		  `permData(daaProof):=,				% 6
% 		  `permData(daaBlobKey):=,				% 7
		  `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),		% 8
			      authDataUsage(s`ek),algoParms(s`ek),
			      PCRInfo(s`ek),encDat(s`ek))
		 ]
	% TODO: invalidate any internal state associated with EK	% 8
    ELSE s
    ENDIF;

  revokeTrustOut(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsOutput =
    IF not s`permFlags`enableRevokeEK					% 1
    THEN OUT_Error(TPM_PERMANENTEK)				 
    ELSIF not s`permData`ekReset=ekReset				% 2
    THEN OUT_Error(TPM_AUTHFAIL) 
    ELSIF not s`stclearFlags`physicalPresence				% 3
    THEN OUT_Error(TPM_BAD_MODE)     % todo: check
    ELSE OUT_RevokeTrust(TPM_SUCCESS)
    ENDIF;

  readPubek?(s:tpmAbsState,n:(tpmNonce?)) : bool = 
    readPubek(permFlags(s)) AND goodkey?(key(ek(s)))

  readPubekOut(s:tpmAbsState,n:(tpmNonce?)) : tpmAbsOutput =
    IF not s`permFlags`readPubek					% 1
    THEN OUT_Error(TPM_DISABLED_CMD)
    ELSIF not goodkey?(key(ek(s)))					% 2
    THEN OUT_Error(TPM_NO_ENDORSEMENT)
    ELSE LET pubEK=ek(s) IN
    	 LET checksum=SHA1(concat(pubEK,n)) IN				% 3
    	 OUT_ReadPubek(pubEK,checksum,TPM_SUCCESS)			% 4
    ENDIF;


  ownerReadInternalPubState(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsState = 
    LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN
    IF key(k)=ekKeyVal							% 2
    THEN s WITH [`outData:=cons(tpmPubkey(algoParms(k),key(k)),outData(s))]
    ELSIF key(k)=srkKeyVal						% 3  
    THEN s WITH [`outData:=cons(tpmPubkey(algoParms(k),key(k)),outData(s))]
    ELSE s								% 4
    ENDIF;  
    
  ownerReadInternalPubOut(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsOutput = 
      % Validate the params and TPM Owner AuthData for this command	% 1
    LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN
    IF key(k)=ekKeyVal							% 2
    THEN OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,TPM_SUCCESS)
    ELSIF key(k)=srkKeyVal						% 3  
    THEN OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,TPM_SUCCESS)
    ELSE OUT_Error(TPM_BAD_PARAMETER)					% 4
    ENDIF;  


  makeIdentity?(s:tpmAbsState,k:(tpmKey?)):bool=
    identity?(keyUsage(k)) AND not(migratable(keyFlags(k)))
    AND not(s`permFlags`FIPS AND never?(authDataUsage(k)))

  setDigAtCreation(s:tpmAbsState,pcr:(tpmPCRInfoLong?)) : (tpmCompositeHash?) =
    LET digest=tpmPCRComposite(creationPCRSelect(pcr),		% 9
    			       pcrs(s))
    IN tpmCompositeHash(digest);

  makeIdentityLocality : LOCALITY

  makeIdentityState(s:tpmAbsState,iA:(tpmEncAuth?),CADig:(tpmDigest?),
	k:(tpmKey?),i1,i2:authIn) : tpmAbsState = 
    IF makeIdentity?(s,k) AND member(private(k),vals(s`keys))
    THEN LET a1=decryptADIP(iA,authHandle(i2)) IN			% 6
         LET pcr=tpmPCRInfoLong(makeIdentityLocality,			% 9
			locAtRelease(PCRInfo(k)),
			creationPCRSelect(PCRInfo(k)),
			releasePCRSelect(PCRInfo(k)),
			setDigAtCreation(s,PCRInfo(k)),			% 9
			digAtRelease(PCRInfo(k))),
	     encData=encrypt(tpmStoreAsymkey(a1,			% 11
				s`permData`tpmProof,			% 13
				pubDataDigest(encData(encDat(k))),
				private(k)),
			key(s`srk)) IN					% 15
      	LET idKey=tpmKey(s`keyGenCnt,					% 8
	    		keyUsage(k),
			keyFlags(k),
			authDataUsage(k),
			algoParms(k),
			pcr,
			encData) IN 
	LET idBind=sign(tpmIdContents(CADig,idKey),			% 16
			  private(idKey),s`keys) IN			% 17
    	 genKeyState(s) WITH [`outData:=cons(idKey,cons(idBind,outData(s)))]
    ELSE s
    ENDIF;

  % Output a newly generated AIK.  Note that a simulates the new aik.
  makeIdentityOut(s:tpmAbsState,iA:(tpmEncAuth?),CADig:(tpmDigest?),k:(tpmKey?),
	i1,i2:authIn) : tpmAbsOutput =
    % validate k params for key description				% 1
    % IF RSA?(algoId(algoParms(srk))) AND length(k) < 2048		% 1a
    %   OR if alg type not RSA, strength comparable to RSA 2048		% 1b
    % THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 1c
    IF s`permFlags`FIPS AND never?(authDataUsage(k))			% 1d
    THEN OUT_Error(TPM_NOTFIPS)						% 1di
    % Use authHandle(i2) to verify Owner authorized input params	% 2
    % use authHandle(i1) to verify SRK owner authorized input params	% 3
    ELSIF not(identity?(keyUsage(k))) OR migratable(keyFlags(k))	% 4,5
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSE LET a1=decryptADIP(iA,authHandle(i2)),			% 6
    	     o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 7
			resAuth:=usageAuth(encData(encDat(s`srk)))#),
	     o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 7
			resAuth:=ownerAuth(i2)#) IN
         LET pcr=tpmPCRInfoLong(makeIdentityLocality,			% 9
			locAtRelease(PCRInfo(k)),
			creationPCRSelect(PCRInfo(k)),
			releasePCRSelect(PCRInfo(k)),
			setDigAtCreation(s,PCRInfo(k)),			% 9
			digAtRelease(PCRInfo(k))),
	     encData=encrypt(tpmStoreAsymkey(a1,			% 11
				s`permData`tpmProof,			% 13
				pubDataDigest(encData(encDat(k))),
				private(k)),
			key(s`srk)) IN					% 15
      	LET idKey=tpmKey(keyGenCnt(s),					% 8
	    		keyUsage(k),
			keyFlags(k),
			authDataUsage(k),
			algoParms(k),
			pcr,
			encData) IN 
	LET idBind=sign(tpmIdContents(CADig,idKey),			% 16
			  private(idKey),s`keys) IN			% 17
        OUT_MakeIdentity(idKey,idBind,o1,o2,TPM_SUCCESS)
    ENDIF;

  activateIdentity?(s:tpmAbsState,i:(tpmKey?),b:(encrypted?)) : bool=
    %Validate owners AuthData using authHandle(a1) to execute cmd & params  % 1
    %Use authHandle(a2) to validate the AuthData to execute cmd& params	% 2
    LET h1=tpmDigest(cons(tpmPubkey(algoParms(i),key(i)),null)), 	% 4
	b1=decrypt(b,private(s`ek),s`keys) IN				% 5
    IF not identity?(keyUsage(i)) 
    THEN FALSE								% 3
    ELSE CASES b1 OF			  				% 6
	 tpmEKBlob(blob) :						% 6ai
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :	
			LET C1=tpmCompositeHash(
					tpmPCRComposite(pcrSelect(p),	% 8di
    			        		s`pcrs)) IN
			IF h1/=d					% 8c
			THEN FALSE
			ELSIF not(null?(pcrSelect(p)))			% 8d
			      AND C1/=digAtRelease(p)
			THEN FALSE					% 8dii
			ELSIF not member(s`locality,locAtRelease(p))
			THEN FALSE					% 8e
			ELSE TRUE					% 8f
			ENDIF
		ELSE FALSE						% 8a
		ENDCASES,
	 tpmAsymCAContents(k,d) : h1=d 					% 6bi,7
	 ELSE TRUE
	 ENDCASES
    ENDIF;

  activateIdentityState(s:tpmAbsState,idKey:(tpmKey?),b:(encrypted?),
	i1,i2:authIn) : tpmAbsState =
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(idKey)))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#),
	h1=tpmDigest(cons(tpmPubkey(algoParms(idKey),key(idKey)),null)),% 4
	b1=decrypt(b,private(s`ek),s`keys) IN				% 5
    IF not activateIdentity?(s,idKey,b)
    THEN s
    ELSE CASES b1 OF			  				% 6
	 tpmAsymCAContents(k,d) : 					% 6bi
	 	IF h1=d							% 7
		THEN s WITH [`outData:=cons(k,outData(s))]		% 7b,9
		ELSE s							% 
		ENDIF,
	 tpmEKBlob(blob) :						% 6ai
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :	
			LET C1=tpmCompositeHash(
					tpmPCRComposite(pcrSelect(p),	% 8di
    			        			pcrs(s))) IN
			IF h1/=d					% 8c
			THEN s
			ELSIF not(null?(pcrSelect(p)))			% 8d
			      AND C1/=digAtRelease(p)
			THEN s						% 8dii
			ELSIF not member(s`locality,locAtRelease(p))
			THEN s						% 8e
			ELSE s WITH [`outData:=cons(k,outData(s))]	% 8f
			ENDIF
		ELSE s							% 8a
		ENDCASES
    	 ELSE s WITH [`outData:=cons(badData,outData(s))]
	 ENDCASES
    ENDIF;

  % Retrieve a key if a can be installed
  % The cmd assumes the availability of the priv key associated with th identity
  % The cmd will verify the association between the keys during the process.
  % The cmd will decrypt the input blob and extract the sess key and verify
  % the connection between the public and private keys. p 157
  activateIdentityOut(s:tpmAbsState,idKey:(tpmKey?),b:(encrypted?),
	i1,i2:authIn) : tpmAbsOutput =
    %Validate owners AuthData using authHandle(a1) to execute cmd & params  % 1
    %Use authHandle(a2) to validate the AuthData to execute cmd& params	% 2
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(idKey)))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#),
	h1=tpmDigest(cons(tpmPubkey(algoParms(idKey),key(idKey)),null)),% 4
	b1=decrypt(b,private(s`ek),s`keys) IN				% 5
    IF not identity?(keyUsage(idKey)) 
    THEN OUT_Error(TPM_BAD_PARAMETER)					% 3
    ELSE CASES b1 OF			  				% 6
	 tpmEKBlob(blob) :						% 6ai
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :	
			LET C1=tpmCompositeHash(
					tpmPCRComposite(pcrSelect(p),	% 8di
    			        		pcrs(s))) IN
			IF h1/=d					% 8c
			THEN OUT_Error(TPM_BAD_PARAMETER)
			ELSIF not(null?(pcrSelect(p)))			% 8d
			      AND C1/=digAtRelease(p)
			THEN OUT_Error(TPM_WRONGPCRVAL)			% 8dii
			ELSIF not member(s`locality,locAtRelease(p))
			THEN OUT_Error(TPM_BAD_LOCALITY)		% 8e
			ELSE OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS)	% 8f
			ENDIF
		ELSE OUT_Error(TPM_BAD_TYPE)				% 8a
		ENDCASES,
	 tpmAsymCAContents(k,d) : 					% 6bi
	 	IF h1=d							% 7
		THEN OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS)		% 7b,9
		ELSE OUT_Error(TPM_BAD_PARAMETER)			% 7a
		ENDIF
	 ELSE OUT_ActivateIdentity(badData,o1 WITH [`resAuth:=badData],
	      			o2,TPM_SUCCESS)	
	 ENDCASES
    ENDIF;
        
  % For PCRS hashing is pcrsExtend instead of tpmDigest
  extend?(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : bool =
    LET L1=s`stanyFlags`localityModifier,				% 2
    	P1=pcrExtendLocal(s`permData`pcrAttrib(pcrNum)) IN		% 3
    (0<=pcrNum<=23) AND member(L1,P1);

  %% Extend operation on TPM state
  extendState(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsState =
    IF not extend?(s,pcrNum,inDigest)
    THEN s 
    ELSE LET s1=s WITH [`pcrs := pcrsExtend(pcrs(s),pcrNum,inDigest)] IN% 7
         IF s`permFlags`disable OR s`stclearFlags`deactivated		% 8
	 THEN s1 
	 ELSE s1 WITH [`outData:=cons(tpmPCRValue(extend(s`pcrs(pcrNum),
							inDigest)),
					outData(s1))]
	 ENDIF
    ENDIF;

  extendOut(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsOutput = 
    LET L1=s`stanyFlags`localityModifier,				% 2
    	P1=pcrExtendLocal(s`permData`pcrAttrib(pcrNum)),		% 3
	H1=pcrsExtend(s`pcrs,pcrNum,inDigest) IN			% 4
    IF pcrNum > 23 OR pcrNum < 0
    THEN OUT_Error(TPM_BADINDEX)					% 1
    ELSIF not member(L1,P1)						% 4
    THEN OUT_Error(TPM_BAD_LOCALITY)
    ELSIF s`permFlags`disable OR s`stclearFlags`deactivated		% 8
    THEN OUT_Extend(tpmPCRValue(reset),TPM_SUCCESS)			% 8a
    ELSE OUT_Extend(tpmPCRValue(extend(s`pcrs(pcrNum),inDigest)),
			TPM_SUCCESS)					% 9a
    ENDIF    

  pcrReadState(s:tpmAbsState,ind:PCRINDEX) : tpmAbsState  =
    IF ind > 23 OR ind < 0
    THEN s								% 1
    ELSE LET p=s`pcrs IN 						% 2
    	 s WITH [`outData:=cons(tpmPCRValue(p(ind)),outData(s))]	% 3
    ENDIF

  % Output PCR of given index
  pcrReadOut(s:tpmAbsState,ind:PCRINDEX) : tpmAbsOutput = 
    IF ind > 23 OR ind < 0
    THEN OUT_Error(TPM_BADINDEX)					% 1
    ELSE LET p=s`pcrs IN 						% 2
    	 OUT_PCRRead(tpmPCRValue(p(ind)),TPM_SUCCESS)			% 3
    ENDIF

  % Output PCRs from a state as quote
  quote?(k:(tpmKey?)) : bool = 
    signing?(keyUsage(k)) OR identity?(keyUsage(k)) OR legacy?(keyUsage(k))

  quoteState(s:tpmAbsState,k:(tpmKey?),extDat:(tpmNonce?),p:PCR_SELECTION,
  	i:authIn) : tpmAbsState =
    IF not quote?(k)
    THEN s
    ELSIF not(member(private(k),vals(s`keys)))
    THEN s
    ELSE %Validate p is valid PCR_SELECTION structure			% 4
         LET H1=tpmCompositeHash(tpmPCRComposite(p,s`pcrs)),		% 5
%             pcrData=getPCRs(s`pcrs,p) IN				
             pcrData=tpmPCRComposite(p,s`pcrs) IN				
	     %TODO: add pcrData !!
	 s WITH [`outData:=cons(sign(tpmQuote(H1,			% 6c
			    		extDat),			% 6d
			  		private(k),s`keys),		% 7,8
				cons(pcrData,outData(s)))]
    ENDIF;

  quoteOut(s:tpmAbsState,k:(tpmKey?),extDat:(tpmNonce?),p:PCR_SELECTION,
  	i:authIn) : tpmAbsOutput =
    % Validate AuthData to use key pointed to by k			% 1
    % IF not(SHA1?(sigScheme(k))) OR not(INFO?(sigScheme(k)))		% 2
    % THEN OUT_Error(TPM_INAPPROPRIATE_SIG)
    IF not quote?(k)
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not(member(private(k),vals(s`keys)))
    THEN OUT_CPUError(CPU_SIGN_ERROR)
    ELSE %Validate p is valid PCR_SELECTION structure			% 4
         LET H1=tpmCompositeHash(tpmPCRComposite(p,s`pcrs)),		% 5
%             pcrData=getPCRs(s`pcrs,p) IN				
             pcrData=tpmPCRComposite(p,s`pcrs) IN				
	 OUT_Quote(pcrData,
		   sign(tpmQuote(H1,					% 6c
			    extDat),					% 6d
			  private(k),s`keys),				% 7,8
		  (#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#),
		  TPM_SUCCESS)
    ENDIF;


  validatePCRVals(s:tpmAbsState,pcrSelect:PCR_SELECTION) : RECURSIVE nat =
    LET L1=s`stanyFlags`localityModifier,				% 2
    	sum:nat=0 IN
    CASES pcrSelect OF
    	  null : 0,
	  cons(x,xs) : 
	      IF not pcrReset(s`permData`pcrAttrib(x))
	      THEN 1							% 3a
	      ELSIF not member(L1,pcrResetLocal(s`permData`pcrAttrib(x)))
	      THEN 2							% 3b
	      ELSE validatePCRVals(s,xs)
	      ENDIF
    ENDCASES		  
    measure pcrSelect by <<

  % induct on select, grind
  validatePCRs : LEMMA
    FORALL (s:tpmAbsState,select:PCR_SELECTION) : 
    LET a=validatePCRVals(s,select) IN
	a=0 OR a=1 or a=2

  check_validatePcrs: THEOREM
  FORALL (state:tpmAbsState) : 
  LET s:tpmAbsState=tpmStartup(state) WITH 
      		[`permData(pcrAttrib)(6):=(#pcrReset:=true
					   ,pcrResetLocal:=cons(2,null)
					   ,pcrExtendLocal:=allLocs#)],
      p:PCR_SELECTION=cons(5,cons(6,null)) IN
      validatePCRVals(s,p)=2;

  pcrResetState(s:tpmAbsState,pcrSelect:PCR_SELECTION) : tpmAbsState  =
    IF null?(pcrSelect)							% 1b
    THEN s								% 1c
    ELSE LET num=validatePCRVals(s,pcrSelect) IN
      	 COND
      	 num=0 -> s WITH [`pcrs:=pcrsResetSelection(s`pcrs,pcrSelect)],	% 4a
      	 ELSE -> s
      	 ENDCOND
    ENDIF;

  pcrResetOut(s:tpmAbsState,pcrSelect:PCR_SELECTION) : tpmAbsOutput = 
    IF null?(pcrSelect)							% 1b
    THEN OUT_Error(TPM_INVALID_PCR_INFO)				% 1c
    ELSE LET num=validatePCRVals(s,pcrSelect) IN
      	 COND
      	 num=0 -> OUT_PCR_Reset(TPM_SUCCESS),				% 
      	 num=1 -> OUT_Error(TPM_NOTRESETABLE),				% 3a
      	 num=2 -> OUT_Error(TPM_NOTLOCAL),				% 3b
	 ELSE -> OUT_Error(TPM_SUCCESS)
      	 ENDCOND
    ENDIF;
  
  changeAuthOut2(s,d:(tpmSecret?),i:authIn) : (tpmSecret?) = 
    % TODO: Validate the command using ownerAuth(i)			% 10b
    d % IF valid, return d, else ?
    
  changeAuthState(s:tpmAbsState,p:(tpmKey?),newA:(tpmEncAuth?),d:(encrypted?),
	i1,i2:authIn) : tpmAbsState = 
    IF tpmKey?(d) OR tpmStoredData?(d) 	      	   			% 5
    THEN LET decryptAuth=decryptADIP(newA,authHandle(i1)) IN		% 6
    	 % VALIDATE command using authdata in ownerAuth(i1)		% 7
	 IF not storage?(keyUsage(p))	   
	 THEN s								% 8
	 ELSE LET b1=decrypt(d,private(p),s`keys) IN			% 9
	      CASES b1 OF	       					% 10
	      tpmStoreAsymkey(u,m,v,k) : 
		s WITH [`outData:=cons(encrypt(tpmStoreAsymkey(
					changeAuthOut2(u,decryptAuth,i2),% 10,11
					m,v,k),
				  key(p)),outData(s))],			% 12
	      tpmSealedData(a,f,e,d) : 
		s WITH [`outData:=cons(encrypt(tpmSealedData(
					changeAuthOut2(a,decryptAuth,i2),% 10,11
					f,e,d),
				  key(p)),outData(s))]			% 12
%	      ELSE s							% 10a
	      ENDCASES

	 ENDIF
    ELSE s							% TODO: check
    ENDIF;

  changeAuthOut(s:tpmAbsState,p:(tpmKey?),newA:(tpmEncAuth?),d:(encrypted?),
	i1,i2:authIn) : tpmAbsOutput = 
    %IF not (DATA?(et) OR KEY?(et)) THEN OUT_Error(TPM_WRONG_ENTITYTYPE) % 1
    %IF not OSAP?(sessType(i1`authHandle) THEN OUT_Error(TPM_BAD_MODE)	 % 2
    %IF not OIAP?(sessType(i2`authHandle) THEN OUT_Error(TPM_BAD_MODE)	 % 3
    %IF not ACDP?(pi) THEN OUT_Error(TPM_BAD_PARAMETER)			 % 4
    IF tpmKey?(d) OR tpmStoredData?(d) 	      	   			% 5
    THEN LET decryptAuth=decryptADIP(newA,authHandle(i1)) IN		% 6
    	 % VALIDATE command using authdata in ownerAuth(i1)		% 7
	 IF not storage?(keyUsage(p))	   
	 THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 8
	 ELSE LET b1=decrypt(d,private(p),s`keys),			% 9
	      	  o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=usageAuth(encData(encDat(p)))#),
	      	  o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=ownerAuth(i2)#) IN
	      CASES b1 OF	       					% 10
	      tpmStoreAsymkey(u,m,v,k) : 
		OUT_ChangeAuth(encrypt(tpmStoreAsymkey(
					changeAuthOut2(u,decryptAuth,i2),% 10,11
					m,v,k),
				  key(p)),		% 12
				o1,o2,TPM_SUCCESS),
	      tpmSealedData(a,f,s,d) : 
		OUT_ChangeAuth(encrypt(tpmSealedData(
					changeAuthOut2(a,decryptAuth,i2),% 10,11
					f,s,d),
				  key(p)),		% 12
				o1,o2,TPM_SUCCESS)
	      ELSE OUT_Error(TPM_INVALID_STRUCTURE)			% 10a
	      ENDCASES
	 ENDIF
    ELSE OUT_Error(TPM_INVALID_STRUCTURE)			% TODO: check
    ENDIF
    % TODO: THe TPM MUST enforce the destruction of authHandle(i1) and 
    %  authHandle(i2) sessions						% 13

  OIAPState(s:tpmAbsState) : tpmAbsState
    

  OIAPOut(s:tpmAbsState) : tpmAbsOutput
%   oiapOut(s:tpmAbsState) : tpmAbsOutput =
%     % Verify the authorization session handle (H) referenced in the command(?) 
%     %  points to a valid session. if not OUT_Error(TPM_INVALID_AUTHHANDLE)  % 1
%     % Retrieve the latest version of caller's nonce (nonceOdd) and 
%     %  continueAuthSession flag from input parameter list, store it in internal 
%     %  tpm memory with authSession 'H' 	   	     	   	       % 2
%     % Retrieve the latest version of TPM's nonce stored with auth sess H 
%     %  (authLastNonceEven) computed during previously executed command. % 3
%     % Retrieve secret AuthData (SecretE) of target entity. Entity and secret 
%     %  must have been previously loaded into TPM.	   	      	% 4
%     % IF command using OIAP session requires owner authorization      	% 4a
%     LET secretE=
%     	IF s`stclearData`ownerReference=key(TPM_KH_OWNER)		% 4aii
% 	THEN s`permData`ownerAuth
% 	ELSE LET R1=s`stclearData`ownerReference IN			% 4aii1
% 	     LET D1=s`permData`delegateTable`delRow(R1) IN		% 4aii2
% 	     authValue(D1)						% 4aii3
% 	     % TODO: VALIDATE Stuff					% 4aii4
% 	ENDIF IN

  validate(H:(tpmAuthData?)) : bool

%   validateOIAPSession(s:tpmAbsState,targetEntity:authIn) : tpmAbsOutput = 
%     % Validate the authoirzation session handle H referenced in the command 
%     % 	       points to a valid session. Else TPM_INVALID_AUTHHANDLE	% 1
%     IF not validate(targetEntity`authHandle)
%     THEN OUT_Error(TPM_INVALID_AUTHHANDLE)
%     % The TPM shall retrieve the latest version of the caller's nonce (nonceOdd)
%     % 	  and continueAuthSession flag from the input param list, and store it 
%     %	  in internal tpm memory with authSession H   	    	        % 2
%     ELSE LET a=targetEntity`nonceOdd,
%     	     b=targetEntity`contAuthSess,
% 	     c=targetEntity`authHandle IN %TODO: store in internal TPM memory?
%     % The TPM shall retrieve the latest version of the TPM's nonce stored with 
%     % 	  the authorization session H (authLastNonceEven) computed during the 
%     % 	  previously executed command   	      	  	   	% 3
      
    % The TPM must retrieve the secret AuthData (SecretE) of the target entity.
    % 	   The entity and its secret must have been previously loaded into the 
    %	   TPM.       	      	     	       	    	       	      	% 4
    % If the command using the OIAP session requires owner authorization% a
    % IF s`stclearData`ownerReference = TPM_KH_OWNER, 
    % THEN LET SecretE=s`permData`ownerAuth				% 4ai
    % ELSIF s`stclearData`ownerReference -> delegate row		% 4aii
    % THEN LET R1:rowIndex:=s`stclearData`ownerReference IN		% 4aii1
    % 	   LET D1:delegate_table_row:=s`permData`delegateTable`delRow[R1]%4aii2
    % 	   LET SecretE:=D1`authValue IN					% 4aii3
    %	   Validate D1`pub`permissions based on command ordinal		% 4aii4a
    %	   	    D1`pub`pcrInfo based on PCR values			% 4aii4b
    % HMAC Calculation per Part 1 Object-Independent Authorization Protocol? % 5
    %  	   entity secret data
    %      ordinal
    %	   input command parameters
    %	   authorization parameters
    % IF HM/=AuthData value received in input params
    % THEN IF authorization is first session THEN OUT_Error(TPM_AUTHFAIL) 
    %  	   ELSIF authorization is second session THEN OUT_ERROR(TPM_AUTH2FAIL)
    % ELSE TPM executes command which produces an output that requires authentication.			% 6
    % generate nonceEven	% 7
    % HMAC digest to authenticate Per Part 1 Object-Independent-Authorization Protocol
    %  	   return code		      	     				% 8
    % 	   return values
    % 	   authorization parametersto the same entity secret
    % Return return code, output parameters, authorization parameters, and authorization session digest			% 9
    % If continueUse=FALSE then TPM shall terminate the session. Future references to H will return error.		% 10
    % Ecah time access to entity is authorized using OIAP, the TPM must validate that the TPM_PCR_Info_xxx ...AtRelease values if specified for entity  % 11
    % The TPM should validate the values before using the shared secret to validate the command parameters. this prevents dictionary attack on the shared secret when the values are invalid for the entity.        % 11 a
  
  OSAPState(s:tpmAbsState,oOSAP:(tpmNonce?)) : tpmAbsState

  OSAPOut(s:tpmAbsState) : tpmAbsOutput

  flushSpecificState(s:tpmAbsState,d:tpmData) : tpmAbsState 

  flushSpecificOut(s:tpmAbsState,d:tpmData) : tpmAbsOutput
  
  dataBindOut(s:tpmAbsState,k:(tpmKey?),d:tpmData) : tpmAbsOutput = 
    OUT_Data_Bind(encrypt(tpmBoundData(d),key(k)),CPU_SUCCESS);

  buildQuoteFromMem?(s:tpmAbsState,q,i:nat) : bool = 
    LET theMem = memory(s) IN
    OUT_Quote?(theMem(q)) AND tpmQuote?(signData(sigD(theMem(q))))
       AND OUT_MakeIdentity?(theMem(i))

  buildQuoteFromMemState(s:tpmAbsState,q,i:nat) : tpmAbsState =
    IF buildQuoteFromMem?(s,q,i)
    THEN LET theMem = memory(s) IN
    	 s WITH [`outData:=cons(signData(sigD(theMem(q))),
			cons(idBinding(theMem(i)),outData(s)))]
    ELSE s
    ENDIF

  buildQuoteFromMemOut(s:tpmAbsState,q,i:nat) : tpmAbsOutput = 
    IF buildQuoteFromMem?(s,q,i)
    THEN LET theMem = memory(s) IN 
    	 OUT_FullQuote(signData(sigD(theMem(q))),
		idBinding(theMem(i)),
		CPU_SUCCESS)
    ELSE OUT_CPUError(CPU_QUOTE_ERROR) %% TODO: Incorrect?
    ENDIF;


  certify?(aik:(tpmKey?),certReq:(signed?)) : bool = 
    LET d=checkSig?(key(aik),certReq) IN
      d AND tpmIdContents?(signData(certReq))
      AND tpmDigest?(digest(signData(certReq)))
  
  %% TODO: should this be able to affect state? i don't think so. CHANGE
%   certState(aik:(tpmKey?),certReq:(signed?)) : tpmAbsState=
%     IF certify?(aik,certReq)
%     THEN genKeyState(s) WITH 
%     	 	[`outData:=cons(aik,
% 			   cons(encrypt(tpmAsymCAContents(
% 				tpmSessKey(initSessKeyVal),
% 					digest(signData(certReq))),
% 				   key(ekVal)),outData(s)))]
%     ELSE s
%     ENDIF
  
  % Generate a certified AIK from an AIK.  Certification assumes that the
  % EK really does belong to the TPM.  We're abstracting away that check.
  certOut(aik:(tpmKey?),certReq:(signed?)) : tpmAbsOutput =
    IF certify?(aik,certReq)
    THEN OUT_Certify(aik,encrypt(tpmAsymCAContents(tpmSessKey(initSessKeyVal),
					digest(signData(certReq))),
				   inverse(sigkey(certReq))), %TODO: ENCRYPTED WITH EK?
		CPU_SUCCESS)
    ELSE OUT_CPUError(CPU_CERTIFY_ERROR)
    ENDIF
  
  % Read a value and output
  readOut(s:tpmAbsState,i:nat) : tpmAbsOutput = 
    s`memory(i);

  %% Revoke key operation on TPM state
  revokeKeyState(s:tpmAbsState,k:(tpmKey?)) : tpmAbsState =
    s WITH [`keys := revokeKey(k,keys(s))];


  restoreState(s:tpmAbsState) : tpmAbsState =
    IF valid?(restore(s))
    THEN LET rs=restore(s) IN
    % TODO: Sessions based off of TPM_GetCapability			% 3b
    % TODO: PCRs     	       	  					% 3c
    % TODO: auditDigest							% 3d
         s WITH[`memory := memory(s)
	       ,`ek := ek(rs)
	       ,`srk := srk(rs)
	       ,`pcrs := pcrs(rs)
	       ,`keys := keys(rs)					% 3f
	       ,`keyGenCnt:=keyGenCnt(rs)
	       ,`locality := 3
	       ,`permFlags := permFlags(rs)
	       ,`permData := permData(rs)
	       ,`stanyFlags := stanyFlags(rs) WITH [`postInitialize:=FALSE] % 6
	       ,`stanyData := stanyData(rs)
	       ,`stclearFlags := stclearFlags(rs)			% 3eii
	       ,`stclearData := stclearData(rs)				% 3ei
	       ,`restore := tpmRestoreUnknown %TODO			% 5
	       ,`outData := null]
    ELSE s WITH [`stanyFlags(postInitialize):=FALSE			% 6
    	   	,restore:=tpmRestoreUnknown]				% 5
    ENDIF;

  restoreOut(s:tpmAbsState) : tpmAbsOutput = 
    IF valid?(restore(s))
    THEN OUT_Startup(TPM_SUCCESS) %TODO: check?
    ELSE OUT_Startup(TPM_FAILEDSELFTEST)				% 3a
    	 % TODO: Returns TPM_FAILEDSELFTEST to all commands...
    ENDIF;


  % deactivate by going back to init.  Not sure this is correct.
  deactivateState(s:tpmAbsState) : tpmAbsState  =
    s WITH [%TODO invalidate sessions					% 4a
      	    `stclearFlags:=stclearFlagsDefault WITH [`deactivated:=TRUE]% 4b,c
	   ,`restore:=tpmRestoreUnknown %TODO  	    			% 5
      	   ,`stanyFlags(postInitialize):=FALSE %TODO: INCORRECT?	% 6
	   ];

  % save a value to external memory
  saveToMemState(s:tpmAbsState,i:nat,v:tpmAbsOutput) : tpmAbsState =
    s WITH [`memory := updateLoc(memory(s),i,v)];

  %% What we want to generate with each command is a pair of type
  %% [tpmAbsOut,tpmAbsState].  executeCom generates the the state
  %% from a TPM state and command while the upcoming outputCom
  %% generates the corresponding output.  Thus, to execute any
  %% operation, both executeCom and outputCom must be used

  %% Run if TPM_Init has run but TPM_Startup has not
  executeComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsState =
    CASES c OF
      ABS_Startup(t) : CASES t OF 
      		        TPM_ST_CLEAR : tpmStartup(s),
    			TPM_ST_STATE : restoreState(s),
    			TPM_ST_DEACTIVATED : deactivateState(s)
                       ENDCASES
      ELSE s
    ENDCASES;

  %% Run if ABS_Startup has run after TPM_Init
  executeComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsState = 
    CASES c OF
      ABS_Init : tpmPostInit,
      ABS_SaveState : saveState(s),
      ABS_SetOwnerInstall(state) : setOwnerInstallState(s,state),
      ABS_OwnerSetDisable(d,i) : ownerSetDisableState(s,d,i),
      ABS_PhysicalEnable : physicalEnableState(s),
      ABS_PhysicalDisable : physicalDisableState(s),
      ABS_PhysicalSetDeactivated(st) : physicalSetDeactivatedState(s,st),
      ABS_SetTempDeactivated(i) : setTempDeactivatedState(s,i),
      ABS_SetOperatorAuth(opAuth) : setOperatorAuthState(s,opAuth),
      ABS_TakeOwnership(oA,sA,srk,a) : takeOwnershipState(s,oA,sA,srk,a),
      ABS_OwnerClear(a): ownerClearState(s,a),
      ABS_ForceClear: forceClearState(s),
      ABS_DisableOwnerClear(a): disableOwnerClearState(s,a),
      ABS_DisableForceClear: disableForceClearState(s),
      ABS_PhysicalPresence(p): physicalPresenceState(s,p),
      ABS_ResetEstablishmentBit: resetEstablishmentBitState(s),
      ABS_Seal(k,e,p,i,a) : sealState(s,k,e,p,i,a),
      ABS_Unseal(p,i,a,d) : unsealState(s,p,i,a,d),
      ABS_UnBind(k,i,a) : unBindState(s,k,i,a),
      ABS_CreateWrapKey(p,k,u,m,a) : createWrapKeyState(s,p,k,u,m,a),
      ABS_LoadKey2(p,k,a): loadKey2State(s,p,k,a), 
      ABS_GetPubKey(k,a) : getPubKeyState(s,k,a),
%       ABS_Sealx(k,e,p,i,a) : sealxState(s,k,e,p,i,a),
      ABS_CreateMigrationBlob(p,m,k,e,a,i) : createMigBlobState(s,p,m,k,e,a,i),
      ABS_ConvertMigrationBlob(p,i,r,a) : convertMigBlobState(s,p,i,r,a),
      ABS_AuthorizeMigrationKey(k,m,a) : authorizeMigKeyState(s,k,m,a),
      ABS_MigrateKey(m,p,i,a) : migrateKeyState(s,m,p,i,a),
      ABS_CMK_SetRestrictions(r,i) : CMKSetRestrState(s,r,i),
      ABS_CMK_ApproveMA(m,i) : CMKApproveMAState(s,m,i),
      ABS_CMK_CreateKey(p,d,k,m,a,i) : CMKCreateKeyState(s,p,d,k,m,a,i),
      ABS_CMK_CreateTicket(v,sd,g,i) : CMKCreateTicketState(s,v,sd,g,i),
      ABS_CMK_CreateBlob(p,t,m,k,l,r,st,e,i) : 
      		CMKCreateBlobState(s,p,t,m,k,l,r,st,e,i),
      ABS_CMK_ConvertMigration(p,r,st,m,l,ra,i) : 
      		CMKConvertMigrationState(s,p,r,st,m,l,ra,i),
      ABS_SHA1Complete(h) : SHA1CompleteState(s,h),
      ABS_SHA1CompleteExtend(p,hd) : SHA1CompleteExtendState(s,p,hd),
      ABS_Sign(k,a) : signState(s,k,a),
      ABS_GetRandom : getRandomState(s),
      ABS_StirRandom(i) : stirRandomState(s,i),
      ABS_CertifyKey(c,k,n,i1,i2) : certifyKeyState(s,c,k,n,i1,i2),
      ABS_CreateEndorsementKeyPair(n,k) : createEKPairState(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKState(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustState(s,r),
      ABS_OwnerReadInternalPub(k,a) : ownerReadInternalPubState(s,k,a),
      ABS_MakeIdentity(e,d,k,a1,a2) : makeIdentityState(s,e,d,k,a1,a2), 
      ABS_ActivateIdentity(a,b,a1,a2) : activateIdentityState(s,a,b,a1,a2),
      ABS_Extend(n,d) : extendState(s,n,d),
      ABS_PCRRead(i) : pcrReadState(s,i),
      ABS_Quote(a,n,p,i) : quoteState(s,a,n,p,i),
      ABS_PCR_Reset(p) : pcrResetState(s,p),
      ABS_ChangeAuth(p,n,d,i1,i2) : changeAuthState(s,p,n,d,i1,i2),
%       ABS_OIAP : OIAPState(s),
%       ABS_OSAP(oa) : OSAPState(s,oa),
%       ABS_FlushSpecific(h) : flushSpecificState(s,h),
      ABS_buildQuoteFromMem(q,i) : buildQuoteFromMemState(s,q,i),
      ABS_senter : 
        changeLocalityState(extendState(pcrsResetSenterState(s),0,sinitHash)),
      ABS_sinit : changeLocalityState(extendState(s,0,mleHash)),
      ABS_save(i,v) : saveToMemState(s,i,v)
      ELSE s
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  executeCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsState =
    IF afterInit?(s)
    THEN executeComPostInit(s,c)
    ELSE executeComStartup(s,c)
    ENDIF;

  %% Run if TPM_Init has run but TPM_Startup has not
  outputComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsOutput =
    OUT_Error(TPM_INVALID_POSTINIT);

  %% Generate output from a command and state 
  %% Run if ABS_Startup has run after TPM_Init
  outputComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsOutput = 
    CASES c OF
      ABS_SetOwnerInstall(state) : setOwnerInstallOut(s,state),
      ABS_OwnerSetDisable(d,i) : ownerSetDisableOut(s,d,i),
      ABS_PhysicalEnable : physicalEnableOut(s),
      ABS_PhysicalDisable : physicalDisableOut(s),
      ABS_PhysicalSetDeactivated(st) : physicalSetDeactivatedOut(s,st),
      ABS_SetTempDeactivated(i) : setTempDeactivatedOut(s,i),
      ABS_SetOperatorAuth(opAuth) : setOperatorAuthOut(s,opAuth),
      ABS_TakeOwnership(oA,sA,srk,a) : takeOwnershipOut(s,oA,sA,srk,a),
      ABS_OwnerClear(a) : ownerClearOut(s,a),
      ABS_ForceClear : forceClearOut(s),
      ABS_DisableOwnerClear(a) : disableOwnerClearOut(s,a),
      ABS_DisableForceClear : disableForceClearOut(s),
      ABS_PhysicalPresence(p) : physicalPresenceOut(s,p),
      ABS_ResetEstablishmentBit : resetEstablishmentBitOut(s),
      ABS_Seal(k,e,p,data,a) : sealOut(s,k,e,p,data,a),
      ABS_Unseal(d,k,pa,da) : unsealOut(s,d,k,pa,da),
      ABS_UnBind(k,d,a) : unBindOut(s,k,d,a),
      ABS_Data_Bind(k,d) : dataBindOut(s,k,d),
      ABS_CreateWrapKey(parent,k,u,m,a) : createWrapKeyOut(s,parent,k,u,m,a),
      ABS_LoadKey2(p,k,a) : loadKey2Out(s,p,k,a),
      ABS_GetPubKey(k,a): getPubKeyOut(s,k,a), 
      ABS_CreateMigrationBlob(pk,m,migKAuth,encData,a1,a2) : 
      		createMigBlobOut(s,pk,m,migKAuth,encData,a1,a2),
      ABS_ConvertMigrationBlob(p,d,r,a) : convertMigBlobOut(s,p,d,r,a),
      ABS_AuthorizeMigrationKey(mk,ms,a) : authorizeMigKeyOut(s,mk,ms,a),
      ABS_MigrateKey(mk,pubKey,data,a) : migrateKeyOut(s,mk,pubKey,data,a),
      ABS_CMK_SetRestrictions(r,i) : CMKSetRestrOut(s,r,i),
      ABS_CMK_ApproveMA(m,i) : CMKApproveMAOut(s,m,i),
      ABS_CMK_CreateKey(p,d,k,m,a,i) : CMKCreateKeyOut(s,p,d,k,m,a,i),
      ABS_CMK_CreateTicket(k,a,v,i) : CMKCreateTicketOut(s,k,a,v,i),
      ABS_CMK_CreateBlob(p,t,m,k,l,r,d,e,i) : 
      		CMKCreateBlobOut(s,p,t,m,k,l,r,d,e,i),
      ABS_CMK_ConvertMigration(p,r,t,k,l,d,i) : 
    		CMKConvertMigrationOut(s,p,r,t,k,l,d,i),
      ABS_SHA1Complete(hd) : SHA1CompleteOut(hd),
      ABS_SHA1CompleteExtend(p,hd) : SHA1CompleteExtendOut(s,p,hd),
      ABS_Sign(k,a) : signOut(s,k,a),
      ABS_GetRandom : getRandomOut(s),
      ABS_StirRandom(i) : stirRandomOut(s,i),
      ABS_CertifyKey(c,k,n,i1,i2) : certifyKeyOut(s,c,k,n,i1,i2),
      ABS_CreateEndorsementKeyPair(n,k) : createEKPairOut(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKOut(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustOut(s,r),
      ABS_ReadPubek(n) : readPubekOut(s,n),
      ABS_OwnerReadInternalPub(k,a) : ownerReadInternalPubOut(s,k,a),
      ABS_MakeIdentity(e,d,k,a1,a2) : makeIdentityOut(s,e,d,k,a1,a2),
      ABS_ActivateIdentity(i,b,a1,a2) : activateIdentityOut(s,i,b,a1,a2),
      ABS_Extend(n,d) : extendOut(s,n,d),
      ABS_PCRRead(ind) : pcrReadOut(s,ind),
      ABS_Quote(k,n,pm,i) : quoteOut(s,k,n,pm,i),
      ABS_PCR_Reset(p) : pcrResetOut(s,p),
      ABS_ChangeAuth(p,n,d,i1,i2) : changeAuthOut(s,p,n,d,i1,i2),
      %ABS_OIAP : oiapOut(s),
%       ABS_FlushSpecific(h) : flushSpecificOut(s,h),
      ABS_buildQuoteFromMem(q,i) : buildQuoteFromMemOut(s,q,i),
      ABS_certify(aik,cr) : certOut(aik,cr),
      ABS_read(i) : readOut(s,i)
    ELSE OUT_Error(TPM_SUCCESS)
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  outputCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsOutput =
    IF afterInit?(s)
       THEN outputComPostInit(s,c)
       ELSE outputComStartup(s,c)
    ENDIF;

	   
END tpm

