%% ----
%%
%% TPM Theory
%%
%% Author: Perry Alexander, Brigid Halling
%% Date: Mon Nov 28 01:09:39 CST 2011
%%
%% Description: Basic model of a TPM using a monadic state model
%% 
%% Dependencies:
%%  StateMonad.pvs
%%  ReturnCodes.pvs
%%  memory.pvs 
%%  StclearFlags.pvs
%%  startupData.pvs
%%  PermanentData.pvs
%%  StanyData.pvs
%%  StanyFlags.pvs
%%  key.pvs
%%  data.pvs
%%  keyData.pvs
%%  pcr.pvs
%%  authdata.pvs
%%  PermanentFlags.pvs
%%
%% Todo: (key - => pending, + => done)
%% ----

%% Standard Error IDs
%%  0 = "Bad identity record"
%%  1 = "Bad input key"
%%  2 = "bad session key"
%%  4 = "bad quote parts"
%%  5 = "Clear Disabled"

tpm [ B:TYPE+ % BLOB
      , HV:TYPE+ % Hash value
      , hash:[B->HV] % Hash function
%      , K:TYPE+ % Key
     ] : THEORY

  BEGIN

  ASSUMING
  % Assume that different blobs always have different hashes
    unique_hash: ASSUMPTION
      FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
  ENDASSUMING

  K : TYPE = nat;
  
  cpuReturn : DATATYPE
  BEGIN
    CPU_ERROR : CPU_ERROR? 
    CPU_SUCCESS : CPU_SUCCESS?
    CPU_DECRYPT_ERROR : CPU_DECRYPT_ERROR? 
    CPU_QUOTE_ERROR : CPU_QUOTE_ERROR?
  END cpuReturn;
  
  IMPORTING ReturnCodes;
  IMPORTING startupData[B,K,HV];

  %% State monad output type
  tpmAbsOutput : DATATYPE
  BEGIN
    OUT_Nothing : OUT_Nothing?
    OUT_Error(m:ReturnCode) : OUT_Error?
    OUT_CPUError(m:cpuReturn) : OUT_CPUError?
    OUT_Data_Bind(outData:(tpmBoundData?),m:cpuReturn) : OUT_Data_Bind?
    OUT_Certify(data:(tpmAsymCAContents?),m:cpuReturn) : OUT_Certify?
    OUT_FullQuote(quote:(tpmQuote?),idBind:(tpmIdContents?),m:cpuReturn) 
    	: OUT_FullQuote?
  %% Admin Startup and State (3)
    OUT_Init(m:ReturnCode) : OUT_Init?
    OUT_SaveState(m:ReturnCode) : OUT_SaveState?
    OUT_Startup(m:ReturnCode) : OUT_Startup?
  %% Admin Ownership (6)
    OUT_TakeOwnership(srkPub:(tpmKey?),a:authOut,m:ReturnCode) : 
    	OUT_TakeOwnership?
    OUT_OwnerClear(a:authOut,m:ReturnCode) : OUT_OwnerClear? 
    OUT_ForceClear(m:ReturnCode) : OUT_ForceClear? 
    OUT_DisableOwnerClear(a:authOut,m:ReturnCode) : OUT_DisableOwnerClear? 
    OUT_DisableForceClear(m:ReturnCode) : OUT_DisableForceClear? 
    OUT_PhysicalPresence(m:ReturnCode) : OUT_PhysicalPresence?
  %% Storage Functions (10)
    OUT_Seal(sealedData:(tpmStoredData?),a:authOut,m:ReturnCode) : OUT_Seal?
    OUT_Unseal(secret:tpmData,a,da:authOut,m:ReturnCode) : OUT_Unseal?
    OUT_UnBind(outData:tpmData,a:authOut,m:ReturnCode) : OUT_UnBind?
    OUT_CreateWrapKey(wrappedKey:(tpmKey?),a:authOut,m:ReturnCode) : 
    	OUT_CreateWrapKey?
    OUT_LoadKey2(inkeyHandle:(tpmKey?),m:ReturnCode) : OUT_LoadKey2?
  %% Migration (11)
    OUT_CreateMigrationBlob(random:int,outData:tpmData,m:ReturnCode) : 
    	OUT_CreateMigrationBlob?
    OUT_ConvertMigrationBlob(outData:tpmData,m:ReturnCode) : 
    	OUT_ConvertMigrationBlob?
    OUT_AuthorizeMigrationKey(outData:(tpmMigKeyAuth?),m:ReturnCode) : 
    	OUT_AuthorizeMigrationKey?
    OUT_MigrateKey(outData:tpmData,m:ReturnCode) : OUT_MigrateKey?
  %% Cryptographic Functions (13)
    OUT_Sign(sig:tpmData,m:ReturnCode) : OUT_Sign?
  %% Endorsement Key Handling (14)
    OUT_CreateEndorsementKeyPair(pubEk:(tpmKey?),checksum:(tpmDigest?),
	m:ReturnCode) : OUT_CreateEndorsementKeyPair?
    OUT_CreateRevocableEK(pubEK:(tpmPubkey?),checksum:(tpmDigest?),
	outputEKreset:(tpmNonce?),m:ReturnCode) : OUT_CreateRevocableEK?
    OUT_RevokeTrust(m:ReturnCode) : OUT_RevokeTrust?
    OUT_ReadPubek(pubEk:(tpmKey?),checksum:(tpmDigest?),m:ReturnCode) : 
    	OUT_ReadPubek?
  %% Identity Creation and Activation (15)
    OUT_MakeIdentity(idKey:(tpmKey?),idBinding:(tpmIdContents?),m:ReturnCode) :
	OUT_MakeIdentity?
   OUT_ActivateIdentity(symmKey:(tpmSessKey?),m:ReturnCode) : 
   	OUT_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
    OUT_Extend(outDigest:PCR,m:ReturnCode) : OUT_Extend?
    OUT_PCRRead(outDigest:PCR,m:ReturnCode) : OUT_PCRRead?
    OUT_Quote(pcrData:list[PCR],sig:(tpmQuote?),m:ReturnCode) : OUT_Quote?
  END tpmAbsOutput;

  IMPORTING memory[tpmAbsOutput,OUT_Nothing];
  

  %% State monad input type.  All inputs are in the form of a command with
  %% parameters.
  tpmAbsInput : DATATYPE
  BEGIN
  %% Admin Startup and State commands (3)
    ABS_Reset : ABS_Reset? %unimplemented
    ABS_Init : ABS_Init? 
    ABS_SaveState : ABS_SaveState?
    ABS_Startup(startupType : TPM_STARTUP_TYPE) : ABS_Startup?
  %% Admin Ownership Commands (6)
    ABS_TakeOwnership(oA,sA:(tpmEncAuth?),srk:(tpmKey?),a:authIn) : 
    	ABS_TakeOwnership? %TODO: oA,sA:(tpmAuthData?)
    ABS_OwnerClear(a:authIn) : ABS_OwnerClear? 
    ABS_ForceClear : ABS_ForceClear? 
    ABS_DisableOwnerClear(a:authIn) : ABS_DisableOwnerClear? 
    ABS_DisableForceClear : ABS_DisableForceClear? 
    ABS_PhysicalPresence(p:PHYSPRES) : ABS_PhysicalPresence?
  %% Protected Storage Commands (10)
    ABS_Seal(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : ABS_Seal?	%encAuth:(tpmAuthData?)
    ABS_Unseal(parent:(tpmKey?),inData:(tpmStoredData?),a,da:authIn) : 
    	ABS_Unseal?   
    ABS_UnBind(key:(tpmKey?),inData:(tpmBoundData?),a:authIn) : ABS_UnBind?
    ABS_CreateWrapKey(parentH,keyInfo:(tpmKey?),dUA,dMA:(tpmEncAuth?),a:authIn):
	ABS_CreateWrapKey?
    ABS_LoadKey2(parent:(tpmKey?),inKey:(tpmKey?)): ABS_LoadKey2? 
  %% Migration Commands (11)
    ABS_CreateMigrationBlob(p:(tpmKey?),m:migrateScheme,
	migKeyAuth:(tpmMigKeyAuth?),encData:tpmData) : ABS_CreateMigrationBlob?
    ABS_ConvertMigrationBlob(parent:(tpmKey?),inData:tpmData,random:int) : 
    	ABS_ConvertMigrationBlob?
    ABS_AuthorizeMigrationKey(migKey:(tpmKey?),migScheme:(tpmMigScheme?)) : 
    	ABS_AuthorizeMigrationKey?
    ABS_MigrateKey(maKey,pubKey:(tpmKey?),inData:tpmData) : ABS_MigrateKey?
  %% Cryptographic Commands (13)
    ABS_Sign(keyHandle:(tpmKey?),areaToSign:tpmData) : ABS_Sign?
  %% Endorsement Key Handling (14)
    ABS_CreateEndorsementKeyPair(antiReplay:(tpmNonce?),keyInfo:(tpmKey?)) : 
    	ABS_CreateEndorsementKeyPair?
    ABS_CreateRevocableEK(antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	genReset:bool,inputEKreset:(tpmNonce?)) : ABS_CreateRevocableEK?
    ABS_RevokeTrust(EKReset:(tpmNonce?)) : ABS_RevokeTrust?
    ABS_ReadPubek(n:(tpmNonce?)) : ABS_ReadPubek?
  %% Identity Creation and Activation (15)
    ABS_MakeIdentity(CADigest:(tpmDigest?),idKeyParams:(tpmKey?)) : 
    	ABS_MakeIdentity?
    ABS_ActivateIdentity(aik:(tpmKey?),blob:(activateIdentityBlob?)) : 
    	ABS_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
%     ABS_Extend(pcrNum:PCRINDEX,inDigest:(tpmDigest?)) : ABS_Extend?
    ABS_Extend(pcrNum:PCRINDEX,d:HV) : ABS_Extend?
    ABS_PCRRead(ind:PCRINDEX) : ABS_PCRRead?
    ABS_Quote(aik:(tpmKey?),nonce:(tpmNonce?),pm:PCR_SELECTION) : ABS_Quote?
  %% Changing AuthData (17)
    ABS_ChangeAuth : ABS_ChangeAuth?
  %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    ABS_save(i:nat,v:tpmAbsOutput) : ABS_save?
    ABS_read(i:nat) : ABS_read?
    ABS_Data_Bind(k:(tpmKey?),d:tpmData) : ABS_Data_Bind?
  %% CA Commands
   ABS_certify(aik:(tpmKey?),certReq:(tpmIdContents?)) : ABS_certify?
  %% Invented, imaginary Commands
    noopCom : noopCom?
  END tpmAbsInput;

  %% sinit blob instance for measurement
  sinit : B;

  %% mle blob instance for measurement
  mle : B;

  %% Initial key values not generated by TPM
  ekKeyVal : K = 1;
  srkKeyVal : K = 2;
  caKeyVal : K = 3;

  %% Initial key count value for initializing TPM
  initKeyVal : K = 100;

  %% Key definitions that make ek and srk values asymmetric keys.
  %% TODO: I mostly just made this stuff up... needs to be checked and changed
  ekVal:(tpmKey?) = tpmKey(ekKeyVal,storage,keyFlagsF,
			   always,keyParmsDef,
			   pcrInfoLongDefault,1,
			   storeAsymkeyDefault,clear);
  srkVal:(tpmKey?) = tpmKey(srkKeyVal,storage,keyFlagsF,
			    always,keyParmsDef,
			    pcrInfoLongDefault,1,
			    storeAsymkeyDefault,clear);
  caVal:(tpmKey?) = tpmKey(caKeyVal,storage,keyFlagsF,
			   always,keyParmsDef,
			   pcrInfoLongDefault,1,
			   storeAsymkeyDefault,clear); 
			   % Certificate Authority key

  %% Abstract TPM State with keys, PCR array and locality
  tpmAbsState : TYPE = [#
  	      	       restore : restoreStateData,
                       memory : mem,
                       srk : (tpmKey?),
		       ek : (tpmKey?),
		       keyGenCnt : K,
		       keys : KEYSET,
                       pcrs : PCRVALUES,	%stcleardata`PCR?
		       locality : LOCALITY,
		       permFlags : PermFlags,
		       permData : PermData,
		       stanyFlags : StanyFlags,
		       stanyData : StanyData,
		       stclearFlags : StclearFlags,
		       stclearData : StclearData
		    #];

  %% Well formedness condition for abstract states.  Currently unused, but we
  %% should show that forall commands, well formed input generates well formed
  %% output.

  wellFormed?(s:tpmAbsState):bool = wellFormedRestore?(restore(s));

  IMPORTING StateMonad[tpmAbsOutput,tpmAbsState];

  %% Define some common TPM states and state operations
  
  %% Unknown state
  tpmUnknown : tpmAbsState

  %% Power on state after init is raised by hardware.
  tpmPostInit : (wellFormed?) = (#
                         pcrs:=pcrsPower
                         , locality:=4
			 , keys:=emptyset
			 , srk:=privateKey(srkVal)
			 , ek:=privateKey(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsDefault
			 , permData:=permDataInit
			 , stanyFlags:=stanyFlagsInit 
			   		WITH [`postInitialize:=TRUE]
			 , stanyData:=stanyDataInit
			 , stclearFlags:=stclearFlagsInit % TODO: check
			 , stclearData :=stclearDataInit  % TODO: check
			 #);

  %% Standard initial state following startup command with the TPM_ST_CLEAR
  %% option set.  Note that this should be checked against the spec before
  %% asserting goodness.
  tpmStartup : (wellFormed?) = (#
                         pcrs:=pcrsReset(allResetAccess)
			 , locality:=4
			 , keys:=emptyset
			 , srk:=privateKey(srkVal)
			 , ek:=privateKey(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsDefault
			 , permData:=permDataInit
			 , stanyFlags:=stanyFlagsInit 
			   		WITH [`postInitialize:=FALSE]
			 , stanyData:=stanyDataInit
			 , stclearFlags:=stclearFlagsInit % TODO: check
			 , stclearData :=stclearDataInit  % TODO: check
			 #);

  %% Generate a new state from restore data.  Basically this is a clear
  %% restart with pcrs, keys, and pcr flags coming from the restore
  %% data.  Note that this function assumes valid data and will behave
  %% badly otherwise
  tpmRestore(rd:(wellFormedRestore?)) : (wellFormed?) = (#
                         pcrs:=pcrs(rd)
			 , locality:=4
			 , keys:=keys(rd)
			 , srk:=privateKey(srkVal)
			 , ek:=privateKey(ekVal)
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=rd
			 , permFlags:=permFlags(rd)
			 , permData:=permData(rd)
			 , stanyFlags:=stanyFlags(rd)
			 , stanyData:=stanyData(rd)
			 , stclearFlags:=stclearFlagsInit % TODO: check
			 , stclearData :=stclearDataInit  % TODO: check
                         #)

  %% Predicate to determine if startup has occured.  Used as types
  %% (afterInit?) is the set of states occuring immediately after TPM_Init
  %% (afterStartup?) is the set of states occuring immediately after
  %% TPM_Startup
  afterInit?(s:tpmAbsState):bool = postInitialize(stanyFlags(s));
  afterStartup?(s:tpmAbsState):bool = NOT postInitialize(stanyFlags(s));

  %% Standard operations on TPM state definition above.  All such
  %% functions end with State to indicate they operate on the state
  %% value rather than on the TPM monad.  Note that key set and pcr
  %% manipulation functions are defined externally in key.pvs and
  %% pcr.pvs respectively

  %% Reset PCRs as performed by SENTER.
  pcrsResetSenterState(s:tpmAbsState) : tpmAbsState =
    s WITH [`pcrs := pcrsSenter(pcrs(s),pcrAttrib(permData(s)))];

  %% Decrease locality value
  changeLocalityState(s:tpmAbsState) : tpmAbsState =
    s WITH [`locality := IF locality(s) > 0
                         THEN locality(s) - 1
			 ELSE 0
			 ENDIF];
    
  %% Generate a new key
  genKeyState(s:tpmAbsState) : tpmAbsState =
    s WITH [`keyGenCnt := keyGenCnt(s)+1];

  saveState(s:tpmAbsState) : tpmAbsState =
    s WITH [`restore:=saveState(keys(s)
                                , ek(s)
		      		, srk(s)
				, keyGenCnt(s)
		      		, pcrs(s)
		      		, permFlags(s)
		      		, permData(s)
				, stanyFlags(s)
				, stanyData(s)
				, stclearFlags(s)
				, stclearData(s)
		      		)];

  takeOwnership?(s:tpmAbsState,k:(tpmKey?)) : bool =
    COND
      i(s`permData`ownerAuth)/=INVALIDAUTH -> FALSE,			% 1
      not s`permFlags`ownership -> FALSE,				% 2
      not goodkey?(key(s`ek)) -> FALSE,					% 3
      %not OIAP?(authHandle) -> FALSE,					% 4
      %not protocolID = TPM_PID_OWNER -> FALSE,				% 5
      %  not length(A1)=20bytes -> FALSE,	     			% 6
      %not command, params using A1, ownerAuth -> FALSE,		% 7b
      not storage?(keyUsage(k)) -> FALSE,   				% 8a
      migratable(keyFlags(k)) -> FALSE,					% 8b
      not RSA?(algoId(algoParms(k))) -> FALSE,				% 8c
      %not SHA1_MGF1?(encScheme(algoParms(k))) -> FALSE,		% 8d    
      %not SS_NONE?(sigScheme(algoParms(k))) -> FALSE,			% 8e
      %length(parms(algoParms(k)))<2048 -> FALSE,			% 8f
      %expSize(parms(algoParms(k)))/=0 -> FALSE,			% 8g
      s`permFlags`FIPS AND never?(authDataUsage(k))-> FALSE,		% 8h
      ELSE -> TRUE
    ENDCOND;

  takeOwnershipState(s:tpmAbsState,encOwnerA,encSrkA:(tpmEncAuth?),
	srkParms:(tpmKey?),a:authIn) : tpmAbsState =
    COND
      NOT takeOwnership?(s,srkParms) -> s,				% 1-8
      ELSE -> LET A2=decryptADIP(encSrkA,authHandle(a)),		% 10
      	      	  A1=decryptADIP(encOwnerA,authHandle(a)) IN		% 6
	      LET asymkey=tpmStoreAsymkey(A2,	 			% 10c
			migrationAuth(encDat(srkParms)),
			pubDataDigest(encDat(srkParms)),
			privKey(encDat(srkParms)),
			crs(encDat(srkParms))) IN
	      LET K1=tpmKey(key(srkParms),keyUsage(srkParms),keyFlags(srkParms),
		      authDataUsage(srkParms),algoParms(srkParms),	% 9
		      PCRInfo(srkParms),wrappingKey(srkParms),asymkey,
		      crs(srkParms)) IN
	      	  s WITH [`srk:=K1					% 11
			 ,`permData(ownerAuth):=A1			% 12
			 % TODO: 
			 %,`permData(contextKey)?			% 13
			 %,`permData(delegateKey)?			% 14
			 %,`permData(tpmProof)=TPM_RNG?			% 15
		    	 ,`permFlags(readPubek):=FALSE]			% 17
    ENDCOND;

  takeOwnershipOut(s:tpmAbsState,encOwnerA,encSrkA:(tpmEncAuth?),
	srkParms:(tpmKey?),a:authIn) : tpmAbsOutput =
    IF NOT takeOwnership?(s,srkParms)
    THEN IF i(s`permData`ownerAuth)/=INVALIDAUTH 
      	    THEN OUT_Error(TPM_OWNER_SET)				% 1
     	 ELSIF not s`permFlags`ownership 
      	    THEN OUT_Error(TPM_INSTALL_DISABLED)			% 2
     	 ELSIF not goodkey?(key(s`ek)) 
      	    THEN OUT_Error(TPM_NO_ENDORSEMENT)				% 3
     	 ELSIF not storage?(keyUsage(srkParms)) 
	    THEN OUT_Error(TPM_INVALID_KEYUSAGE)			% 8a
     	 ELSIF migratable(keyFlags(srkParms)) 
	    THEN OUT_Error(TPM_INVALID_KEYUSAGE)			% 8b
     	 ELSIF not RSA?(algoId(algoParms(srkParms))) 
	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8c
     	 ELSIF s`permFlags`FIPS AND never?(authDataUsage(srkParms))
	    THEN OUT_Error(TPM_NOTFIPS)					% 8h
	 % TODO: implemented?
%   	 ELSIF not OIAP?(a`authHandle) 
% 	    THEN OUT_Error(TPM_AUTHFAIL)				% 4
%   	 ELSIF not protocolID = TPM_PID_OWNER 
% 	    THEN OUT_Error(TPM_BAD_PARAMETER)				% 5
% 	 ELSIF LET A1:(tpmSecret?)=decrypt(encOwnerA,PRIVEK) IN		
%   	   not length(A1)=20bytes 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 6
%   	 ELSIF not command, params using A1, ownerAuth 
% 	    THEN OUT_Error(TPM_AUTHFAIL)				% 7b
%   	 ELSIF not SHA1_MGF1?(encScheme(algoParms(srkParms))) 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8d    
%   	 ELSIF not SS_NONE?(sigScheme(algoParms(srkParms))) 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8e
%   	 ELSIF length(parms(algoParms(srkParms)))<2048 
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8f
%   	 ELSIF expSize(parms(algoParms(srkParms)))/=0
% 	    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)			% 8g
     	 ELSE OUT_Error(TPM_SUCCESS) % should never reach here
    	 ENDIF 
    ELSE %takeOwnership?(s,srkParms)
        LET A2=decryptADIP(encSrkA,authHandle(a)),			% 10
	    A1=decryptADIP(encOwnerA,authHandle(a)) IN			% 6
	LET asymkey=tpmStoreAsymkey(A2,	 				% 10c
			migrationAuth(encDat(srkParms)),
			pubDataDigest(encDat(srkParms)),
			privKey(encDat(srkParms)),
			crs(encDat(srkParms))) IN
	 LET K1=tpmKey(key(srkParms),keyUsage(srkParms),keyFlags(srkParms),
		      authDataUsage(srkParms),algoParms(srkParms),
		      PCRInfo(srkParms),wrappingKey(srkParms),asymkey,
		      crs(srkParms)),					% 9
	     aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			    contAuthSess:=TRUE,resAuth:=A1#) IN	% 18
    	 OUT_TakeOwnership(K1,aOut,TPM_SUCCESS)				% 16
    ENDIF;


  clear(s:tpmAbsState) : tpmAbsState = %not fully implemented
    s WITH [`keys:=emptyset
	   ,`permData(ownerAuth):=tpmSecret(INVALIDAUTH)		% 5a
      	   ,`srk:=tpmKey(0,keyUsage(s`srk),keyFlags(s`srk),
			 authDataUsage(s`srk),algoParms(s`srk),
			 PCRInfo(s`srk),wrappingKey(s`srk),
			 encDat(s`srk),crs(s`srk))			% 5b
	   %,`permData(delegateKey):=badkey				% 5c
	   %,`permData(delegateTable):=invalid				% 5d
	   %,`permData(contextKey):=badkey				% 5e
	   ,`permData(tpmProof):=tpmSecret(INVALIDPROOF)		% 5f
	   ,`permData(operatorAuth):=tpmSecret(INVALIDAUTH)		% 5g
	   %,`permData(noOwnerNVWrite):=0				% 6a
	   %,`permData(ordinalAuditStatus):=default			% 6b
	   %,`permData(restrictDelegate):=default			% 6c
	   ,`stanyData:=stanyDataInit					% 7
	   %TODO : nonces shall be reset, lists invalidated
	   ,`stclearData:=stclearDataInit WITH [`PCR:=PCR(stclearData(s))]% 8
	   %TODO: nonces shall be reset, lists invalidated, deferredPhysPresence=0
	   ,`permFlags(disable):=disableDef				% 9a
	   ,`permFlags(deactivated):=deactivatedDef			% 9b
	   ,`permFlags(readPubek):=readPubekDef				% 9c
	   ,`permFlags(disableOwnerClear):=disableOwnerClearDef		% 9d
	   ,`permFlags(disableFullDALogicInfo):=disableFullDALogicInfoDef% 9e
	   ,`permFlags(allowMaintenance):=allowMaintenanceDef		% 9f
	   ,`permFlags(readSRKPub):=readSRKPubDef			% 9g
      	   ,`permFlags(ownership):=TRUE					% 10a
	   ,`permFlags(operator):=FALSE					% 10b
	   ,`permFlags(maintenanceDone):=FALSE				% 10c
	   %,`permData(monotonicCounter):= release all values		% 11
	   % TODO: 12-14
      	   ]

  ownerClearState(s:tpmAbsState,a:authIn) : tpmAbsState =
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> s,
      s`permFlags`disableOwnerClear -> s,				% 2
      ELSE -> clear(s)		      	 				% 3-14
    ENDCOND;

  ownerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> TPM_Error(TPM_AUTHFAIL),
      disableOwnerClear(permFlags(s)) -> OUT_Error(TPM_CLEAR_DISABLED),	% 2 
      ELSE -> LET a:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			     contAuthSess:=FALSE,resAuth:=ownerAuth(a)#) IN
      	      OUT_OwnerClear(a,TPM_SUCCESS)				% 3-14
    ENDCOND;

  forceClearState(s:tpmAbsState) : tpmAbsState = 
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN s								% 2
    	 ELSE clear(s)							% 3
    	 ENDIF
    ELSE s								% 1
    ENDIF
  
  forceClearOut(s:tpmAbsState) : tpmAbsOutput =
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN OUT_Error(TPM_CLEAR_DISABLED)   	 	  	      	% 2
    	 ELSE OUT_ForceClear(TPM_SUCCESS)				% 3
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PRESENCE)					% 1
    ENDIF

  disableOwnerClearState(s:tpmAbsState,a:authIn) : tpmAbsState = 
  % 1. TPM verifies authHandle properly authorizes owner
    s WITH [`permFlags(disableOwnerClear):=TRUE];			% 2

  disableOwnerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=TRUE,resAuth:=ownerAuth(a)#) IN
    OUT_DisableOwnerClear(a1,TPM_SUCCESS)				
    % TODO: 3. When this flag is TRUE... Prove this?

  disableForceClearState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`stclearFlags(disableForceClear):=TRUE];			% 1

  disableForceClearOut(s:tpmAbsState) : tpmAbsOutput = 
    OUT_DisableForceClear(TPM_SUCCESS)

  physicalPresenceState(s:tpmAbsState,p:PHYSPRES) : tpmAbsState =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN s								% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN s								% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN s								% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN s								% 2d
	 ELSE s WITH [`permFlags`physicalPresenceHWEnable:=
			IF member(HW_ENABLE,p) THEN TRUE		% 2e
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2f
			ELSE s`permFlags`physicalPresenceHWEnable ENDIF,
		      `permFlags`physicalPresenceCMDEnable:=
			IF member(CMD_ENABLE,p) THEN TRUE		% 2g
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2h
			ELSE s`permFlags`physicalPresenceCMDEnable ENDIF,
		      `permFlags`physicalPresenceLifetimeLock:=
			IF member(LIFETIME_LOCK,p) THEN TRUE		% 2i
			ELSE s`permFlags`physicalPresenceLifetimeLock ENDIF]
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN s								% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN s								% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN s								% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN s								% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN s								% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE		% 3fi
	      	     ,`stclearFlags`physicalPresenceLock:=TRUE]		% 3fii
    	 ELSIF member(PRESENT,p)					% 3g
	 THEN s WITH [`stclearFlags`physicalPresence:=TRUE]		% 3gi
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE]		% 3hi
	 ELSE s % should never get to this case.
    	 ENDIF
    ELSE s								% 4
    ENDIF

  physicalPresenceOut(s:tpmAbsState,p:PHYSPRES) : tpmAbsOutput =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2d
	 ELSE OUT_PhysicalPresence(TPM_SUCCESS)				% 2j
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)	% 3
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3fiii
    	 ELSIF member(PRESENT,p) 					% 3g
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSE OUT_Error(TPM_BAD_PARAMETER) % should never get here
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PARAMETER)					% 4
    ENDIF


  seal?(k:(tpmKey?)) : bool =
    storage?(keyUsage(k)) AND not(migratable(keyFlags(k))) %AND DECRYPTED
    
  % Output secret sealed with asymmetric key 
  % crs(S1) encrypts S2
  sealOut(s:tpmAbsState,kH:(tpmKey?),enc:(tpmEncAuth?),p:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : tpmAbsOutput = 
    % Validate the authorization to use the key pointed to by kH	% 1
    % IF inDataSize = 0 THEN OUT_Error(TPM_BAD_PARAMETER)     		% 2
    IF seal?(kH)      	     						% 3,4
    % TODO: Determine version of pcrInfo				% 5
    THEN LET h2=tpmCompositeHash((#select:=creationPCRSelect(p),	% 11bvi 
				   pcrValue:=s`pcrs#)) IN
    	 LET s1=tpmStoredData(tpmPCRInfoLong(				% 11
				s`stanyFlags`localityModifier,		% 11viii
				locAtRelease(p),			% 11bv
				creationPCRSelect(p),			% 11bii
				releasePCRSelect(p),			% 11biii
				h2,					% 11bvii
				digAtRelease(p)),			% 11biv
			      tpmNull,					% 9
			      clear) IN					% 7
	     % decrypting encAuth according to the ADIP indicated by authHandle
	 LET a1=decryptADIP(enc,authHandle(a)), % TODO: incorrect	% 12
	     h3=tpmDigest(cons(s1,null),clear) IN %TODO: SHA1(s1)	% 14c
    	 LET S3=tpmSealedData(a1,			 		% 14e
			      s`permData`tpmProof,			% 14b
			      h3,					% 14d
    	     		      inData,					% 14g
			      encrypted(key(kH),clear)) IN 		% 16
	% Validate the size(S2) can be encrypted by kH,TPM_BAD_DATASIZE % 15
	LET S1=tpmStoredData(sealInfo(s1),S3,clear),  	  		% 11,19
	    A:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,				% 17
			resAuth:=usageAuth(encDat(kH))#)
    	     IN OUT_Seal(S1,A,TPM_SUCCESS)				% 20
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)				% 3,4
    ENDIF

  unseal?(p:(tpmKey?)) : bool =	% 2,3
    storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) %AND DECRYPTED

  % Output secret unsealed with an asymmetric key and PCRs 
  unsealOut(s:tpmAbsState,parent:(tpmKey?),inData:(tpmStoredData?),
	pa,da:authIn) : tpmAbsOutput = 
    % Validate that pa authorizes the use of the key in p TPM_AUTHFAIL	% 1
    LET d=decrypt(key(parent),inData) IN				% 5
    LET d1:(tpmSealedData?)=encData(d),		      			% 5,6a
	S2=tpmStoredData(sealInfo(inData),tpmNull,clear),		% 4
	h2=tpmCompositeHash((#select:=releasePCRSelect(sealInfo(inData)),
			      pcrValue:=s`pcrs#)) IN			% 7bii
    IF not unseal?(parent)						% 2,3
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not crs(d)=clear						% 5
       THEN OUT_CPUError(CPU_DECRYPT_ERROR)
    ELSIF not(tpmProof(d1)=tpmProof(s`permData) AND			% 6b
       tpmDigest(cons(S2,null),clear)=storedDigest(d1))			% 6e,f
       % TODO: 6g,
       THEN OUT_Error(TPM_NOTSEALED_BLOB)				% 6h
    ELSIF not locAtRelease(sealInfo(S2))=localityModifier(s`stanyFlags) % 7biii
       THEN OUT_Error(TPM_BAD_LOCALITY)
    ELSIF not h2=digAtRelease(sealInfo(S2))				% 7c
       THEN OUT_Error(TPM_WRONGPCRVAL)
    % validate authorization to use d1 by checking the HMAC calculation using 
    % authData(d1) as the shared secret matches the ownerAuth(da) TPM_AUTHFAIL 
    % on mismatch     	  	 		    		  	% 8
    % TODO: authdata stuff						% 9
    ELSE let a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
    	     resAuth:=usageAuth(encDat(parent))#) IN	% TODO: made up
    	 OUT_Unseal(data(d1),a,a,TPM_SUCCESS) 			% 10,11,12
    ENDIF;
  
  unBind?(k:(tpmKey?)) : bool =
    legacy?(keyUsage(k)) OR bind?(keyUsage(k))				% 3
  
  % Output decrypted key
  unBindOut(s:tpmAbsState,k:(tpmKey?),d:(tpmBoundData?),a:authIn):tpmAbsOutput=
    % if inDataSize=0 OUT_Error(TPM_BAD_PARAMETER)			% 1
    % validate the AuthData to use the key pointed to by k		% 2
    LET d1:(tpmBoundData?)=decrypt(private(k),d) IN    	 		% 4
    IF not unBind?(k)							% 3
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not clear?(crs(d1))						% 4
       THEN OUT_CPUError(CPU_DECRYPT_ERROR)
%     ELSIF SHA1_MGF1?(encScheme(algoParms(k))) AND legacy?(keyUsage(k))% 5
%        THEN outData=payloadData(d1) d1 NOT :(tpmBoundData?)		% 5b
    ELSE LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#)
	 IN OUT_UnBind(payloadData(d1),a,TPM_SUCCESS)			% 6,7
    ENDIF  	    

  createWrapKey?(p,k:(tpmKey?)):bool = 
    storage?(keyUsage(p)) AND						% 4
    IF migratable(keyFlags(p)) AND not(migratable(keyFlags(k)))		% 5
    THEN FALSE 
    ELSE IF identity?(keyUsage(k)) OR authChange?(keyUsage(k))		% 6a
    	 THEN FALSE
	 ELSE not(migrateAuthority(keyFlags(k)))			% 6b
	 ENDIF
    ENDIF;

  createWrapKeyState(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsState =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN s
    ELSIF s`permFlags`FIPS AND						% 7
       	   (%keySize(k) < 1024 OR					% 7a
    	    never?(authDataUsage(k)) OR 				% 7b
	    legacy?(keyUsage(k)))	  				% 7c
       THEN s
    ELSIF (storage?(keyUsage(k)) or migrate?(keyUsage(k)))		% 8
    	  AND not RSA?(algoId(algoParms(k)))				% 8i
%   	  AND not SHA1_MGF1?(encScheme(algoParms(srkParms))) 		% 8ii
%   	  AND not SS_NONE?(sigScheme(algoParms(srkParms))) 		% 8iii
%   	  AND length(parms(algoParms(srkParms)))/=2048 			% 8iv
%   	  AND expSize(parms(algoParms(srkParms)))/=0			% 8v
       THEN s
    % Determine version of key						% 9
    ELSE genKeyState(s)
    ENDIF;

  % Generate a NEW RANDOM key pair.
  createWrapKeyOut(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsOutput =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF s`permFlags`FIPS AND						% 7
       	   (%keySize(k) < 1024 OR					% 7a
    	    never?(authDataUsage(k)) OR 				% 7b
	    legacy?(keyUsage(k)))	  				% 7c
       THEN OUT_Error(TPM_NOTFIPS)
    ELSIF (storage?(keyUsage(k)) or migrate?(keyUsage(k)))		% 8
    	  AND not RSA?(algoId(algoParms(k)))				% 8i
%   	  AND not SHA1_MGF1?(encScheme(algoParms(srkParms))) 		% 8ii
%   	  AND not SS_NONE?(sigScheme(algoParms(srkParms))) 		% 8iii
%   	  AND length(parms(algoParms(srkParms)))/=2048 			% 8iv
%   	  AND expSize(parms(algoParms(srkParms)))/=0			% 8v
       THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    % determine version of key						% 9
    ELSE 
    	 LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),		% 10
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)),		% 11
	     b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 12
			resAuth:=usageAuth(encDat(p))#) IN
	LET h=tpmCompositeHash((#select:=creationPCRSelect(PCRInfo(k)),
			      pcrValue:=s`pcrs#)) IN			% 15d
	LET encData=tpmStoreAsymkey(DU1,				% 14a
			IF migratable(keyFlags(k)) THEN DM1		% 14b
			ELSE s`permData`tpmProof ENDIF, 		% 14c
			%TODO: next line is incorrect?
			pubDataDigest(encDat(k)),
			privKey(encDat(k)),
			clear),
	    pcrs=tpmPCRInfoLong(s`locality,				% 15e	
				locAtRelease(PCRInfo(k)),		% 15c
				creationPCRSelect(PCRInfo(k)),		% 15c
				releasePCRSelect(PCRInfo(k)),		% 15c
				h,					% 15d
				digAtRelease(PCRInfo(k))) IN		% 15c
      	   OUT_CreateWrapKey(tpmKey(s`keyGenCnt,			% 13,14
				    keyUsage(k),
				    keyFlags(k),
				    authDataUsage(k),
				    algoParms(k),
				    pcrs,				% 15c
				    key(p),
				    encData,
				    clear),
			     b,TPM_SUCCESS)
    ENDIF
    

  loadKey2?(p,k:(tpmKey?)) : bool = 
    IF storage?(keyUsage(p)) AND key(p)=wrappingKey(k)
    THEN CASES keyUsage(k) OF
    	 identity: IF migratable(keyFlags(k))=FALSE
	 	   THEN true
		   ELSE false
		   ENDIF,
    	 authChange: false
	 ELSE true
	 ENDCASES
    ELSE false	
    ENDIF;


  %% Install key operation on TPM state.
  loadKey2State(s:tpmAbsState,p,k:(tpmKey?)) : tpmAbsState =
    IF storage?(keyUsage(p)) AND key(p)=wrappingKey(k)
    THEN CASES keyUsage(k) OF
    	 identity: IF migratable(keyFlags(k))=FALSE
	 	   THEN s with [`keys:=loadKey(k,srk(s),keys(s),pcrs(s))]
		   ELSE s
		   ENDIF,
    	 authChange: s
	 ELSE s with [`keys:=loadKey(k,srk(s),keys(s),pcrs(s))]
	 ENDCASES
    ELSE s	
    ENDIF;
% TODO:  Do we need to check this?
%       IF validateLoadKey2?(s,parentHandle,k)
%       THEN s with [`keys:=addKey(k,srk(s),keys(s),pcrs(s))]
%       ELSE s
%       ENDIF


  validateKeyConsistency(s:tpmAbsState,p,k:(tpmKey?)) : nat = 
    0 % TODO: uncomment when authdata figured out
%     IF migrationAuth(k)=tpmProof(permData(s))
%     THEN IF FIPS(permFlags(s)) 
%     	 THEN IF authNever?(authDataUsage(k)) OR legacy?(keyUsage(k)) 
%       	      THEN 3 % TPM_NOTFIPS
% 	      ELSE 0 % OUT_LoadKey2(inKey,TPM_SUCCESS)
% 	      ENDIF
%     	 ELSE 0 % OUT_LoadKey2(inKey,TPM_SUCCESS)
%     	 ENDIF
%     ELSE 0 % OUT_LoadKey2(inKey,TPM_SUCCESS)
%     ENDIF

  validateLoadKey2(s:tpmAbsState,p,k:(tpmKey?)) : nat = 
    IF storage?(keyUsage(p))		      % 2
    THEN IF key(p)=wrappingKey(k)     	      % ~5
	 THEN CASES keyUsage(k) OF		      
	      identity: IF migratable(keyFlags(k))=FALSE  % 7b
	      		THEN validateKeyConsistency(s,p,k)%OUT_LoadKey2(inKey,TPM_SUCCESS) 
			ELSE 1 % TPM_INVALID_KEYUSAGE % 7b
			ENDIF,
	      authChange: 1 % TPM_INVALID_KEYUSAGE  %7c
	      ELSE validateKeyConsistency(s,p,k)
	      ENDCASES
    	 ELSE 2 % OUT_CPUError(CPU_DECRYPT_ERROR) %% TODO: Might not be right.
	 ENDIF
    ELSE 1 % TPM_INVALID_KEYUSAGE	      % 2
    ENDIF;

  loadKey2Out(s:tpmAbsState,parentHandle:(tpmKey?),inKey:(tpmKey?)) : tpmAbsOutput = 
    LET num = validateLoadKey2(s,parentHandle,inKey) IN
      COND 
      num=0 -> OUT_LoadKey2(inKey,TPM_SUCCESS),
      num=1 -> OUT_Error(TPM_INVALID_KEYUSAGE),
      num=2 -> OUT_CPUError(CPU_DECRYPT_ERROR),
      num=3 -> OUT_Error(TPM_NOTFIPS),
      ELSE -> OUT_Error(TPM_FAIL) %TODO: incorrect?
      ENDCOND


  checkMigKeyAuth?(s:tpmAbsState,a:(tpmMigKeyAuth?)):bool =
    digest(a)=tpmDigest(cons(key(a),
			     cons(scheme(a),
				  cons(s`permData`tpmProof, % TODO: CHECK
				       null))),clear)
  
  createMigBlob?(s:tpmAbsState,p:(tpmKey?),m:migrateScheme,a:(tpmMigKeyAuth?),e:tpmData) : bool = 
    storage?(keyUsage(p)) AND
    CASES e OF
      tpmKey(k,ku,kf,ka,kap,pcr,wk,eu,crs) : 
	   key(p)=k AND checkMigKeyAuth?(s,a) AND
	   	CASES m OF
      	   	  migrate : FALSE, %TODO : not correct!
		  rewrap  : TRUE
		ENDCASES	
      ELSE FALSE
    ENDCASES

  createMigBlobOut(s:tpmAbsState,parent:(tpmKey?),migType:migrateScheme,
			 migKeyAuth:(tpmMigKeyAuth?),encData:tpmData) : tpmAbsOutput =
    IF storage?(keyUsage(parent))
    THEN CASES encData OF
    	 tpmKey(k,ku,kf,a,kap,pcr,wk,e,crs) : 
	   IF key(parent)=k
	   THEN IF checkMigKeyAuth?(s,migKeyAuth)
	   	THEN CASES migType OF
      	   	     migrate: OUT_Error(TPM_INSTALL_DISABLED),%TODO: not correct!
		     rewrap : OUT_CreateMigrationBlob(0,
				tpmKey(k,ku,kf,a,kap,pcr,
					key(key(migKeyAuth)),e,clear),
				TPM_SUCCESS)
		     %ELSE OUT_Error(TPM_BAD_PARAMETER)
		     ENDCASES	
	      	ELSE OUT_Error(TPM_RESOURCES) % TODO: not at all correct.
	      	ENDIF
    	   ELSE OUT_CPUError(CPU_DECRYPT_ERROR) % TODO: not correct?
	   ENDIF
	 ELSE OUT_Error(TPM_WRONG_ENTITYTYPE) % TODO: not correct?
    	 ENDCASES
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF

%   convertMigBlobOut(s:tpmAbsState,parent:(tpmKey?),inData:tpmData,rand:int) : tpmAbsOutput =
%     IF storage?(keyUsage(parent))
%     THEN LET d1=decrypt(key(parent),inData) IN
% %     	 LET o1=d1 xor rand IN
% % 	 OAEP decoding o1?
% % 	 LET m1=tpmMigrateAsymkey(usageAuth:(tpmSecret?),pubDataDigest:(tpmDigest?),partPrivKey:(tpmKey?)),seed?,pHash?
% 	 LET k1=tpmStorePrivkey(partPrivKey(m1)) IN
% % 	 IF payload(m1)=TPM_PT_MIGRATE 
% % 	 THEN 
% 	 LET d2=tpmStoreAsymkey(%TPM_PT_ASYM,
% 				usageAuth(m1),
% 				pHash,
% 				pubDataDigest(m1),
% 				k1,	
% 				encrypted(parent,clear)) IN
% 	OUT_CreateMigrationBlob(d2,TPM_SUCCESS)
% %	ELSE I don't know what
%     ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
%     ENDIF
    
  authorizeMigKeyOut(s:tpmAbsState,migKey:(tpmKey?),migScheme:(tpmMigScheme?)) : tpmAbsOutput = 
    OUT_AuthorizeMigrationKey(
	tpmMigKeyAuth(migKey,
		      migScheme,
		      tpmDigest(cons(migKey,%cons(migScheme,cons(tpmProof(permData(s)),null))))),
						null),clear),
		      clear),
	TPM_SUCCESS);

  %% Decrypts the input packet (coming from TPM_CreateMigrationBlob) and then 
  %% re-encrypts it with the input public key. The output would then be sent to 
  %% TPM_ConvertMigrationBlob on the target TPM.
  migrateKeyOut(s:tpmAbsState,maKey,pubKey:(tpmKey?),inData:tpmData) : tpmAbsOutput =
    IF migrate?(keyUsage(maKey))
      %The TPM decripts inData and re-encrypts it using pubKey
      %THEN outBlob(encryptBlob(pubKey,blob(inData)),TPM_SUCCESS)
      THEN OUT_MigrateKey(encrypt(key(pubKey),decrypt(key(maKey),inData)),TPM_SUCCESS)
      ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF

  sign?(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : bool = 
    signing?(keyUsage(key)) OR legacy?(keyUsage(key))

  % Sign a blob if signing key isn't aik
  % TODO: add signature scheme (makes this more complicated)
  signOut(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : tpmAbsOutput=
    IF signing?(keyUsage(key)) OR legacy?(keyUsage(key)) 
    THEN OUT_Sign(sign(key(key),areaToSign),TPM_SUCCESS)
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF

  createEndorsementKeyPairState(s:tpmAbsState,antiReplay:(tpmNonce?),keyInfo:(tpmKey?)) : tpmAbsState = 
    IF goodkey?(key(ek(s)))
    THEN s
    ELSE s WITH [`ek := privateKey(keyInfo)
    	   	,`permFlags(CEKPUsed) := TRUE
		,`permFlags(enableRevokeEK) := FALSE]
    ENDIF;

  % If ek doesn't exist, create a new ek from keyInfo
  createEndorsementKeyPairOut(s:tpmAbsState,antiReplay:(tpmNonce?),keyInfo:(tpmKey?)) : tpmAbsOutput = 
    IF goodkey?(key(ek(s)))
      THEN OUT_Error(TPM_DISABLED_CMD) 
      ELSE OUT_CreateEndorsementKeyPair(keyInfo,tpmDigest(cons(keyInfo,cons(antiReplay,null)),clear),TPM_SUCCESS)
    ENDIF;

  createRevEKState(s:tpmAbsState,antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	generateReset:bool,inputEKreset:(tpmNonce?)) : tpmAbsState =
    IF goodkey?(key(ek(s)))
    THEN s
    ELSE LET s1=createEndorsementKeyPairState(s,antiReplay,keyInfo) IN
    	 s1 WITH [`permFlags(enableRevokeEK):=TRUE,
	     	  `permData(ekReset):= 
		  	%IF generateReset 
			%THEN next(TPM_RNG)
			%ELSE 
			inputEKreset
			%ENDIF
	     	 ]
    ENDIF;
    
  createRevEKOut(s:tpmAbsState,antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	generateReset:bool,inputEKreset:(tpmNonce?)) : tpmAbsOutput = 
    IF goodkey?(key(ek(s)))
    THEN OUT_Error(TPM_DISABLED_CMD) 
    ELSE LET checksum=tpmDigest(cons(keyInfo,cons(antiReplay,null)),clear),
    	     pubEK=tpmPubkey(key(keyInfo)) IN 
	 OUT_CreateRevocableEK(pubEK,
			       checksum,
			       %IF generateReset...
			       inputEKreset,
			       TPM_SUCCESS)
    ENDIF;

  revokeTrust?(s:tpmAbsState,ekReset:(tpmNonce?)) : bool =
    enableRevokeEK(permFlags(s)) AND ekReset(permData(s))=ekReset

  revokeTrustState(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsState = 
    IF enableRevokeEK(permFlags(s)) AND ekReset(permData(s)) = ekReset
    THEN %ensure physical presence is being asserted
    	 LET s1 = clear(s) IN
	 s1 WITH [`permFlags(nvLocked):=FALSE,
% 	      	  `permData(tpmDAASeed):=,
% 		  `permData(daaProof):=,
% 		  `permData(daaBlobKey):=,
		  `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),
			      authDataUsage(s`ek),algoParms(s`ek),
			      PCRInfo(s`ek),wrappingKey(s`ek),
			      encDat(s`ek),crs(s`ek))
		]
    ELSE s
    ENDIF;

  revokeTrustOut(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsOutput =
    IF enableRevokeEK(permFlags(s)) 
    THEN IF ekReset(permData(s)) = ekReset 
    	 THEN %ensure physical presence is being asserted
      	      OUT_RevokeTrust(TPM_SUCCESS) 
	 ELSE OUT_Error(TPM_AUTHFAIL) 
	 ENDIF
    ELSE OUT_Error(TPM_PERMANENTEK) 
    ENDIF;

  readPubek?(s:tpmAbsState,n:(tpmNonce?)) : bool = 
    readPubek(permFlags(s)) AND goodkey?(key(ek(s)))

  readPubekOut(s:tpmAbsState,n:(tpmNonce?)) : tpmAbsOutput =
    IF readPubek(permFlags(s))
      THEN IF goodkey?(key(ek(s)))
      	     THEN LET pubEK=publicKey(ek(s)) IN
	     	  OUT_ReadPubek(pubEK,
				tpmDigest(cons(pubEK,cons(n,null)),clear),
				TPM_SUCCESS)
	     ELSE OUT_Error(TPM_NO_ENDORSEMENT)
	   ENDIF
      ELSE OUT_Error(TPM_DISABLED_CMD)
    ENDIF

  makeIdentity?(s:tpmAbsState,CADigest:(tpmDigest?),idKeyParams:(tpmKey?)) : bool =
	identity?(keyUsage(idKeyParams)) AND migratable(keyFlags(idKeyParams))=FALSE

  makeIdentityState(s:tpmAbsState,CADigest:(tpmDigest?),idKeyParams:(tpmKey?)) : tpmAbsState = 
    IF identity?(keyUsage(idKeyParams)) AND migratable(keyFlags(idKeyParams))=FALSE
    THEN genKeyState(s)
    ELSE s
    ENDIF;

  setDigAtCreation(s:tpmAbsState,pcr:(tpmPCRInfoLong?)) : (tpmCompositeHash?) =
    LET digest:PCR_COMPOSITE=(# select:=creationPCRSelect(pcr),
    			        pcrValue:=pcrs(s) #)
    IN tpmCompositeHash(digest);

  makeIdentityLocality : LOCALITY

  % Output a newly generated AIK.  Note that a simulates the new aik.
  makeIdentityOut(s:tpmAbsState,CADigest:(tpmDigest?),idKeyParams:(tpmKey?)) : tpmAbsOutput =
    IF identity?(keyUsage(idKeyParams)) AND migratable(keyFlags(idKeyParams))=FALSE
      THEN LET pcr= tpmPCRInfoLong(makeIdentityLocality,
				   locAtRelease(PCRInfo(idKeyParams)),
				   creationPCRSelect(PCRInfo(idKeyParams)),
				   releasePCRSelect(PCRInfo(idKeyParams)),
				   setDigAtCreation(s,PCRInfo(idKeyParams)),
				   digAtRelease(PCRInfo(idKeyParams))) IN
      	   LET idKey:(tpmKey?) = tpmKey(keyGenCnt(s),
					keyUsage(idKeyParams),
					keyFlags(idKeyParams),
					authDataUsage(idKeyParams),
					algoParms(idKeyParams),
					pcr,
					wrappingKey(srk(s)),
					encDat(idKeyParams),
					clear) IN 
		LET idBinding = tpmIdContents(CADigest,
					      idKey,
					      signed(private(idKey),clear)) IN
    		    OUT_MakeIdentity(idKey,idBinding,TPM_SUCCESS)
      ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF;

  % Use an AIK. 
  % TODO: Should this be loaded here (or ever)?
%   activateIdentityState(s:tpmAbsState,a:(wrapKey?),b:BLOB) : tpmAbsState =
%     loadKey2State(s,srk(s),a);

  % Retrieve a key if a can be installed
  % The command assumes the availability of the private key associated with the identity.
  % The command will verify the association between the keys during the process.
  % The command will decrypt the input blob and extract the session key and verify the
  % connection between the public and private keys. p 157
  activateIdentityOut(s:tpmAbsState,idKey:(tpmKey?),b:(activateIdentityBlob?)) : tpmAbsOutput =
    IF identity?(keyUsage(idKey)) 
    THEN LET h1=tpmDigest(cons(tpmPubkey(key(idKey)),null),clear),
    	     b1=decrypt(private(ekVal),b) IN
	 CASES b1 OF
	 tpmAsymCAContents(k,d,crs) : 
	 	IF h1=d and not(encrypted?(crs))
		THEN OUT_ActivateIdentity(k,TPM_SUCCESS)
		ELSE OUT_Error(TPM_BAD_PARAMETER)
		ENDIF,
	 tpmEKBlob(blob,crs) :
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) : 
			IF h1=d and not(encrypted?(crs))
			THEN % TODO: do some pcr check
			     OUT_ActivateIdentity(k,TPM_SUCCESS)
			ELSE OUT_Error(TPM_BAD_PARAMETER)
			ENDIF
		ELSE OUT_Error(TPM_BAD_TYPE)
		ENDCASES
	 ELSE OUT_Error(TPM_BAD_PARAMETER) % TODO: may be incorrect
	 ENDCASES
    ELSE OUT_Error(TPM_BAD_PARAMETER)
    ENDIF;
        
  %% Extend operation on TPM state
  extendState(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsState =
    s WITH [`pcrs := pcrsExtend(pcrs(s),pcrNum,inDigest)];

  extendOut(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsOutput = 
  %% TODO: will pcrNum not be allowed to be > 23 because of defn of PCRINDEX? 
  %% Should throw TPM_BADINDEX if outside range
    IF disable(permFlags(s)) %OR deactivated(STCLEAR_FLAGS)
    THEN OUT_Extend(reset,TPM_SUCCESS)
    ELSE OUT_Extend(extend(pcrs(s)(pcrNum),inDigest),TPM_SUCCESS)
    ENDIF    

  % Output PCR of given index
  pcrReadOut(s:tpmAbsState,ind:PCRINDEX) : tpmAbsOutput = 
  %% TODO: will ind not be allowed to be > 23 because of defn of PCRINDEX? 
  %% Should throw TPM_BADINDEX if outside range
     LET p = pcrs(s) IN OUT_PCRRead(p(ind),TPM_SUCCESS)

  % Output PCRs from a state as quote
  quoteOut(s:tpmAbsState,keyHandle:(tpmKey?),externalData:(tpmNonce?),targetPCR:PCR_SELECTION) : tpmAbsOutput =
  %% TODO: will pm be allowed to have elements > 23? see pcrReadOut 
%      IF checkKeyRoot(keyHandle,srk(s))
%      THEN 
     LET pcrData=getPCRs(s`pcrs,targetPCR) IN
	OUT_Quote(pcrData,
		  tpmQuote(tpmCompositeHash((#select:=targetPCR,pcrValue:=pcrs(s)#)),
			   externalData,
			   signed(private(keyHandle),clear)),
		  TPM_SUCCESS)
%      ELSE OUT_Error(TPM_INVALID_KEYUSAGE) %% TODO: double check this
%      ENDIF

  dataBindOut(s:tpmAbsState,k:(tpmKey?),d:tpmData) : tpmAbsOutput = 
    OUT_Data_Bind(tpmBoundData(d,encrypted(key(k),clear)),CPU_SUCCESS);

  %% TODO: should this be able to affect state? i don't think so.
  certState(s:tpmAbsState,aik:(tpmKey?),certReq:(tpmIdContents?)) : tpmAbsState =
    LET d:(tpmIdContents?)=decrypt(key(aik),certReq) IN
    	IF crs(d)=clear AND tpmDigest?(digest(certReq))
	THEN genKeyState(s)
	ELSE s
	ENDIF

  % Generate a certified AIK from an AIK.  Certification assumes that the
  % EK really does belong to the TPM.  We're abstracting away that check.
  certOut(s:tpmAbsState,aik:(tpmKey?),certReq:(tpmIdContents?)) : tpmAbsOutput =
    LET d:(tpmIdContents?)=decrypt(key(aik),certReq) IN
    	IF crs(d)=clear AND tpmDigest?(digest(certReq))
	THEN OUT_Certify(tpmAsymCAContents(tpmSessKey(keyGenCnt(s),clear),
					   digest(certReq),
					   encrypted(key(ekVal),clear)),
			 CPU_SUCCESS)
	ELSE OUT_CPUError(CPU_DECRYPT_ERROR)
	ENDIF
  
  % Read a value and output
  readOut(s:tpmAbsState,i:nat) : tpmAbsOutput = 
    s`memory(i);

  %% Revoke key operation on TPM state
  revokeKeyState(s:tpmAbsState,k:(tpmKey?)) : tpmAbsState =
    s WITH [`keys := revokeKey(k,keys(s))];


  restoreState(s:tpmAbsState) : tpmAbsState =
    IF valid?(restore(s))
       THEN LET rs=restore(s) IN
             (# restore := rs
	      , memory := memory(s)
	      , ek := ek(rs)
	      , srk := srk(rs)
	      , pcrs := pcrs(rs)
	      , keys := keys(rs)
	      , keyGenCnt:=keyGenCnt(rs)
	      , locality := 3
	      , permFlags := permFlags(rs)
	      , permData := permData(rs)
	      , stanyFlags := stanyFlags(rs)
	      , stanyData := stanyData(rs)
	      , stclearFlags := stclearFlags(rs)
	      , stclearData := stclearData(rs)
            #)
       ELSE s
    ENDIF;

  % deactivate by going back to init.  Not sure this is correct.
  deactivateState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`stanyFlags(postInitialize) := TRUE];

  % save a value to external memory
  saveToMemState(s:tpmAbsState,i:nat,v:tpmAbsOutput) : tpmAbsState =
    s WITH [`memory := updateLoc(memory(s),i,v)];

  %% What we want to generate with each command is a pair of type
  %% [tpmAbsOut,tpmAbsState].  executeCom generates the the state
  %% from a TPM state and command while the upcoming outputCom
  %% generates the corresponding output.  Thus, to execute any
  %% operation, both executeCom and outputCom must be used

  %% Run if TPM_Init has run but TPM_Startup has not
  executeComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsState =
    CASES c OF
      ABS_Startup(t) : CASES t OF 
      		        TPM_ST_CLEAR : tpmStartup,
    			TPM_ST_STATE : restoreState(s),
    			TPM_ST_DEACTIVATED : deactivateState(s)
                       ENDCASES
      ELSE s
    ENDCASES;

  %% Run if ABS_Startup has run after TPM_Init
  executeComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsState = 
    CASES c OF
      ABS_Init : tpmPostInit,
      ABS_SaveState : saveState(s),
      ABS_TakeOwnership(oA,sA,srk,a) : takeOwnershipState(s,oA,sA,srk,a),
      ABS_OwnerClear(a): ownerClearState(s,a),
      ABS_ForceClear: forceClearState(s),
      ABS_DisableOwnerClear(a): disableOwnerClearState(s,a),
      ABS_DisableForceClear: disableForceClearState(s),
      ABS_PhysicalPresence(p): physicalPresenceState(s,p),
      ABS_CreateWrapKey(p,k,u,m,a) : createWrapKeyState(s,p,k,u,m,a),
      ABS_LoadKey2(p,k): loadKey2State(s,p,k), 
      ABS_CreateEndorsementKeyPair(n,k) : createEndorsementKeyPairState(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKState(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustState(s,r),
      ABS_MakeIdentity(d,k) : makeIdentityState(s,d,k), 
      ABS_Extend(n,d) : extendState(s,n,d),
      ABS_certify(k,cr) : certState(s,k,cr),
      ABS_senter : 
        changeLocalityState(extendState(pcrsResetSenterState(s),0,hash(sinit))),
      ABS_sinit : changeLocalityState(extendState(s,0,hash(mle))),
      ABS_save(i,v) : saveToMemState(s,i,v)
      ELSE s
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  executeCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsState =
    IF afterInit?(s)
    THEN executeComPostInit(s,c)
    ELSE executeComStartup(s,c)
    ENDIF;

  %% Run if TPM_Init has run but TPM_Startup has not
  outputComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsOutput =
    OUT_Error(TPM_SUCCESS);

  %% Generate output from a command and state 
  %% Run if ABS_Startup has run after TPM_Init
  outputComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsOutput = 
    CASES c OF
      ABS_TakeOwnership(oAuth,srkAuth,srk,a) : takeOwnershipOut(s,oAuth,srkAuth,srk,a),
      ABS_OwnerClear(a) : ownerClearOut(s,a),
      ABS_ForceClear : forceClearOut(s),
      ABS_DisableOwnerClear(a) : disableOwnerClearOut(s,a),
      ABS_DisableForceClear : disableForceClearOut(s),
      ABS_PhysicalPresence(p) : physicalPresenceOut(s,p),
      ABS_Seal(k,e,p,data,a) : sealOut(s,k,e,p,data,a),
      ABS_Unseal(d,k,pa,da) : unsealOut(s,d,k,pa,da),
      ABS_UnBind(k,d,a) : unBindOut(s,k,d,a),
      ABS_Data_Bind(k,d) : dataBindOut(s,k,d),
      ABS_CreateWrapKey(parent,k,u,m,a) : createWrapKeyOut(s,parent,k,u,m,a),
      ABS_LoadKey2(p,k) : loadKey2Out(s,p,k),
      ABS_CreateMigrationBlob(pk,m,migKAuth,encData) : 
      				createMigBlobOut(s,pk,m,migKAuth,encData),
%       ABS_ConvertMigrationBlob(k,d,r) : convertMigBlobOut(s,k,d,r),
      ABS_AuthorizeMigrationKey(mk,ms) : authorizeMigKeyOut(s,mk,ms),
      ABS_MigrateKey(mk,pubKey,data) : migrateKeyOut(s,mk,pubKey,data),
      ABS_Sign(k,a) : signOut(s,k,a),
      ABS_CreateEndorsementKeyPair(n,k) : createEndorsementKeyPairOut(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKOut(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustOut(s,r),
      ABS_ReadPubek(n) : readPubekOut(s,n),
      ABS_MakeIdentity(d,k) : makeIdentityOut(s,d,k),
      ABS_ActivateIdentity(a,b) : activateIdentityOut(s,a,b),
      ABS_Extend(n,d) : extendOut(s,n,d),
      ABS_PCRRead(ind) : pcrReadOut(s,ind),
      ABS_Quote(k,n,pm) : quoteOut(s,k,n,pm),
      ABS_certify(aik,cr) : certOut(s,aik,cr),
      ABS_read(i) : readOut(s,i)
    ELSE OUT_Error(TPM_SUCCESS)
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  outputCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsOutput =
    IF afterInit?(s)
       THEN outputComPostInit(s,c)
       ELSE outputComStartup(s,c)
    ENDIF;


  %% CPU Command Definitions

  %% Requires use of bind
  CPU_saveOutput(i:nat) : [tpmAbsOutput -> State] =
      useOutputStateOutput(
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    executeCom(s,ABS_save(i,a)))),
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    a)));

  CPU_read(i:nat) : State =
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_read(i)));

  %% Call SENTER 
  CPU_senter : State =
    modify(OUT_Error(TPM_SUCCESS),
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_senter)));

  %% Reset the TPM by senter call - depreciated - DO NOT USE
  %senterResetTPM : State = put(OUT_Error(TPM_SUCCESS),tpmStartup);

  %% Measure sinit by senter call - depreciated - DO NOT USE
  %senterHashSinitTPM : State = TPM_Extend(hash(sinit),0);

  %% Call sinit for initial measurements
  CPU_sinit : State =
    modify(OUT_Error(TPM_SUCCESS),
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_sinit)));
 
  CPU_BuildQuoteFromMem(q,idcont:nat):State =
    output(LAMBDA (s:tpmAbsState) :
	       LET theMem = memory(s) IN
	         IF OUT_Quote?(theMem(q)) AND tpmQuote?(sig(theMem(q)))
		    AND OUT_MakeIdentity?(theMem(idcont))
                 THEN  OUT_FullQuote(sig(theMem(q)),idBinding(theMem(idcont)),CPU_SUCCESS)
		 ELSE OUT_CPUError(CPU_QUOTE_ERROR) %% TODO: Incorrect?
		 ENDIF);

  %% CA Command Definitions
  %% Invoke the certification authority
  CA_certify(aik:(tpmKey?),cr:(tpmIdContents?)) : State =
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_certify(aik,cr))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_certify(aik,cr))));

  %% Assure the CA generates an appropriate cert from the AIK and Ek
  %% proved - Wed Jul 11 13:14:11 EDT 2012
  gen_cert: THEOREM 
    FORALL (state:(afterStartup?),aik:(tpmKey?),id:(tpmIdContents?)) :
      LET (a,s) = runState(
      	  	  CA_certify(aik,id))
		  (state) IN
    LET d=decrypt(key(aik),id) IN
    	IF crs(d)=clear and tpmDigest?(digest(id))
	THEN a=OUT_Certify(tpmAsymCAContents(tpmSessKey(keyGenCnt(state),clear),
					   digest(id),
					   encrypted(key(ekVal),clear)),
			   CPU_SUCCESS)
	     AND s = state WITH [`keyGenCnt := keyGenCnt(state)+1]
	ELSE a=OUT_CPUError(CPU_DECRYPT_ERROR) %TODO: may be incorrect
	     AND s=state
	ENDIF
	
  %% TPM Command Definitions - Note that all commands used by the TPM
  %% have the TPM suffix to distinguish from operations on tpm state.
  %% Commands thus far are defined as state transforming or output
  %% generating.  This does not exclude the eventuality of doing both.

  %% No-op - not a real TPM command
  TPM_Noop : [tpmAbsOutput -> State] =
    (LAMBDA (a:tpmAbsOutput): state((LAMBDA(s:tpmAbsState) : (a,s))));

  %% TPM is off - not a real TPM command
  TPM_Off : State = put(OUT_Nothing,tpmUnknown);

  %% Power up the TPM and hit the TPM_Init signal
  TPM_Init : State = put(OUT_Init(TPM_SUCCESS),tpmPostInit);

  init_post : THEOREM
    FORALL (state:tpmAbsState) :
      LET (a,s) = runState(TPM_Init)(state) IN
       	  a=OUT_Init(TPM_SUCCESS) AND
       	  s=tpmPostInit

  %% Save the TPM state in preparation for restore at startup
  TPM_SaveState : State =
    modify(OUT_SaveState(TPM_SUCCESS),
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_SaveState)))
  
  %% Save state actually saves the correct information.
  %% proved - Fri Sep 14 11:20:25 CDT 2012
  save_state_post : THEOREM
    FORALL (s0:(afterStartup?)) : 
      LET (a,s) = runState(TPM_SaveState)(s0) IN
       LET save = restore(s) IN
        valid?(save)
	AND keys(save) = keys(s0)
	AND ek(save) = ek(s0)
	AND srk(save) = srk(s0)
	AND FORALL (i:PCRINDEX) : 
	      IF pcrReset(pcrAttrib(permData(save))(i))
	         THEN pcrs(save)(i) = resetOne
		 ELSE pcrs(save)(i) = pcrs(s0)(i)
	      ENDIF
	AND permFlags(save) = permFlags(s0)
	AND permData(save) = permData(s0)
	AND a=OUT_SaveState(TPM_SUCCESS)

  %% Start up the TPM after TPM_Init
  TPM_Startup(st:TPM_STARTUP_TYPE) : State =
    modify(OUT_Startup(TPM_SUCCESS),
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Startup(st))));

  %% TPM_Startup post condition covering three major cases: clear, restore
  %% state and deactivate.
  %% proved - Sat Sep 15 09:58:36 CDT 2012
  startup_post : THEOREM
    FORALL (s0:(afterInit?), f:TPM_STARTUP_TYPE) : 
      LET (a,s) = runState(TPM_Startup(f))(s0) IN
       LET save = restore(s) IN
        CASES f OF
          TPM_ST_CLEAR : s = tpmStartup,
	  TPM_ST_STATE : valid?(save) AND wellFormedRestore?(save) =>
	                      keys(save) = keys(s)
			      AND ek(save) = ek(s)
			      AND srk(save) = srk(s)
			      AND FORALL (i:PCRINDEX) : 
	      		      	    IF pcrReset(pcrAttrib(permData(save))(i))
	         		    THEN pcrs(save)(i) = resetOne
		 		    ELSE pcrs(save)(i) = pcrs(s)(i)
	      			    ENDIF
			      AND permFlags(save) = permFlags(s)
			      AND permData(save) = permData(s),
	  TPM_ST_DEACTIVATED : postInitialize(stanyFlags(s))
        ENDCASES
	AND a=OUT_Startup(TPM_SUCCESS)

  %% Prove that the only command that can run and do anyting folling a
  %% TPM_Init is TPM_Startup.  If anything else tries to run, nothing happens. 
  %% Note the use of an "anything" command in the first command sequence.
  startup_after_init: THEOREM 
    FORALL (s:tpmAbsState,a:tpmAbsOutput,c:tpmAbsInput) :
      NOT ABS_Startup?(c) =>
        LET (a0,s0) = runState(TPM_Init 
	    	      >> state(LAMBDA (s:tpmAbsState) : 
		      	 	      	(a,executeCom(s,c))))(s) IN
          LET (a1,s1) = runState(TPM_Init)(s) IN
	      s0=s1


  %% Prove that senter after power up results in reset PCRs followed by sinit
  %% measurement.
  %% proved - Tue Jun 12 15:31:12 CDT 2012
  resetMonad: THEOREM 
    FORALL (hv:HV, state:tpmAbsState) :
      LET (a,s) = runState(
      	          TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
      		  >> CPU_senter
      		  >> CPU_sinit)
      		  (state)
      IN s = changeLocalityState(
               changeLocalityState(
                 extendState(
                   extendState(pcrsResetSenterState(tpmStartup),0,hash(sinit)),
			0,hash(mle))))
      AND a = OUT_Error(TPM_SUCCESS)


  %% Establish SRK
  TPM_TakeOwnership(ownerA,srkA:(tpmEncAuth?),srk:(tpmKey?),a:authIn) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : 
			executeCom(s,ABS_TakeOwnership(ownerA,srkA,srk,a))),
	(LAMBDA (s:tpmAbsState) : 
			outputCom(s,ABS_TakeOwnership(ownerA,srkA,srk,a))));
	 
  take_ownership_post: THEOREM FORALL (state:(afterStartup?),srk:(tpmKey?),
  	eOA,eSA:(tpmEncAuth?),aIn:authIn) : 
    LET (a,s) = runState(
		 TPM_TakeOwnership(eOA,eSA,srk,aIn))
		 (state) IN
    IF takeOwnership?(state,srk) 
    THEN LET A2=decryptADIP(eSA,authHandle(aIn)),
    	     A1=decryptADIP(eOA,authHandle(aIn)) IN
    	 LET asymkey=tpmStoreAsymkey(A2,
			migrationAuth(encDat(srk)),
			pubDataDigest(encDat(srk)),
			privKey(encDat(srk)),
			crs(encDat(srk))) IN
	 LET K1=tpmKey(key(srk),keyUsage(srk),keyFlags(srk),
		      authDataUsage(srk),algoParms(srk),
		      PCRInfo(srk),wrappingKey(srk),asymkey,
		      crs(srk)),
	     aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		    contAuthSess:=TRUE,resAuth:=A1#) IN
   	 a=OUT_TakeOwnership(K1,aOut,TPM_SUCCESS)
	 AND 
     	 s=state WITH [`srk:=K1
		      ,`permData(ownerAuth):=A1
		      ,`permFlags(readPubek):=FALSE]
    ELSIF i(state`permData`ownerAuth)/=INVALIDAUTH 
    	  THEN a=OUT_Error(TPM_OWNER_SET) AND s=state
    ELSIF not state`permFlags`ownership 
	  THEN a=OUT_Error(TPM_INSTALL_DISABLED) AND s=state 
    ELSIF not goodkey?(key(state`ek)) 
    	  THEN a=OUT_Error(TPM_NO_ENDORSEMENT) AND s=state 
    ELSIF not storage?(keyUsage(srk)) 
    	  THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(srk)) 
    	  THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF not RSA?(algoId(algoParms(srk))) 
    	  THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state 
    ELSIF s`permFlags`FIPS AND never?(authDataUsage(srk)) 
    	  THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;

  unique_error: THEOREM
    FORALL (b0,b1:ReturnCode) : OUT_Error(b0)=OUT_Error(b1) iff b0=b1;

  take_ownership_post2: THEOREM FORALL (state:(afterStartup?),srk:(tpmKey?),
  	eOA,eSA:(tpmEncAuth?),aIn:authIn) : 
    LET (a,s) = runState(
		 TPM_TakeOwnership(eOA,eSA,srk,aIn))
		 (state) IN
    not (takeOwnership?(state,srk)) =>
    not (a=OUT_Error(TPM_SUCCESS))


  % To be used with commands that use clear command: 
  %  TPM_OwnerClear, TPM_ForceClear, TPM_RevokeTrust
  clear_post(s,state:(afterStartup?),a,af,at:tpmAbsOutput,p:bool) : bool = 
        % 4. The TPM MUST NOT modify the following TPM_PERMANENT_DATA items
    %s`permData`endorsementKey = state`permData`endorsementKey AND	% 4a
    %s`permData`revMajor = state`permData`revMajor AND	       		% 4b
    %s`permData`revMinor = state`permData`revMinor AND			% 4c
    %s`permData`manuMaintPub = state`permData`manuMaintPub AND		% 4d
    %s`permData`auditMonotonicCounter = state`permData`auditMonotonicCounter AND
    %s`permData`monotonicCounter = state`permData`monotonicCounter AND	% 4f
    s`permData`pcrAttrib = state`permData`pcrAttrib AND		   	% 4g
    %s`permData`rngState = state`permData`rngState AND			% 4h
    s`permData`ekReset = state`permData`ekReset	   			% 4i
    %s`permData`lastFamilyID = state`permData`lastFamilyID AND		% 4j
    %s`permData`tpmDAASeed = state`permData`tpmDAASeed AND 		% 4k
    %s`permData`authDIR[0] = state`permData`authDIR[0] AND		% 4l
    %s`permData`daaProof = state`permData`daaProof AND 			% 4m
    %s`permData`daaBlobKey = state`permData`daaBlobKEY;			% 4n
    AND
    	 IF p
    	 THEN a=at AND s=state
	 ELSE a=af AND 
	      keys(s) = emptyset AND					% 3
	      s`permData`ownerAuth = tpmSecret(INVALIDAUTH) AND		% 5a
    	      %s`permData`srk =  AND 			  		% 5b
	      %s`permData`delegateKey =  AND				% 5c
	      %s`permData`delegateTable =  AND				% 5d
	      %s`permData`contextKey =  AND				% 5e
	      s`permData`tpmProof = tpmSecret(INVALIDPROOF) AND		% 5f
	      s`permData`operatorAuth = tpmSecret(INVALIDAUTH) AND	% 5g
	      s`permFlags = state`permFlags WITH
    		  [`disable:=disableDef					% 9a
		  ,`deactivated:=deactivatedDef				% 9b
		  ,`readPubek:=readPubekDef				% 9c
		  ,`disableOwnerClear:=disableOwnerClearDef		% 9d
		  ,`disableFullDALogicInfo:=disableFullDALogicInfoDef	% 9e
		  ,`allowMaintenance:=allowMaintenanceDef		% 9f
		  ,`readSRKPub:=readSRKPubDef				% 9g
		  ,`ownership:=TRUE					% 10a
		  ,`operator:=FALSE					% 10b
		  ,`maintenanceDone:=FALSE]				% 10b
	      %% TODO: AND LOTS MORE STUFF!
	 ENDIF
    % TODO: TPM_OwnerClear 3,6-8,11-14


  TPM_OwnerClear(a:authIn) : State = 
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_OwnerClear(a))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerClear(a))));

  owner_clear_post: THEOREM FORALL (state:(afterStartup?),a:authIn) : 
    LET(a,s) = runState(
	       TPM_OwnerClear(a))
	       (state) IN   
%     IF k=private(srk(s))
%     THEN 
      LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,resAuth:=ownerAuth(a)#) IN
      clear_post(s,state,
		 a,OUT_OwnerClear(a1,TPM_SUCCESS),OUT_Error(TPM_CLEAR_DISABLED),
		 state`permFlags`disableOwnerClear);
%     ELSE a=OUT_Error(TPM_AUTHFAIL) AND keys(s)=keys(state)
%     ENDIF


  TPM_ForceClear : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_ForceClear)),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ForceClear)));

  force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(
	       TPM_ForceClear)
	       (state) IN
    IF s`stclearFlags`physicalPresence
    THEN clear_post(s,state,
	       a,OUT_ForceClear(TPM_SUCCESS),OUT_Error(TPM_CLEAR_DISABLED),
	       state`stclearFlags`disableForceClear)
    ELSE a=OUT_Error(TPM_BAD_PRESENCE) and s=state
    ENDIF;


  TPM_DisableOwnerClear(a:authIn) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableOwnerClear(a))),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_DisableOwnerClear(a))));

  disable_owner_clear_post: THEOREM FORALL (state:(afterStartup?),a:authIn) : 
    LET(a,s) = runState(
    	       TPM_DisableOwnerClear(a))
	       (state) IN
      s=state with [`permFlags`disableOwnerClear:=TRUE] AND
      LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		       contAuthSess:=TRUE,resAuth:=ownerAuth(a)#) IN
      	  a=OUT_DisableOwnerClear(a1,TPM_SUCCESS);


  TPM_DisableForceClear : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableForceClear)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_DisableForceClear)));

  disable_force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(
    	       TPM_DisableForceClear)
	       (state) IN
      s`stclearFlags`disableForceClear = TRUE
      AND a = OUT_DisableForceClear(TPM_SUCCESS);


  TPM_PhysicalPresence(p:PHYSPRES) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalPresence(p))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalPresence(p))));

  physical_presence_post: THEOREM FORALL (state:(afterStartup?),p:PHYSPRES) : 
    LET(a,s) = runState(
    	       TPM_PhysicalPresence(p))
	       (state) IN
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
    THEN IF state`permFlags`physicalPresenceLifetimeLock
    	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)		
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2d
	 ELSE s=state WITH [`permFlags`physicalPresenceHWEnable:=
			IF member(HW_ENABLE,p) THEN TRUE		% 2e
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2f
			ELSE s`permFlags`physicalPresenceHWEnable ENDIF,
		      `permFlags`physicalPresenceCMDEnable:=
			IF member(CMD_ENABLE,p) THEN TRUE		% 2g
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2h
			ELSE s`permFlags`physicalPresenceCMDEnable ENDIF,
		      `permFlags`physicalPresenceLifetimeLock:=
			IF member(LIFETIME_LOCK,p) THEN TRUE		% 2i
			ELSE s`permFlags`physicalPresenceLifetimeLock ENDIF]
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 2j
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3a
	 ELSIF state`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3d
	 ELSIF state`stclearFlags`physicalPresenceLock
	 THEN  s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN s=state WITH [`stclearFlags`physicalPresence:=FALSE	% 3fi
	      	     ,`stclearFlags`physicalPresenceLock:=TRUE]		% 3fii
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
    	 ELSIF member(PRESENT,p)					% 3g
	 THEN s=state WITH [`stclearFlags`physicalPresence:=TRUE]	% 3gi
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN s=state WITH [`stclearFlags`physicalPresence:=FALSE]	% 3hi
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
	 ELSE s=state AND a=OUT_Error(TPM_BAD_PARAMETER) % should never get here
    	 ENDIF
    ELSE s=state AND a=OUT_Error(TPM_BAD_PARAMETER)			% 4
    ENDIF;


  %% Seal and output a blob (should be binary or data)
  TPM_Seal(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : State = %encAuth:(tpmSecret?)
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Seal(k,encAuth,pcrInfo,
						inData,a)));

  %% Seal a secret successfully
  seal_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),e:(tpmEncAuth?),%e:(tpmSecret?),
    	   p:(tpmPCRInfoLong?),d:tpmData,aIn:authIn) :
      LET (a,s) = runState(
     	 	  TPM_Seal(k,e,p,d,aIn))
 		  (state) IN
      IF not(storage?(keyUsage(k)) AND not(migratable(keyFlags(k))))
      THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ELSE LET sealInfo=tpmPCRInfoLong(state`stanyFlags`localityModifier,
				locAtRelease(p),
				creationPCRSelect(p),
				releasePCRSelect(p),
				tpmCompositeHash((#select:=creationPCRSelect(p),
						   pcrValue:=state`pcrs#)),
				digAtRelease(p)),
	       a1=decryptADIP(e,authHandle(aIn)) IN
	   a=OUT_Seal(tpmStoredData(sealInfo,
			tpmSealedData(a1,
				state`permData`tpmProof,
				tpmDigest(cons(tpmStoredData(sealInfo,
							tpmNull,clear),
						null),clear),
				d,encrypted(key(k),clear)),
			clear),
		(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,resAuth:=usageAuth(encDat(k)) #),
		TPM_SUCCESS)
      ENDIF
      AND s=state
 

  %% Unseal and output a blob (should be binary or data)
  TPM_Unseal(p:(tpmKey?),d:(tpmStoredData?),pa,da:authIn) : State = 
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Unseal(p,d,pa,da)));

  unseal_post: THEOREM
    FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmStoredData?),pa,da:authIn) :
      LET (a,s) = runState(
                  TPM_Unseal(p,d,pa,da))
		  (state) IN
      LET S2=tpmStoredData(sealInfo(d),tpmNull,clear),
      	  H2=tpmCompositeHash((#select:=releasePCRSelect(sealInfo(d)),
				pcrValue:=s`pcrs#)) IN
      IF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))))
      	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ELSIF not(clear?(crs(decrypt(key(p),d))))
      	 THEN a=OUT_CPUError(CPU_DECRYPT_ERROR) %  TODO: correct?
      ELSIF not(tpmProof(encData(d))=s`permData`tpmProof AND 
	    storedDigest(encData(d))=tpmDigest(cons(S2,null),clear))
	 THEN a=OUT_Error(TPM_NOTSEALED_BLOB) 
      ELSIF not(locAtRelease(sealInfo(S2))=s`stanyFlags`localityModifier)
	 THEN a=OUT_Error(TPM_BAD_LOCALITY)
      ELSIF not(H2=digAtRelease(sealInfo(S2)))
      	 THEN a=OUT_Error(TPM_WRONGPCRVAL)
      ELSE LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(p))#) IN
    	 a=OUT_Unseal(data(encData(d)),b,b,TPM_SUCCESS)
      ENDIF
      AND s=state

  unseal_prev_post: THEOREM
    FORALL (state:(afterStartup?),j,k:(tpmKey?),e:(tpmEncAuth?),%e:(tpmSecret?),
    	   p:(tpmPCRInfoLong?),d:tpmData,a,ap,ad:authIn) :
      LET (a,s) = runState(
      	  	  TPM_Seal(k,e,p,d,a)
		  >>= (LAMBDA (a:tpmAbsOutput) : 
		       CASES a OF
		         OUT_Seal(sd,ao,m) : TPM_Unseal(j,sd,ap,ad) 
			 ELSE TPM_Noop(a)
		       ENDCASES))
		  (state) IN  
	seal?(k) AND unseal?(j) AND key(j)=private(k) AND
	locAtRelease(p)=localityModifier(stanyFlags(state)) AND
	digAtRelease(p)=tpmCompositeHash((#select:=releasePCRSelect(p),
						pcrValue:=state`pcrs#))
	   =>  LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
	       	   resAuth:=usageAuth(encDat(j))#) IN 
	a=OUT_Unseal(d,b,b,TPM_SUCCESS)
	AND s=state


  %% UnBind encrypted blob (decrypt)
  TPM_UnBind(keyHandle:(tpmKey?),inData:(tpmBoundData?),a:authIn) : State = 
     output(LAMBDA (s:tpmAbsState):outputCom(s,ABS_UnBind(keyHandle,inData,a)));

  %% UnBind an encrypted blob successfully
  unBind_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),d:(tpmBoundData?),a:authIn) : 
      LET (a,s) = runState(
		  TPM_UnBind(k,d,a))
		  (state) IN
      LET d1=decrypt(private(k),d) IN
      IF not(legacy?(keyUsage(k)) OR bind?(keyUsage(k)))
      	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ELSIF not(clear?(crs(d1)))
      	 THEN a=OUT_CPUError(CPU_DECRYPT_ERROR)
      ELSE LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#) IN 
	   	a=OUT_UnBind(payloadData(d),b,TPM_SUCCESS)
      ENDIF
      AND s=state

	
  Tspi_Data_Bind(k:(tpmKey?),d:tpmData) : State = 
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Data_Bind(k,d)));

  %% UnBind an encrypted blob successfully
  unBind_prev_post: THEOREM 
    FORALL (state:(afterStartup?),d:tpmData,p,k:(tpmKey?),a:authIn) : 
      LET (a,s) = runState(
		  Tspi_Data_Bind(k,d)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		      CASES a OF
		        OUT_Data_Bind(d,m) : TPM_UnBind(k,d,a) 
			ELSE TPM_Noop(a) 
		      ENDCASES)
 		  (state) IN 
	  tpmBoundData?(d) AND unBind?(k) =>
	  LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encDat(k))#)
	      IN 
	  a = OUT_UnBind(d,b,TPM_SUCCESS) 
	  AND s = state


  %% Wrap new key k with parent key
  TPM_CreateWrapKey(p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),a:authIn) : State = 
     modifyOutput(
	  (LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_CreateWrapKey(p,k,dUA,dMA,a))),
          (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateWrapKey(p,k,dUA,dMA,a)))
	      );

  create_wrap_key_post: THEOREM 
    FORALL (state:(afterStartup?),p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
    	   a:authIn) : 
      LET (a,s) = runState(
     	          TPM_CreateWrapKey(p,k,dUA,dMA,a))
		  (state) IN
    IF not storage?(keyUsage(p)) 
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(p)) AND not(migratable(keyFlags(k)))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF identity?(keyUsage(k)) or authChange?(keyUsage(k))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migrateAuthority(keyFlags(k))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF state`permFlags`FIPS AND
    	  (never?(authDataUsage(k)) OR legacy?(keyUsage(k)))
       THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSIF (storage?(keyUsage(k)) OR migrate?(keyUsage(k))) AND
    	  not(RSA?(algoId(algoParms(k))))
       THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
    ELSE LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)),
    	     b=(#nonceEven:=EVEN,nonceOdd:=ODD,
		 contAuthSess:=FALSE,resAuth:=usageAuth(encDat(p))#),
	     migAuth:(tpmSecret?)=IF migratable(keyFlags(k)) 
	     			  THEN DM1 ELSE state`permData`tpmProof ENDIF,
	     h=tpmCompositeHash((#select:=creationPCRSelect(PCRInfo(k)),
					pcrValue:=state`pcrs#)) IN
	 LET encData=tpmStoreAsymkey(DU1,migAuth,pubDataDigest(encDat(k)),
			privKey(encDat(k)),clear),
	     pcrs=tpmPCRInfoLong(state`locality,
				locAtRelease(PCRInfo(k)),
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				h,digAtRelease(PCRInfo(k))) IN
	     a=OUT_CreateWrapKey(tpmKey(state`keyGenCnt,
					keyUsage(k),
					keyFlags(k),
					authDataUsage(k),
					algoParms(k),
					pcrs,
					key(p),
					encData,
					clear),
				b,TPM_SUCCESS)
      	 AND s=state WITH [`keyGenCnt:=keyGenCnt(state)+1]
    ENDIF


  %% Install key k in a TPM
  TPM_LoadKey2(p:(tpmKey?),k:(tpmKey?)):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_LoadKey2(p,k))),
	   (LAMBDA (s:tpmAbsState):outputCom(s,ABS_LoadKey2(p,k))));

  % A key is installed if it is wrapped with SRK
  % TODO: loadKey2State
  load_key_post: THEOREM 
    FORALL (state:(afterStartup?),p,inKey:(tpmKey?)) :
      LET (a,s) = runState(
    		    TPM_LoadKey2(p,inKey))
		    (state) IN
    IF storage?(keyUsage(p)) 
    THEN IF key(p) = wrappingKey(inKey) 
    	 THEN LET usage = keyUsage(inKey) IN
	      CASES usage OF
	      identity: IF migratable(keyFlags(inKey))=FALSE
	      		THEN a=OUT_LoadKey2(inKey,TPM_SUCCESS)
			 AND s=state with [`keys:=loadKey(inKey,srk(state),keys(state),pcrs(state))]
			ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE)
			 AND s=state
			ENDIF,
	      authChange: a=OUT_Error(TPM_INVALID_KEYUSAGE)
	      		  AND s=state
	      ELSE a=OUT_LoadKey2(inKey,TPM_SUCCESS)
	      	   AND s=state with [`keys:=loadKey(inKey,srk(state),keys(state),pcrs(state))]
	      ENDCASES
	 ELSE a=OUT_CPUError(CPU_DECRYPT_ERROR) %% Might not be right.
	      AND s=state
	 ENDIF
    ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE)
    	 AND s=state
    ENDIF;

  load_key_pred_test: THEOREM
    FORALL (p,k:(tpmKey?),state:(afterStartup?)) :
      LET (a,s) = runState(
    		    TPM_LoadKey2(p,k))
		    (state) IN
	IF loadKey2?(p,k)
	THEN a=OUT_LoadKey2(k,TPM_SUCCESS)
	     AND s=state with [`keys:=loadKey(k,srk(state),keys(state),pcrs(state))]
	ELSE IF storage?(keyUsage(p)) AND key(p)/=wrappingKey(k) 
	     THEN a=OUT_CPUError(CPU_DECRYPT_ERROR)
	     ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE)
	     ENDIF
	     AND s=state
	ENDIF

  %% A key is installed if it is wrapped with an installed key
  %% proved - Tue Jun 12 15:38:22 CDT 2012
  load_key_post2: THEOREM 
    FORALL (p,j,k:(tpmKey?),state:(afterStartup?)) :
      LET (a,s) = runState(
      	  	  TPM_LoadKey2(srk(state),k)
		  >> TPM_LoadKey2(k,j))
		  (state) IN
	loadKey2?(srk(state),k) AND loadKey2?(k,j) 
	AND srk(state) = TPM_KH_SRK
		=> member(key(j),s`keys);

  load_key_prev_post: THEOREM 
    FORALL (state:(afterStartup?),k,p:(tpmKey?),i:nat,dUA,dMA:(tpmEncAuth?),
    	   a:authIn) :
      LET (a,s) = runState(
      	  	  TPM_CreateWrapKey(p,k,dUA,dMA,a)
		  >>= CPU_saveOutput(i)
		  >>= (LAMBDA (a:tpmAbsOutput) :
		         CASES a OF
		           OUT_CreateWrapKey(wk,a,m) : TPM_LoadKey2(p,wk)
			   ELSE TPM_Noop(a)
			 ENDCASES))
		  (state) IN
      OUT_CreateWrapKey?(s`memory(i)) => 
      createWrapKey?(p,k) AND loadKey2?(p,wrappedKey(s`memory(i))) =>
     		%member(asymKey(keyGenCnt(state),keyUsage(k),keyFlags(k)),keys(s))
      a=OUT_LoadKey2(wrappedKey(s`memory(i)),TPM_SUCCESS) 
     

%   %%install nested wrapped keys?
%   nested_wrapped_keys_post: THEOREM 
%     FORALL (state:(afterStartup?),p,k1,k2:(tpmKey?)) :
%       LET (a,s) = runState(
% 		  TPM_CreateWrapKey(p,k1)
% 		  >>= CPU_saveOutput(0)
% 		  >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       CASES a OF 
% 		         OUT_CreateWrapKey(wk,m) : TPM_LoadKey2(p,wk) 
% 			 ELSE TPM_Noop(a) 
% 		       ENDCASES)
% 		  >>= (LAMBDA (a:tpmAbsOutput) :
% 		       CASES a OF
% 		         OUT_LoadKey2(wk,m) : TPM_CreateWrapKey(wk,k2)
% 			 ELSE TPM_Noop(a)
% 		       ENDCASES)
% 		  >>= CPU_saveOutput(1)
% 		  >>= (LAMBDA (a:tpmAbsOutput) : 
% 		       CASES a OF
% 		         OUT_CreateWrapKey(wk2,m) : TPM_LoadKey2(k1,wk2) 
% 			 ELSE TPM_Noop(a) 
% 		       ENDCASES))
% 		  (state) IN
% 	OUT_CreateWrapKey?(s`memory(0)) AND OUT_CreateWrapKey?(s`memory(1)) AND
% 	createWrapKey?(p,k1) AND createWrapKey?(k1,k2) AND 
% 	loadKey2?(p,wrappedKey(s`memory(0))) AND loadKey2?(k1,wrappedKey(s`memory(1)))=>
% 	a=OUT_LoadKey2(wrappedKey(s`memory(1)),TPM_SUCCESS)


  TPM_CreateMigrationBlob(pk:(tpmKey?),m:migrateScheme,mka:(tpmMigKeyAuth?),
			    d:(tpmKey?)) : State = 
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateMigrationBlob(pk,m,mka,d)));

  create_mig_blob_post: THEOREM 
   FORALL (state:(afterStartup?),pk:(tpmKey?),m:migrateScheme,
		mka:(tpmMigKeyAuth?),d:(tpmKey?)) : 
    LET(a,s) = runState(
    	       TPM_CreateMigrationBlob(pk,m,mka,d))
	       (state) IN
    IF storage?(keyUsage(pk))
    THEN CASES d OF
      	 tpmKey(k,ku,kf,a,kap,pcr,wk,e,crs) :
	   IF key(pk)=k 
      	   THEN IF checkMigKeyAuth?(state,mka)
	        THEN CASES m OF
      	   	     migrate : a=OUT_Error(TPM_INSTALL_DISABLED), % TODO: not at all correct
		     rewrap  : a=OUT_CreateMigrationBlob(0,
					tpmKey(k,ku,kf,a,kap,pcr,
						key(key(mka)),e,clear),
		     			TPM_SUCCESS)
		     %ELSE OUT_Error(TPM_BAD_PARAMETER)
		     ENDCASES	
	        ELSE a=OUT_Error(TPM_RESOURCES) % TODO: not at all correct.
	        ENDIF 
      	   ELSE a=OUT_CPUError(CPU_DECRYPT_ERROR) % TODO: not correct?
	   ENDIF
	ELSE a=OUT_Error(TPM_WRONG_ENTITYTYPE) % TODO: not correct?
	ENDCASES
      ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ENDIF
      AND s=state 

  create_mig_blob_pred_test: THEOREM 
   FORALL (state:(afterStartup?),pk:(tpmKey?),m:migrateScheme,
		mka:(tpmMigKeyAuth?),d:(tpmKey?)) : 
    LET(a,s) = runState(
    	       TPM_CreateMigrationBlob(pk,m,mka,d))
	       (state) IN
    IF createMigBlob?(state,pk,m,mka,d)
    THEN a=OUT_CreateMigrationBlob(0,
				   tpmKey(key(d),keyUsage(d),keyFlags(d),
					  authDataUsage(d),algoParms(d),
					  PCRInfo(d),key(key(mka)),
					  encDat(d),clear),
		     		   TPM_SUCCESS)
    ELSE a=OUT_Error(TPM_INSTALL_DISABLED) OR a=OUT_CPUError(CPU_DECRYPT_ERROR) OR 
    	 a=OUT_Error(TPM_RESOURCES) OR a=OUT_Error(TPM_WRONG_ENTITYTYPE) OR  
	 a=OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF


  TPM_ConvertMigrationBlob(k:(tpmKey?),inData:tpmData,rand:int) : State =
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_ConvertMigrationBlob(k,inData,rand)));


  TPM_AuthorizeMigrationKey(migKey:(tpmKey?),migScheme:(tpmMigScheme?)) : State = 
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_AuthorizeMigrationKey(migKey,migScheme)));

  authorize_migration_key_post: THEOREM 
   FORALL (state:(afterStartup?),k:(tpmKey?),scheme:(tpmMigScheme?)) : 
    LET(a,s) = runState(
    	       TPM_AuthorizeMigrationKey(k,scheme))
	       (state) IN
      a=OUT_AuthorizeMigrationKey(tpmMigKeyAuth(k,scheme,
						tpmDigest(cons(k,%cons(scheme,cons(tpmProof(PermData(s)),null))))),
								null),clear),
						clear),
				  TPM_SUCCESS)
      AND s=state


  TPM_MigrateKey(migKey,pubKey:(tpmKey?),data:tpmData) : State =
     output(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_MigrateKey(migKey,pubKey,data)));

  migrate_key_post: THEOREM 
   FORALL (state:(afterStartup?),mk,k:(tpmKey?),d:tpmData) : 
    LET(a,s) = runState(
    	       TPM_MigrateKey(mk,k,d))
	       (state) IN
    IF migrate?(keyUsage(mk))
      THEN a = OUT_MigrateKey(encrypt(key(k),decrypt(key(mk),d)),TPM_SUCCESS)
      ELSE a = OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF

  
  %% Generate and output a signature
  TPM_Sign(k:(tpmKey?),areaToSign:tpmData) : State = 
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Sign(k,areaToSign)));
	   
  sign_post: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),b:tpmData) :
      LET(a,s) = runState(
     		  TPM_Sign(k,b))
		  (state) IN
	IF legacy?(keyUsage(k)) or signing?(keyUsage(k))
	THEN a = OUT_Sign(sign(key(k),b),TPM_SUCCESS)
	ELSE a = OUT_Error(TPM_INVALID_KEYUSAGE)
	ENDIF
	AND s = state;

  sign_pred_test : THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),b:tpmData) :
      LET(a,s) = runState(
     		  TPM_Sign(k,b))
		  (state) IN
	IF sign?(state,k,b)
	THEN a = OUT_Sign(sign(key(k),b),TPM_SUCCESS)
	ELSE a = OUT_Error(TPM_INVALID_KEYUSAGE)
	ENDIF
	AND s = state;


  TPM_CreateEndorsementKeyPair(n:(tpmNonce?),k:(tpmKey?)) : State =
     %% TODO: Perm Data stuff with RNG
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_CreateEndorsementKeyPair(n,k))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_CreateEndorsementKeyPair(n,k)))
	    );

  create_endorsement_key_pair_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),n:(tpmNonce?)) : 
      LET (a,s) = runState(
      	  	  TPM_CreateEndorsementKeyPair(n,k))
		  (state) IN
      IF (key(ek(state)) = badkey) 
        THEN a = OUT_CreateEndorsementKeyPair(k,
					      tpmDigest(cons(k,cons(n,null)),clear),
					      TPM_SUCCESS) AND
	     s = state WITH [`ek := privateKey(k),
      	     	       	    `permFlags(CEKPUsed) := TRUE,
		   	    `permFlags(enableRevokeEK) := FALSE]
        ELSE a = OUT_Error(TPM_DISABLED_CMD) AND 
	     s = state
      ENDIF;


  TPM_CreateRevocableEK(a:(tpmNonce?),k:(tpmKey?),g:bool,i:(tpmNonce?)) : State =
     %% TODO: Perm Data stuff with RNG
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_CreateRevocableEK(a,k,g,i))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_CreateRevocableEK(a,k,g,i)))
	    );

  create_revocable_ek_post: THEOREM
    FORALL (state:(afterStartup?),a:(tpmNonce?),k:(tpmKey?),g:bool,i:(tpmNonce?)) : 
      LET (a,s) = runState(
      	  	  TPM_CreateRevocableEK(a,k,g,i))
		  (state) IN
      IF key(ek(state)) = badkey
        THEN a = OUT_CreateRevocableEK(tpmPubkey(key(k)),
				tpmDigest(cons(k,cons(a,null)),clear),
				i,
				TPM_SUCCESS) AND
	     s = state WITH [`ek := privateKey(k),
      	     	       	    `permFlags(CEKPUsed) := TRUE,
		   	    `permFlags(enableRevokeEK) := TRUE,	
			    `permData(ekReset):=i]
        ELSE a = OUT_Error(TPM_DISABLED_CMD) AND 
	     s = state
      ENDIF;


  TPM_RevokeTrust(r:(tpmNonce?)) : State = 
    modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_RevokeTrust(r))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_RevokeTrust(r)))
	    );
	    
  revoke_trust_post : THEOREM
    FORALL (state:(afterStartup?),EKReset:(tpmNonce?)) : 
      LET (a,s) = runState(
      	  	  TPM_RevokeTrust(EKReset))
		  (state) IN
      IF enableRevokeEK(permFlags(state)) 
      THEN IF ekReset(permData(state)) = EKReset 
    	   THEN a=OUT_RevokeTrust(TPM_SUCCESS) AND
	   	LET s1=clear(state) IN
	   	s=s1 WITH [`permFlags(nvLocked):=FALSE,
		    	      `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),
					authDataUsage(s`ek),algoParms(s`ek),
			      		PCRInfo(s`ek),wrappingKey(s`ek),
			      		encDat(s`ek),crs(s`ek))]
	   ELSE a=OUT_Error(TPM_AUTHFAIL) AND
	   	s=state
	   ENDIF
      ELSE a=OUT_Error(TPM_PERMANENTEK) AND
      	   s=state
      ENDIF;

  revoke_trust_pred_test : THEOREM
    FORALL (state:(afterStartup?),EKReset:(tpmNonce?)) : 
      LET (a,s) = runState(
      	  	  TPM_RevokeTrust(EKReset))
		  (state) IN
      IF revokeTrust?(state,EKReset)
      THEN a=OUT_RevokeTrust(TPM_SUCCESS) AND
	   LET s1=clear(state) IN
	       s=s1 WITH [`permFlags(nvLocked):=FALSE,
		    	  `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),
					authDataUsage(s`ek),algoParms(s`ek),
			      		PCRInfo(s`ek),wrappingKey(s`ek),
			      		encDat(s`ek),crs(s`ek))]
      ELSE a=OUT_Error(TPM_AUTHFAIL) OR a=OUT_Error(TPM_PERMANENTEK) AND
	   s=state
      ENDIF;



  TPM_ReadPubek(n:(tpmNonce?)) : State =
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ReadPubek(n)));

  read_pub_ek_post: THEOREM
    FORALL (state:(afterStartup?),n:(tpmNonce?)) : 
      LET (a,s) = runState(
      	  	  TPM_ReadPubek(n))
		  (state) IN
    a = IF readPubek(permFlags(state))
        THEN IF goodkey?(key(ek(state)))
	     THEN LET pubEndoK=ek(state) IN
	     	  OUT_ReadPubek(pubEndoK,
				tpmDigest(cons(pubEndoK,cons(n,null)),clear),
				TPM_SUCCESS)
	     ELSE OUT_Error(TPM_NO_ENDORSEMENT)
	     ENDIF
	ELSE OUT_Error(TPM_DISABLED_CMD)
      	ENDIF
    AND s = state
	           	  

  %% Make a new identity and output it
  TPM_MakeIdentity(CADigest:(tpmDigest?),idKeyParams:(tpmKey?)) : State =
     modifyOutput(
	    (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_MakeIdentity(CADigest,idKeyParams))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_MakeIdentity(CADigest,idKeyParams)))
	    );

  make_identity_post: THEOREM 
    FORALL (state:(afterStartup?),CADigest:(tpmDigest?),idKeyParams:(tpmKey?)) :
      LET (a,s)=runState(
     	 	   TPM_MakeIdentity(CADigest,idKeyParams))
		 (state) IN
      LET pcr=tpmPCRInfoLong(makeIdentityLocality,
			     locAtRelease(PCRInfo(idKeyParams)),
			     creationPCRSelect(PCRInfo(idKeyParams)),
			     releasePCRSelect(PCRInfo(idKeyParams)),
			     tpmCompositeHash((# select:=creationPCRSelect(PCRInfo(idKeyParams)),
    			        		pcrValue:=pcrs(state) #)),
			     digAtRelease(PCRInfo(idKeyParams))) IN
        LET waik=tpmKey(keyGenCnt(state),
			keyUsage(idKeyParams),
			keyFlags(idKeyParams),
			authDataUsage(idKeyParams),
			algoParms(idKeyParams),
			pcr,
			wrappingKey(srk(state)),
			encDat(idKeyParams),
			clear) IN
	LET idBind=tpmIdContents(CADigest,waik,signed(private(waik),clear)) IN
      IF identity?(keyUsage(idKeyParams)) AND not(migratable(keyFlags(idKeyParams)))
        THEN a=OUT_MakeIdentity(waik,idBind,TPM_SUCCESS)
	 AND s=state WITH [`keyGenCnt := keyGenCnt(state)+1]
	ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE)
	 AND s=state
      ENDIF;

  make_identity_pred_test: THEOREM 
    FORALL (state:(afterStartup?),CADigest:(tpmDigest?),idKeyParams:(tpmKey?)) :
      LET (a,s) = runState(
     	 	   TPM_MakeIdentity(CADigest,idKeyParams))
		 (state) IN
      LET pcr=tpmPCRInfoLong(makeIdentityLocality,
			locAtRelease(PCRInfo(idKeyParams)),
			creationPCRSelect(PCRInfo(idKeyParams)),
			releasePCRSelect(PCRInfo(idKeyParams)),
			tpmCompositeHash(
				(#select:=creationPCRSelect(PCRInfo(idKeyParams)),
					   pcrValue:=pcrs(state) #)),
			digAtRelease(PCRInfo(idKeyParams))) IN
        LET waik:(tpmKey?) = tpmKey(keyGenCnt(state),
				    keyUsage(idKeyParams),
				    keyFlags(idKeyParams),
				    authDataUsage(idKeyParams),
				    algoParms(idKeyParams),
				    pcr,
				    wrappingKey(srk(state)),
				    encDat(idKeyParams),
				    clear) IN
	LET idBind = tpmIdContents(CADigest,waik,signed(private(waik),clear)) IN
      IF makeIdentity?(s,CADigest,idKeyParams)
        THEN a = OUT_MakeIdentity(waik,idBind,TPM_SUCCESS)
	     AND s = state WITH [`keyGenCnt := keyGenCnt(state)+1]
	ELSE a = OUT_Error(TPM_INVALID_KEYUSAGE)
	     AND s = state
      ENDIF;
      

  %% Use an AIK
  TPM_ActivateIdentity(a:(tpmKey?),b:(activateIdentityBlob?)) : State =
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_ActivateIdentity(a,b))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ActivateIdentity(a,b)))
	    );

  %% Assure that activate idenity installs its AIK and returns K if AIK can
  %% be installed.
  activate_identity_post: THEOREM 
    FORALL (state:(afterStartup?),aik:(tpmKey?),blob:(activateIdentityBlob?)) :
      LET (a,s) = runState(
                  TPM_ActivateIdentity(aik,blob))
		  (state) IN     
      IF identity?(keyUsage(aik))    
      THEN LET h=tpmDigest(cons(tpmPubkey(key(aik)),null),clear),
      	       b1=decrypt(private(ekVal),blob) IN
	   CASES b1 OF
	   tpmAsymCAContents(k,d,crs) : 
	   	IF h=d and not(encrypted?(crs))
		THEN a=OUT_ActivateIdentity(k,TPM_SUCCESS)
		ELSE a=OUT_Error(TPM_BAD_PARAMETER)
		ENDIF,
	   tpmEKBlob(b,crs) : 
	   	CASES b OF
		tpmEKBlobActivate(k,d,p) : 
			IF h=d and not(encrypted?(crs))
			THEN a=OUT_ActivateIdentity(k,TPM_SUCCESS)
			ELSE a=OUT_Error(TPM_BAD_PARAMETER)
			ENDIF
		ELSE a=OUT_Error(TPM_BAD_TYPE)
		ENDCASES
	   ELSE a=OUT_Error(TPM_BAD_PARAMETER)
	   ENDCASES
      ELSE a=OUT_Error(TPM_BAD_PARAMETER)
      ENDIF
      AND s=state;

  cert_activate : THEOREM
    FORALL(state:(afterStartup?),aik:(tpmKey?),cr:(tpmIdContents?)) : 
      LET (a,s) = runState(
      	  	  CA_certify(aik,cr)
		  >>= CPU_saveOutput(0)
		  >>= (LAMBDA (a:tpmAbsOutput) :
		       CASES a OF
		       OUT_Certify(data,m) : TPM_ActivateIdentity(aik,data)
		       ELSE TPM_Noop(a)	
		       ENDCASES))
		  (state) IN
  	LET d=decrypt(key(aik),cr) IN
    	    crs(d)=clear AND identity?(keyUsage(aik)) AND 
	    digest(cr)=tpmDigest(cons(tpmPubkey(key(aik)),null),clear) =>
	a=OUT_ActivateIdentity(sessK(data(s`memory(0))),TPM_SUCCESS)


  %% REALLY LONG PROOF!
  make_and_activate_identity: THEOREM 
    FORALL (state:(afterStartup?),caDigest:(tpmDigest?),idKeyParams:(tpmKey?)) :
      LET  (a,s) = runState(
 		   TPM_MakeIdentity(caDigest,idKeyParams) % identity is output
		   >>= CPU_saveOutput(0)
		   >>= (LAMBDA (a:tpmAbsOutput) : 
		       	CASES a OF
		          OUT_MakeIdentity(aik,idBind,m) : CA_certify(aik,idBind)
			  ELSE TPM_Noop(a)
			ENDCASES)
		   >>= CPU_saveOutput(1)
		   >>= (LAMBDA (a:tpmAbsOutput) : 
		       	CASES a OF
		          OUT_Certify(data,m) : TPM_ActivateIdentity(idKeyParams,data)
			  ELSE TPM_Noop(a)
			ENDCASES))
		  (state) IN
	makeIdentity?(state,caDigest,idKeyParams)
	AND OUT_MakeIdentity?(s`memory(0)) 
	AND private(idKeyParams)=key(idKey(s`memory(0)))
	AND caDigest=idBinding(s`memory(0)) 
	AND OUT_Certify?(s`memory(1))=>
	a=OUT_ActivateIdentity(sessK(data(s`memory(1))),TPM_SUCCESS) AND 
	s=state WITH [`keyGenCnt:=keyGenCnt(state)+2]



  %% Extend PCR n with hash value h.
  TPM_Extend(n:PCRINDEX,h:HV):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Extend(n,h))),
           (LAMBDA (s:tpmAbsState):outputCom(s,ABS_Extend(n,h))));
  
  extend_post : THEOREM
    FORALL (state:(afterStartup?),h:HV,n:PCRINDEX) : 
      LET (a,s) = runState(
      	  	  TPM_Extend(n,h))
		  (state) IN
    IF disable(permFlags(state)) %OR deactivated(STCLEAR_FLAGS)
    THEN a=OUT_Extend(reset,TPM_SUCCESS)
    ELSE a=OUT_Extend(extend(pcrs(state)(n),h),TPM_SUCCESS)
    ENDIF
    AND s=state WITH [`pcrs := pcrsExtend(pcrs(state),n,h)];


  %% Extend is antisymmetric if the hash values used for extension are
  %% not equal.  In this example we use the LET form to define
  %% commands directly with monad functions defined in StateMonad.pvs
  antisymmetryMonad: THEOREM 
    FORALL (hv0,hv1:HV,state:(afterStartup?)) :
      LET f1:State =
          modify(OUT_Nothing,
                 (LAMBDA (s:tpmAbsState):
		   s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv0)])),
      	f2:State =
          modify(OUT_Nothing,
                 (LAMBDA (s:tpmAbsState):
		   s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv1)])) IN
      hv0/=hv1 =>
        runState(
          f2 >>= (LAMBDA (x:tpmAbsOutput): f1))(tpmStartup)
        /=
        runState(
          f1 >>= (LAMBDA (x:tpmAbsOutput): f2))(tpmStartup)

  %% Extending a reset PCR is antisymmetric if the two values are not equal
  %% Let form used to defined commands for bind.  Will use command forms
  %% later in antisymmetryMonad3
  antisymmetryMonad2: THEOREM 
    FORALL (hv0,hv1:HV) :
      LET 
        f1:State = TPM_Extend(0,hv0),
      	f2:State = TPM_Extend(0,hv1) IN
      (hv0/=hv1 =>
        runState(f2 >> f1)(tpmStartup)
        /=
        runState(f1 >> f2)(tpmStartup))

  %% Extending a reset PCR is antisymmetric if the two values are not equal.
  %% No let form - commands appear directly in bind
  %% Theorem is now false when PCRs other than PCR0 are included.
  antisymmetryMonad3: THEOREM 
    FORALL (hv0,hv1:HV) :
      hv0/=hv1 =>
         runState(TPM_Extend(0,hv1)
		>> TPM_Extend(0,hv0))
	   (tpmStartup)
       /=
         runState(TPM_Extend(0,hv0)
		>> TPM_Extend(0,hv1))
	   (tpmStartup)


  %% Output PCR(i)
  TPM_PcrRead(i:PCRINDEX) : State = 
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PCRRead(i)));

  pcr_read_post: THEOREM
    FORALL (state:(afterStartup?),i:PCRINDEX) : 
      LET(a,s) = runState(
     		  TPM_PcrRead(i))
		  (state) IN
	a = OUT_PCRRead(pcrs(s)(i),TPM_SUCCESS)
	AND s = state;


  %% Generate and output a quote
  TPM_Quote(k:(tpmKey?),n:(tpmNonce?),pm:PCR_SELECTION) : State = 
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Quote(k,n,pm)));

  %% If nonces don't match, quotes don't match.  We don't care about this
  %% if the a quote cannot be produced.
  %% proved - Fri Jun 22 16:55:16 CDT 2012
  bad_nonce: THEOREM
    FORALL (s:(afterStartup?),k:(tpmKey?), n1,n2:(tpmNonce?), pm:PCR_SELECTION) :
      n1/=n2 %AND checkKeyRoot(k,srk(s)) 
      =>
       runState(
         TPM_Quote(k,n1,pm))
	 (s)
       /=
       runState(
	 TPM_Quote(k,n2,pm))
	 (s);


  %% Bad Signing Key - Man in the Middle Attack - we don't care about this
  %% if either key won't produce a quote.
  %% proved - Fri Jun 22 16:55:56 CDT 2012
  bad_signing_key: THEOREM
    FORALL (s:(afterStartup?),n:(tpmNonce?),pm:PCR_SELECTION,k0,k1:(tpmKey?)) :
      LET (a0,s0) = runState(TPM_Quote(k0,n,pm))(s),
        (a1,s1) = runState(TPM_Quote(k1,n,pm))(s) IN
          private(k0) /= private(k1) 
% 	  AND checkKeyRoot(k0,srk(s))
% 	  AND checkKeyRoot(k1,srk(s))
          =>
	  a0 /= a1;
     
  %% Output after going through tpm commands is same as grabbing pcrs
  %% This is one of those theorems where assert must be called before grind
  %% proved - Fri Jun 22 16:56:08 CDT 2012
  check_PCRS: THEOREM (
    FORALL (state:(afterStartup?),k:(tpmKey?),hv:HV,pm:PCR_SELECTION,n:(tpmNonce?),i:PCRINDEX) :
      LET (a,s)=runState(
        	TPM_Extend(i,hv) 
		>> TPM_Quote(k,n,pm))
		(state) IN
%     checkKeyRoot(k,srk(s)) => 
      a=OUT_Quote(map(s`pcrs,pm),
		  tpmQuote(tpmCompositeHash((#select:=pm,pcrValue:=pcrs(s)#)),
			   n,
			   signed(private(k),clear)),
		  TPM_SUCCESS));

  %% Prove that quote generation returns the correct PCR.  This theorem
  %% needs to be updated with something cleaner.
  %% proven - Wed Jul 11 10:40:28 EDT 2012
  quote_post: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),n:(tpmNonce?),p:PCR_SELECTION) :
        LET (a,s) = runState(
      	    	    TPM_Quote(k,n,p))
		    (state) IN 
%	checkKeyRoot(k,srk(state)) => 
	LET pcrData=getPCRs(s`pcrs,p) IN
        a=OUT_Quote(pcrData,
		     tpmQuote(tpmCompositeHash((#select:=p,pcrValue:=pcrs(s)#)),
			      n,
			      signed(private(k),clear)),
		     TPM_SUCCESS)
	AND s=state
      
  quote_with_prev_key: THEOREM
    FORALL (state:(afterStartup?),pk,k:(tpmKey?),n:(tpmNonce?),pm:PCR_SELECTION,
    	   dUA,dMA:(tpmEncAuth?),a:authIn) :
      LET (a,s) = runState(
		  TPM_CreateWrapKey(pk,k,dUA,dMA,a)
		  >>=CPU_saveOutput(0)
		  >>= (LAMBDA (a:tpmAbsOutput) : 
		       CASES a OF 
		         OUT_CreateWrapKey(wk,a,m) : TPM_Quote(wk,n,pm) 
			 ELSE TPM_Noop(a) 
		       ENDCASES))
		  (state) IN
	OUT_CreateWrapKey?(s`memory(0)) => LET key=wrappedKey(s`memory(0)) IN
 	createWrapKey?(pk,k) => 
        a=OUT_Quote(map(s`pcrs,pm),
	            tpmQuote(tpmCompositeHash((#select:=pm,pcrValue:=s`pcrs#)),
			     n,
			     signed(private(key),clear)),
		    TPM_SUCCESS)
	

  %% Prove that skipping SENTER is detectable by showing the quote following
  %% a command differs when SENTER is excluded.
  %% proved - Tue Jun 12 15:34:24 CDT 2012
  no_senter: THEOREM 
    FORALL (state:tpmAbsState,k:(tpmKey?),hv:HV,n:(tpmNonce?),pm:PCR_SELECTION,i:PCRINDEX) :
      runState(
	TPM_Init
      	>> TPM_Startup(TPM_ST_CLEAR)
      	>> CPU_senter
      	>> CPU_sinit
      	>> TPM_Extend(i,hv)
      	>> TPM_Quote(k,n,pm))
      	(state)
      /=
      runState(
	TPM_Init
	>> TPM_Extend(i,hv)
	>> TPM_Quote(k,n,pm))
	(state)

  %% TPMs will not lie about who they are.  If the AIK cannot be installed
  %% then no quote will be generated
  %% proved - Wed Jul 11 11:28:46 EDT 2012
%   aik_binding: THEOREM
%     FORALL (aik:(tpmKey?),b:(tpmNonce?),pm:PCR_SELECTION,state:tpmAbsState) :
%       LET (a,s) = runState(
%                   TPM_Init
% 		  >> TPM_Startup(TPM_ST_CLEAR)
% 		  >> CPU_senter
% 		  >> CPU_sinit
% 		  >> TPM_Quote(aik,b,pm))
% 		  (state) IN
%        NOT checkKeyRoot(aik,srk(s)) => 
%        a=OUT_Error(TPM_INVALID_KEYUSAGE);

   %% Simple verification of the quote generation process from init
   %% through generation of the appraiser's quote.  Yay.  This is what
   %% I was after!!
   %%
   %% Memory map:  
   %% 0 -> identity
   %% 1 -> CA cert
   %% 2 -> TPM quote
   %%
   %% Note that the identity is not used in building the final
   %% appraiser's quote
   %% proved Sat Jul 14 11:19:56 CDT 2012
   cert_and_quote_with_prev_key : THEOREM
   FORALL (state:(afterStartup?)
   	  ,n:(tpmNonce?)
	  ,pm:PCR_SELECTION
	  ,idKey:(tpmKey?)
	  ,caDig:(tpmDigest?)) :
    LET (a,s) = runState(
    	      	TPM_MakeIdentity(caDig,idKey)
		>>= CPU_saveOutput(0)
		>>= (LAMBDA (a:tpmAbsOutput) : 
		     CASES a OF
		     OUT_MakeIdentity(aik,idBind,m) : CA_certify(aik,idBind)
		     ELSE TPM_Noop(a)
		     ENDCASES)
% 		>>= CPU_saveOutput(1)
		>>= (LAMBDA (a:tpmAbsOutput) : 
		     CASES a OF
		     OUT_Certify(data,m) : TPM_ActivateIdentity(idKey,data)
		     ELSE TPM_Noop(a)
		     ENDCASES)
		>> CPU_read(0)
		>>= (LAMBDA (a:tpmAbsOutput) : 
		     CASES a OF
		     OUT_MakeIdentity(aik,idBind,m) : TPM_Quote(aik,n,pm)
		     ELSE TPM_Noop(a)
		     ENDCASES)
		>>= CPU_saveOutput(2)
		>> CPU_BuildQuoteFromMem(2,0))
		(state) IN
	makeIdentity?(state,caDig,idKey)
	AND OUT_MakeIdentity?(s`memory(0)) 
	AND OUT_Quote?(s`memory(2))
	AND private(idKey)=key(idKey(s`memory(0)))
	AND caDig=idBinding(s`memory(0)) =>
	LET pcrs = getPCRs(s`pcrs,pm) IN
	a=OUT_FullQuote(tpmQuote(tpmCompositeHash((#select:=pm,pcrValue:=s`pcrs#)),
				 n,
				 signed(private(idKey),clear)),
			tpmIdContents(caDig,idKey,signed(private(idKey),clear)),
			CPU_SUCCESS)
	   
END tpm
