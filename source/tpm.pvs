%% ----
%%
%% TPM Theory
%%
%% Author: Perry Alexander, Brigid Halling
%% Date: Mon Nov 28 01:09:39 CST 2011
%%
%% Description: Basic model of a TPM using a monadic state model
%% 
%% Dependencies:
%%  StateMonad.pvs
%%  key.pvs
%%  pcr.pvs
%%
%% Todo: (key - => pending, + => done)
%%  + AIKs are all wrapped by SRK - no chaining allowed
%%  - AIKs need to be installed, not just checked, when used
%%  + MakeIdentity creates a pair
%%  - data sent to the CA is encrypted with the CA public key
%%  - noop needs to generate a message when used in error cases
%% ----

%% Standard Error IDs
%%  0 = "Bad identity record"
%%  1 = "Bad input key"
%%  2 = "bad session key"
%%  4 = "bad quote parts"

tpm [ B:TYPE+, % BLOB
      HV:TYPE+,% Hash value
      hash:[B->HV], % Hash function
      K:TYPE+ % Key
     ] : THEORY

  BEGIN

  ASSUMING
    % Assume that different blobs always have different hashes
    unique_hash: ASSUMPTION
      FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
  ENDASSUMING

  IMPORTING pcr[HV];
  IMPORTING key[B,K,HV];
  IMPORTING ReturnCodes;

  SML : TYPE = list[HV];

  %% State monad output type
  tpmAbsOutput : DATATYPE
  BEGIN
    outNothing : outNothing?
    outError(m:ReturnCode) : outError?
    outQuote(oqk:KEY,oqnon:BLOB,oqpcrs:list[PCR],m:ReturnCode) : outQuote?
    outWrapKey(owk:wrapKey,m:ReturnCode) : outWrapKey?
    outAsymKey(oask:KEY,m:ReturnCode) : outAsymKey?
    outSymKey(osk:KEY,m:ReturnCode) : outSymKey?
    outBlob(obl:BLOB,m:ReturnCode) : outBlob?
    outCertReq(ocertaik:wrapKey,ocertek:(asymKey?),ofreshk:(symKey?),m:ReturnCode) : outCertReq?
    outIdentity(oidentaik:wrapKey,oidentc:(outCertReq?),m:ReturnCode) : outIdentity?
    outIdentActivation(oactc:(certBlob?),osessk:(symKey?),oactek:(asymKey?),m:ReturnCode) : outIdentActivation?
    outFullQuote(ofullqc:(certBlob?),ofullqsml:SML,ofullqq:(outQuote?),m:ReturnCode) : outFullQuote?
    outPCR(pcr:PCR,m:ReturnCode) : outPCR?
  END tpmAbsOutput;

  IMPORTING memory[tpmAbsOutput,outNothing];

  %% Argument to TPM startup indicating startup mode.
  TPM_STARTUP_TYPE : DATATYPE
  BEGIN
    TPM_ST_CLEAR : TPM_ST_CLEAR?
    TPM_ST_STATE : TPM_ST_STATE?
    TPM_ST_DEACTIVATED : TPM_ST_DEACTIVATED?
  END TPM_STARTUP_TYPE

  %% State monad input type.  All inputs are in the form of a command with
  %% parameters.
  tpmAbsInput : DATATYPE
  BEGIN
  %% Startup commands
    ABS_Reset : ABS_Reset? %unimplemented
    ABS_Init : ABS_Init? 
    ABS_SaveState : ABS_SaveState? % unimplemented
    ABS_Startup(startupType : TPM_STARTUP_TYPE) : ABS_Startup? % Only clear implemented
  %% Protected Storage Commands
    ABS_Seal(sk:(asymKey?),data:BLOB) : ABS_Seal?
    ABS_Unseal(s:(sealBlob?),uk:(asymKey?)) : ABS_Unseal?   
    ABS_UnBind(inData:(encryptBlob?),dk:(asymKey?)) : ABS_UnBind?
    ABS_CreateWrapKey(parentk,wk:(asymKey?),wk_auth:AUTHDATA): ABS_CreateWrapKey?  
  %% Key Management Commands
    ABS_LoadKey2(lk:wrapKey): ABS_LoadKey2? 
  %% Measurement Collection Commands
    ABS_Extend(h:HV,i:PCRINDEX) : ABS_Extend?
  %% Measurement Reporting Commands
    ABS_PcrRead(ind:PCRINDEX) : ABS_PcrRead?
    ABS_Quote(aik:wrapKey,nonce:BLOB,pm:PCRMASK) : ABS_Quote?
  %% AIK Commands
    ABS_MakeIdentity(naik:(asymKey?),k:(symKey?),auth:AUTHDATA) : ABS_MakeIdentity?
    ABS_ActivateIdentity(caik:wrapKey,k:(symKey?)) : ABS_ActivateIdentity?
  %% Cryptographic Commands
    ABS_Sign(sk:KEY,saik:wrapKey,sb:BLOB) : ABS_Sign?
  %% TPM Ownership Commands
    ABS_TakeOwnership : ABS_TakeOwnership?
  %% Operational Flags Commands
    ABS_OwnerClear : ABS_OwnerClear? % unimplemented
    ABS_ForceClear : ABS_ForceClear? % unimplemented
    ABS_DisableOwnerClear : ABS_DisabelOwnerClear? % unimplemented
  %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    ABS_save(i:nat,v:tpmAbsOutput) : ABS_save?
    ABS_read(i:nat) : ABS_read?
    ABS_Data_Bind(k:KEY,d:BLOB) : ABS_Data_Bind?
  %% CA Commands
    ABS_certify(aik:wrapKey,ek:(asymKey?),freshk:(symKey?)) : ABS_certify?
  %% Invented, imaginary Commands
    noopCom : noopCom?
  END tpmAbsInput;

  %% sinit blob instance for measurement
  sinit : B;

  %% mle blob instance for measurement
  mle : B;

  %% Uninterpreted Key values.
  ekKeyVal : K;
  srkKeyVal : K;
  caKeyVal : K

  %% Key definitions that make ek and srk values asymmetric keys.
  ekVal : KEY = asymKey(ekKeyVal);
  srkVal : KEY = asymKey(srkKeyVal);
  caVal : KEY = asymKey(caKeyVal); % Certificate Authority key

  %% Abstract TPM State with keys, PCR array and locality
  tpmAbsState : TYPE = [#
                       memory : mem,
                       postInit : bool,
                       srk : (asymKey?),
		       ek : (asymKey?),
		       keys : KEYSET,
                       pcrs : PCRS,
		       pcrFlags : PCRFLAGS,
		       locality : LOCALITY
		    #];

  IMPORTING StateMonad[tpmAbsOutput,tpmAbsState];

  %% Define some common TPM states and state operations
  
  %% Unknown state
  tpmUnknown : tpmAbsState

  %% Power on state after init is raised by hardware
  tpmPostInit : tpmAbsState = (#
                         pcrs:=pcrsPower
			 , pcrFlags:=allResetAccess
			 , postInit:=true
                         , locality:=4
			 , keys:=emptyset
			 , srk:=private(srkVal)
			 , ek:=private(ekVal)
			 , memory:=empty
			 #);

  %% Standard initial state following startup command.  Technically, there
  %% will be many results of TPM_Startup, but this is a good starting point
  tpmStartup : tpmAbsState = (#
                         pcrs:=pcrsReset(allResetAccess)
			 , pcrFlags:=allResetAccess
			 , postInit:=false
			 , locality:=4
			 , keys:=emptyset
			 , srk:=private(srkVal)
			 , ek:=private(ekVal)
			 , memory:=empty
			 #);

  %% Predicate to determine if startup has occured.  Used as types
  %% (afterInit?) is the set of states occuring immediately after TPM_Init
  %% (afterStartup?) is the set of states occuring immediately after
  %% TPM_Startup
  afterInit?(s:tpmAbsState):bool = postInit(s);
  afterStartup?(s:tpmAbsState):bool = NOT postInit(s);

  %% Standard operations on TPM state definition above.  All such
  %% functions end with State to indicate they operate on the state
  %% value rather than on the TPM monad.  Note that key set and pcr
  %% manipulation functions are defined externally in key.pvs and
  %% pcr.pvs respectively

  %% Reset PCRs as performed by SENTER.
  pcrsResetSenterState(s:tpmAbsState) : tpmAbsState =
    s WITH [`pcrs := pcrsReset(pcrFlags(s))];

  %% Decrease locality value
  changeLocalityState(s:tpmAbsState) : tpmAbsState =
    s WITH [`locality := IF locality(s) > 0
                         THEN locality(s) - 1
			 ELSE 0
			 ENDIF];
  
  %% Revoke key operation on TPM state
  revokeKeyState(s:tpmAbsState,k:wrapKey) : tpmAbsState =
    s WITH [`keys := removeKey(k,keys(s))];

  %% Install key operation on TPM state.
  loadKey2State(s:tpmAbsState,k:wrapKey) : tpmAbsState =
    s WITH [`keys := addKey(k,srk(s),keys(s))];

  %% Extend operation on TPM state
  extendState(s:tpmAbsState,n:PCRINDEX,h:HV) : tpmAbsState =
    s WITH [`pcrs := pcrsExtend(pcrs(s),n,h)];

  % Use an AIK.  This is currently unimplemented.
  activateIdentityState(s:tpmAbsState,a:wrapKey,k:(symKey?)) : tpmAbsState =
    loadKey2State(s,a);

  % save a value to external memory
  saveState(s:tpmAbsState,i:nat,v:tpmAbsOutput) : tpmAbsState =
    s WITH [`memory := updateLoc(memory(s),i,v)];

  %% What we want to generate with each command is a pair of type
  %% [tpmAbsOut,tpmAbsState].  executeCom generates the the state
  %% from a TPM state and command while the upcoming outputCom
  %% generates the corresponding output.  Thus, to execute any
  %% operation, both executeCom and outputCom must be used

  %% Run if TPM_Init has run but TPM_Startup has not
  executeComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsState =
    CASES c OF
      ABS_Startup(t) : tpmStartup
      ELSE s
    ENDCASES;

  %% Run if ABS_Startup has run after TPM_Init
  executeComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsState = 
    CASES c OF
      ABS_LoadKey2(k): loadKey2State(s,k), 
      ABS_Extend(h,n) : extendState(s,n,h),
      ABS_ActivateIdentity(a,k) : activateIdentityState(s,a,k),
      ABS_Init : tpmPostInit,
      ABS_senter : 
        changeLocalityState(extendState(pcrsResetSenterState(s),0,hash(sinit))),
      ABS_sinit : changeLocalityState(extendState(s,0,hash(mle))),
      ABS_save(i,v) : saveState(s,i,v)
      ELSE s
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInit=true.
  executeCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsState =
    IF afterInit?(s)
       THEN executeComPostInit(s,c)
       ELSE executeComStartup(s,c)
    ENDIF;

  
  % Output secret sealed with asymetric key 
  sealOut(s:tpmAbsState,k:(asymKey?),data:BLOB) : tpmAbsOutput = 
    IF data = nothing
      THEN outError(TPM_BAD_PARAMETER)
      ELSE outBlob(sealBlob(k,pcrs(s),data),TPM_SUCCESS)
    ENDIF

  % Output secret unsealed with an asymetric key and PCRs 
  unsealOut(s:tpmAbsState,d:(sealBlob?),k:(asymKey?)) : tpmAbsOutput = 
    LET b:BLOB = unseal(d,pcrs(s),k) IN
    IF nothing?(b)
      THEN outError(TPM_NOTSEALED_BLOB)
      ELSE outBlob(b,TPM_SUCCESS)
    ENDIF

  % Output decrypted key
  unBindOut(s:tpmAbsState,d:(encryptBlob?),k:(asymKey?)) : tpmAbsOutput =
    LET b:BLOB = decrypt(d,k) IN
%% TODO: double check command specificiations... this might be okay without IF stmt
%      IF nothing?(b)
%        THEN outError()
%        ELSE 
       outBlob(b,TPM_SUCCESS)
%      ENDIF
    

  % Generate a NEW RANDOM key pair.
  createWrapKeyOut(parent,k:(asymKey?),a:AUTHDATA):tpmAbsOutput = 
     LET wk:wrapKey = (#
     	 	      parentKey:=parent, 
		      childKey:=k
		      #)
     IN outWrapKey(wk,TPM_SUCCESS)

  % Output PCR of given index
  pcrReadOut(s:tpmAbsState,ind:PCRINDEX) : tpmAbsOutput = 
  %% TODO: will ind not be allowed to be > 23 because of defn of PCRINDEX?
%     IF ind > 23
%       THEN outError(TPM_BADINDEX) 
%       ELSE 
      	   LET p = pcrs(s) IN outPCR(p(ind),TPM_SUCCESS)
%     ENDIF;

  % Output PCRs from a state as quote
  quoteOut(s:tpmAbsState,k:wrapKey,n:BLOB,pm:PCRMASK) : tpmAbsOutput =
  %% TODO: will pm be allowed to have elements > 23? see pcrReadOut 
%     IF some((LAMBDA (x:nat):x>23),pm)
%       THEN outError(TPM_INVALID_PCR_INFO)
%       ELSE 
      	   IF checkKeyRoot(k,srk(s))
      	     THEN outQuote(private(childKey(k)),n,getPCRs(s`pcrs,pm),TPM_SUCCESS)
      	     ELSE outError(TPM_INVALID_KEYUSAGE) %% TODO: double check this
	   ENDIF
%     ENDIF;


  % Output a newly generated AIK.  Note that a simulates the new aik.
  makeIdentityOut(s:tpmAbsState,a:(asymKey?),k:(symKey?),auth:AUTHDATA) : tpmAbsOutput =
    LET waik:wrapKey = (# 
    		       parentKey:=srk(s),
		       childKey:=a 
		       #) 
    IN outIdentity(waik,outCertReq(waik,ekVal,k,TPM_SUCCESS),TPM_SUCCESS);

  % Retrieve a key if a can be installed
  %% TODO: Activiate identity needs more work
  activateIdentityOut(s:tpmAbsState,a:wrapKey,k:(symKey?)) : tpmAbsOutput =
    IF checkKeyRoot(a,srk(s)) 
      THEN outSymKey(k,TPM_SUCCESS) 
      ELSE outError(TPM_BAD_PARAMETER)
    ENDIF;

  % Sign a blob if signing key isn't aik
  signOut(s:tpmAbsState,sk:KEY,aik:wrapKey,sb:BLOB) : tpmAbsOutput =
    IF sk /= childKey(aik)
     THEN outBlob(signBlob(sk,sb),TPM_SUCCESS)
     ELSE outError(TPM_INVALID_KEYUSAGE)
    ENDIF;
    
  % NEED TO ENSURE NEW, RANDOM SRK KEY PAIR
  takeOwnershipOut : tpmAbsOutput =
  %% TODO: Lots of flags for this one.
    outAsymKey(srkVal,TPM_SUCCESS);

  % Generate a certified AIK from an AIK.  Certification assumes that the
  % EK really does belong to the TPM.  We're abstracting away that check.
  certOut(s:tpmAbsState,aik:wrapKey,ek:(asymKey?),freshk:(symKey?)) : tpmAbsOutput =
    outIdentActivation(certBlob(private(caVal),aik),freshk,ek,TPM_SUCCESS);

  % Read a value and output
  readOut(s:tpmAbsState,i:nat) : tpmAbsOutput =
    memory(s)(i);
  
  dataBindOut(s:tpmAbsState,k:KEY,d:BLOB) : tpmAbsOutput = 
    outBlob(encryptBlob(k,d),TPM_SUCCESS);

  %% Generate output from a command and state
  outputCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsOutput = 
    CASES c OF
      ABS_Seal(k,data) : sealOut(s,k,data),
      ABS_Unseal(d,k) : unsealOut(s,d,k),
      ABS_UnBind(d,k) : unBindOut(s,d,k),
      ABS_CreateWrapKey(parent,k,k_auth) : createWrapKeyOut(parent,k,k_auth),
      ABS_PcrRead(ind) : pcrReadOut(s,ind),
      ABS_Quote(k,n,pm) : quoteOut(s,k,n,pm),
      ABS_MakeIdentity(a,k,auth) : makeIdentityOut(s,a,k,auth), 
      ABS_ActivateIdentity(a,k) : activateIdentityOut(s,a,k),
      ABS_Sign(sk,aik,sb) : signOut(s,sk,aik,sb),
      ABS_TakeOwnership : takeOwnershipOut,
      ABS_certify(aik,ek,freshk) : certOut(s,aik,ek,freshk),
      ABS_read(i) : readOut(s,i),
      ABS_Data_Bind(k,d) : dataBindOut(s,k,d)
    ELSE outNothing
  ENDCASES;


  %% CPU Command Definitions

  %% Requires use of bind
  CPU_saveOutput(i:nat) : [tpmAbsOutput -> State] =
      useOutputStateOutput(outNothing,
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    executeCom(s,ABS_save(i,a)))),
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    a)));

  CPU_read(i:nat) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_read(i))));

  %% Call SENTER 
  CPU_senter : State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_senter)));

  %% Reset the TPM by senter call - depreciated - DO NOT USE
  senterResetTPM : State = put(outNothing,tpmStartup);

  %% Measure sinit by senter call - depreciated - DO NOT USE
  %senterHashSinitTPM : State = TPM_Extend(hash(sinit),0);

  %% Call sinit for initial measurements
  CPU_sinit : State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_sinit)));
 
  %% Build a quote for the appraiser from the quote, cert, and log
  buildQuote(q:(outQuote?),ca:(outIdentActivation?),sml:SML,sessk:(symKey?)):tpmAbsOutput =
    IF sessk=osessk(ca)
     THEN outFullQuote(oactc(ca),sml,q,TPM_SUCCESS)
     ELSE outError(TPM_INAPPROPRIATE_SIG) %% TODO: Double check this
    ENDIF;

  CPU_BuildQuoteFromMem(q,ca,sessk:nat,sml:SML):State =
    output(outNothing,
            (LAMBDA (s:tpmAbsState) :
	       LET theMem = memory(s) IN
	         IF outIdentActivation?(theMem(sessk))
		    AND outIdentActivation?(theMem(ca))
		    AND outQuote?(theMem(q))
                 THEN buildQuote(theMem(q),theMem(ca),sml,osessk(theMem(sessk)))
		 ELSE outError(TPM_FAIL) %% TODO: Incorrect
		 ENDIF));

  %% CA Command Definitions
  %% Invoke the certification authority
  CA_certify(cr:(outCertReq?)) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState) :
               outputCom(s,ABS_certify(ocertaik(cr),ocertek(cr),ofreshk(cr)))));

  %% Assure the CA generates an appropriate cert from the AIK and Ek
  %% proved - Wed Jul 11 13:14:11 EDT 2012
  gen_cert : THEOREM FORALL (aik:wrapKey,ek:(asymKey?),k:(symKey?)) :
    LET (out,s) = runState(CA_certify(outCertReq(aik,ek,k,TPM_SUCCESS)))(tpmStartup) IN
      out = outIdentActivation(
                 certBlob(private(asymKey(caKeyVal)),aik),
                 k,
                 ek,
		 TPM_SUCCESS)


  %% TPM Command Definitions - Note that all commands used by the TPM
  %% have the TPM suffix to distinguish from operations on tpm state.
  %% Commands thus far are defined as state transforming or output
  %% generating.  This does not exclude the eventuality of doing both.

  %% No-op - not a real TPM command
  TPM_Noop : [tpmAbsOutput -> State] =
    (LAMBDA (a:tpmAbsOutput): state((LAMBDA(s:tpmAbsState) : (a,s))));

  %% TPM is off - not a real TPM command
  TPM_Off : State = put(outNothing,tpmUnknown);

  %% Power up the TPM and hit the TPM_Init signal
  TPM_Init : State = put(outNothing,tpmPostInit);

  %% Start up the TPM after TPM_Init
  TPM_Startup(st:TPM_STARTUP_TYPE) : State =
    modify(outNothing,
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Startup(st))));
  
  %% The only command that can run and do anyting folling a TPM_Init is 
  %% TPM_Startup.  If anything else tries to run, nothing happens.  Note
  %% the use of an "anything" command in the first command sequence.  Could
  %% use LET here rather than the tuple accessor
  startup_after_init : THEOREM FORALL
    (s0:tpmAbsState,a:tpmAbsOutput,c:tpmAbsInput) :
      NOT ABS_Startup?(c) =>
        runState(TPM_Init
                 >> state(LAMBDA (s:tpmAbsState):(a,executeCom(s,c))))
	      (s0)`2
        =
        runState(TPM_Init)
	      (s0)`2

  %% Prove that senter after power up results in reset PCRs followed by sinit
  %% measurement.
  %% proved - Tue Jun 12 15:31:12 CDT 2012
  resetMonad: THEOREM (FORALL (hv:HV, state:tpmAbsState) :
    LET (a,s) = runState(
      	          TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
      		  >> CPU_senter
      		  >> CPU_sinit)
      		  (state)
      IN s = changeLocalityState(
               changeLocalityState(
                 extendState(
                   extendState(tpmStartup,0,hash(sinit)),0,hash(mle)))))

  %% Extend PCR n with hash value h.
  TPM_Extend(h:HV,n:PCRINDEX):State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Extend(h,n))));

  %% Extend is antisymmetric if the hash values used for extension are
  %% not equal.  In this example we use the LET form to define
  %% commands directly with monad functions defined in StateMonad.pvs
  antisymmetryMonad: THEOREM (FORALL (hv0,hv1:HV):
    LET f1:State =
          modify(outNothing,
                 (LAMBDA (s:tpmAbsState):
		   s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv0)])),
      	f2:State =
          modify(outNothing,
                 (LAMBDA (s:tpmAbsState):
		   s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv1)])) IN
      hv0/=hv1 =>
        runState(
          f2 >>= (LAMBDA (x:tpmAbsOutput): f1))(tpmStartup)
        /=
        runState(
          f1 >>= (LAMBDA (x:tpmAbsOutput): f2))(tpmStartup))

  %% Extending a reset PCR is antisymmetric if the two values are not equal
  %% Let form used to defined commands for bind.  Will use command forms
  %% later in antisymmetryMonad3
  antisymmetryMonad2: THEOREM (FORALL (hv0,hv1:HV) :
    LET 
        f1:State = TPM_Extend(hv0,0),
      	f2:State = TPM_Extend(hv1,0) IN
      (hv0/=hv1 =>
        runState(f2 >> f1)(tpmStartup)
        /=
        runState(f1 >> f2)(tpmStartup)))

  %% Extending a reset PCR is antisymmetric if the two values are not equal.
  %% No let form - commands appear directly in bind
  %% Theorem is now false when PCRs other than PCR0 are included.
  antisymmetryMonad3: THEOREM (FORALL (hv0,hv1:HV) :
    hv0/=hv1 =>
       runState(TPM_Extend(hv1,0)
		>> TPM_Extend(hv0,0))
	 (tpmStartup)
       /=
       runState(TPM_Extend(hv0,0)
		>> TPM_Extend(hv1,0))
	 (tpmStartup))


  %% Establish SRK
  TPM_TakeOwnership : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_TakeOwnership)));

  take_ownership_success : THEOREM FORALL (state:tpmAbsState) :
     LET (a,s) = runState(
     	         TPM_Init
		 >> TPM_Startup(TPM_ST_CLEAR)
		 >> CPU_senter
		 >> CPU_sinit
		 >> TPM_TakeOwnership)
		 (state) IN
      a = outAsymKey(srkVal,TPM_SUCCESS);

  %% Wrap new key k with parent key
  TPM_CreateWrapKey(parent,k:(asymKey?),k_auth:AUTHDATA) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateWrapKey(parent,k,k_auth))));

  create_wrap_key_success: THEOREM FORALL (p,k:(asymKey?),a:AUTHDATA, state:tpmAbsState) : 
     LET (a,s) = runState(
     	         TPM_Init
		 >> TPM_Startup(TPM_ST_CLEAR)
		 >> CPU_senter
		 >> CPU_sinit
		 >> TPM_CreateWrapKey(p,k,a))
		 (state) IN
      LET wk : wrapKey = (# parentKey:=p, childKey:=k #) IN
      a = outWrapKey(wk,TPM_SUCCESS);


  %% Install key k in a TPM
  TPM_LoadKey2(k:wrapKey):State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_LoadKey2(k))));

  % A key is installed if it is wrapped with SRK
  % proved - Tue Jun 12 15:37:56 CDT 2012
  load_key_success: THEOREM FORALL (k:wrapKey,state:tpmAbsState) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_LoadKey2(k))
		  (state) IN
      IF parentKey(k) = srk(s)
         THEN member(childKey(k),keys(s))
	 ELSE not(member(childKey(k),keys(s)))
      ENDIF;

  %% A key is installed if it is wrapped with an installed key
  %% proved - Tue Jun 12 15:38:22 CDT 2012
  load_key_success2: THEOREM FORALL (j,k:wrapKey,state:tpmAbsState) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_LoadKey2(k)
		  >> TPM_LoadKey2(j))
		  (state) IN
      parentKey(j) = childKey(k) AND parentKey(k) = srk(s) =>
         member(childKey(j),keys(s));
	
  load_prev_key_success: THEOREM FORALL (k,p:(asymKey?),auth:AUTHDATA,state:tpmAbsState) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
                  >> TPM_CreateWrapKey(p,k,auth)
		  >>= LAMBDA(a:tpmAbsOutput) : 
		      IF outWrapKey?(a) THEN
		           TPM_LoadKey2(owk(a)) ELSE TPM_Noop(a)ENDIF)
		  (state) IN 
      IF member(p,keys(s)) OR p=srk(s) 
      	 THEN member(k,keys(s))
	 ELSE not(member(k,keys(s)))
      ENDIF;


  %%install nested wrapped keys?
  nested_wrapped_keys_success: THEOREM FORALL (k,j,p:(asymKey?),a1,a2:AUTHDATA,state:tpmAbsState) :
     LET (out,s) = runState(
     	 	   TPM_Init
      		   >> TPM_Startup(TPM_ST_CLEAR)
		   >> CPU_senter
		   >> CPU_sinit
		   >> TPM_CreateWrapKey(p,k,a1)
		   >>= LAMBDA (a:tpmAbsOutput) : IF outWrapKey?(a) THEN
		   TPM_LoadKey2(owk(a)) ELSE TPM_Noop(a) ENDIF
		   >> TPM_CreateWrapKey(k,j,a2)
		   >>= LAMBDA (a:tpmAbsOutput) : IF outWrapKey?(a) THEN
		   TPM_LoadKey2(owk(a)) ELSE TPM_Noop(a) ENDIF)
		   (state) IN
	p=srk(s) OR member(p,keys(s))
	=>
	member(j,keys(s)) 
	%AND member(k,keys(s));



  %% Make a new identity and output it
  TPM_MakeIdentity(n:(asymKey?),k:(symKey?),a:AUTHDATA) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_MakeIdentity(n,k,a))));

  make_identity_success: THEOREM FORALL(state:tpmAbsState,a:(asymKey?),k:(symKey?),auth:AUTHDATA) :
     LET (out,s) = runState(
     	         TPM_Init
		 >> TPM_Startup(TPM_ST_CLEAR)
		 >> CPU_senter
		 >> CPU_sinit
		 >> TPM_MakeIdentity(a,k,auth))
		 (state) IN
    LET waik:wrapKey = (# parentKey:=srk(s),childKey:=a #) IN
      out = outIdentity(waik,outCertReq(waik,ekVal,k,TPM_SUCCESS),TPM_SUCCESS);

   
  %% Use an AIK
  TPM_ActivateIdentity(a:wrapKey,k:(symKey?)) : State =
     modifyOutput(outNothing,
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_ActivateIdentity(a,k))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ActivateIdentity(a,k)))
	    );

  %% Assure that activate idenity installs its AIK and returns K if AIK can
  %% be installed.
  %% proved - Thu Jul 12 10:26:02 EDT 2012
  activate_identity_success : THEOREM FORALL (aik:wrapKey,k:(symKey?)) :
    LET (out,s) = runState(
                  TPM_ActivateIdentity(aik,k))
		  (tpmStartup) IN
      out = IF checkKeyRoot(aik,srk(s))
            THEN outSymKey(k,TPM_SUCCESS)
	    ELSE outNothing
	    ENDIF
      AND checkKeyRoot(aik,srk(s)) => member(childKey(aik),keys(s));

  activate_prev_success: THEOREM FORALL (aik:(asymKey?),k:(symKey?),auth:AUTHDATA) :
   LET  (out,s) = runState(
 		  TPM_MakeIdentity(aik,k,auth) % identity is output
		  >>= LAMBDA(a:tpmAbsOutput) : 
		      IF outIdentity?(a) THEN
		           TPM_ActivateIdentity(oidentaik(a),k)ELSE TPM_Noop(a) ENDIF)
		  (tpmStartup) IN
      out = outSymKey(k,TPM_SUCCESS)
       AND 
      member(aik,keys(s));


  %% Generate and output a signature
  TPM_Sign(k:KEY,aik:wrapKey,b:BLOB) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Sign(k,aik,b))));
	   
  sign_success: THEOREM FORALL(k:KEY,aik:wrapKey,b:BLOB,state:tpmAbsState) :
     LET(out,s) = runState(
     		  TPM_Sign(k,aik,b))
		  (state) IN
		  IF k /= childKey(aik)
		  THEN out = outBlob(signBlob(k,b),TPM_SUCCESS)
		  ELSE out = outError(TPM_INVALID_KEYUSAGE)
		  ENDIF
		  %Need to test to make sure aik parameter is actual aik?
	           	  
  %% Output PCR(i)
  TPM_PcrRead(i:PCRINDEX) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PcrRead(i))));

  pcrRead_success: THEOREM(FORALL(i:PCRINDEX,state:tpmAbsState) : 
     LET(out,s) = runState(TPM_PcrRead(i))
		    (state) IN
	out = outPCR(pcrs(s)(i),TPM_SUCCESS));


  %% Generate and output a quote
  TPM_Quote(k:wrapKey,n:BLOB,pm:PCRMASK) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Quote(k,n,pm))));

  %% If nonces don't match, quotes don't match.  We don't care about this
  %% if the a quote cannot be produced.
  %% proved - Fri Jun 22 16:55:16 CDT 2012
  bad_nonce: THEOREM
    FORALL(k:wrapKey, n1,n2:BLOB, pm:PCRMASK, s:tpmAbsState) :
      n1/=n2 AND checkKeyRoot(k,srk(s)) =>
       runState(
         TPM_Quote(k,n1,pm))
	 (s)
       /=
       runState(
	 TPM_Quote(k,n2,pm))
	 (s);
  
  %% Bad Signing Key - Man in the Middle Attack - we don't care about this
  %% if either key won't produce a quote.
  %% proved - Fri Jun 22 16:55:56 CDT 2012
  bad_signing_key: THEOREM
    FORALL(n:BLOB, pm:PCRMASK, k0,k1:wrapKey, s:tpmAbsState) :
      LET (a0,s0) = runState(TPM_Quote(k0,n,pm))(s) IN
        LET (a1,s1) = runState(TPM_Quote(k1,n,pm))(s) IN
          private(childKey(k0)) /= private(childKey(k1)) 
	  AND checkKeyRoot(k0,srk(s))
	  AND checkKeyRoot(k1,srk(s))
          =>
	  a0 /= a1;
     
  %% Output after going through tpm commands is same as grabbing pcrs
  %% This is one of those theorems where assert must be called before grind
  %% proved - Fri Jun 22 16:56:08 CDT 2012
  check_PCRS: THEOREM (FORALL(k:wrapKey,hv:HV,pm:PCRMASK,n:BLOB,state:tpmAbsState) :
    LET (a,s) =
      runState(
        TPM_Init
        >> TPM_Startup(TPM_ST_CLEAR)
        >> CPU_senter
        >> CPU_sinit
        >> TPM_Extend(hv,0)
        >> TPM_Quote(k,n,pm))
      (state) IN
    checkKeyRoot(k,srk(s)) => 
      a = outQuote(private(childKey(k)),n,map(s`pcrs,pm),TPM_SUCCESS));

  %% Prove that quote generation returns the correct PCR.  This theorem
  %% needs to be updated with something cleaner.
  %% proven - Wed Jul 11 10:40:28 EDT 2012
  quote_monad: THEOREM (FORALL (k:wrapKey,hv:HV,n:BLOB, state:tpmAbsState) :
        LET (a,s) = runState(
          TPM_Init
          >> TPM_Startup(TPM_ST_CLEAR)
      	  >> CPU_senter
	  >> CPU_sinit
      	  >> TPM_Extend(hv,0)
      	  >> TPM_Quote(k,n,cons(0,null)))
      	  (state)
	IN parentKey(k) = private(asymKey(srkKeyVal)) =>
        a = outQuote(private(childKey(k)),
	             n,
		     cons(
		       extend(
		     	 extend(
		       	   extend(reset,hash(sinit)),hash(mle)),hv),null),
		     TPM_SUCCESS))
      
  quote_with_prev_key:
    THEOREM
    FORALL (k:(asymKey?),state:tpmAbsState,n:BLOB,pm:PCRMASK,sessk:(symKey?),auth:AUTHDATA) :
       LET (out,s) = runState(
                   TPM_Init
		   >> TPM_Startup(TPM_ST_CLEAR)
		   >> CPU_senter
		   >> CPU_sinit
		   >> TPM_MakeIdentity(k,sessk,auth)
		   >>= LAMBDA (a:tpmAbsOutput) : 
		   IF outIdentity?(a) THEN
			TPM_Quote(oidentaik(a),n,pm)ELSE TPM_Noop(a)ENDIF)
		   (state) IN
        out = outQuote(private(k),
	               n,
                       map((pcrsReset(pcrFlags(s)) WITH [(0) := extend(
                                                     extend(reset,hash(sinit)),
                                                     hash(mle))]),
	                   pm),
		       TPM_SUCCESS);


  %% Seal and output a blob (should be binary or data)
  TPM_Seal(k:(asymKey?),data:BLOB) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Seal(k,data))));

  %% Seal a secret successfully
  seal_secret_success: THEOREM
    FORALL (k:(asymKey?),hv:HV,b:BLOB,state:tpmAbsState) :
      LET (out,s) = runState(
 		  TPM_Seal(k,b))
 		  (tpmStartup) IN
	IF nothing?(b) 
	  THEN out = outError(TPM_BAD_PARAMETER) 
	  ELSE out = outBlob(sealBlob(k,s`pcrs,b),TPM_SUCCESS)
	ENDIF

  %% Unseal and output a blob (should be binary or data)
  TPM_Unseal(d:(sealBlob?),k:(asymKey?)) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Unseal(d,k))));

  %% Unseal a secret successfully - This is not right yet 
  unseal_secret_success: THEOREM
    FORALL (j,k:(asymKey?),hv:HV,b:BLOB,pcrs:PCRS,state:tpmAbsState) :
      LET (out,s) = runState(
      	  	  TPM_Unseal(sealBlob(k,pcrs,b),j))
		  (tpmStartup) IN
      IF j=private(k) AND pcrs=pcrs(s) AND not(nothing?(b))
         THEN out=outBlob(b,TPM_SUCCESS)
         ELSE out=outError(TPM_NOTSEALED_BLOB) 
      ENDIF;  

  unseal_prev_success: THEOREM
    FORALL (k,j:(asymKey?),b:BLOB,pcrs:PCRS,state:tpmAbsState) :
      LET (out,s) = runState(
      	  	  TPM_Seal(k,b)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		  IF outBlob?(a) AND sealBlob?(obl(a)) THEN
		       TPM_Unseal(obl(a),j) ELSE TPM_Noop(a)ENDIF)
		  (tpmStartup) IN  
	j=private(k) AND pcrs=pcrs(s) AND not(nothing?(b))
	   => out = outBlob(b,TPM_SUCCESS)      


  %% UnBind encrypted blob (decrypt)
  TPM_UnBind(d:(encryptBlob?),k:(asymKey?)) : State = 
     output(outNothing,
	    (LAMBDA (s:tpmAbsState): outputCom(s,ABS_UnBind(d,k))));

  %% UnBind an encrypted blob successfully
  unBind_success : THEOREM
    FORALL (k,j:(asymKey?),b:BLOB,state:tpmAbsState) : 
      LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_UnBind(encryptBlob(j,b),k))
		  (state) IN
      j = private(k) =>
       out = outBlob(b,TPM_SUCCESS)

	
  Tspi_Data_Bind(k:KEY,d:BLOB) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Data_Bind(k,d))));

  %% UnBind an encrypted blob successfully
  unBind_prev_success:THEOREM 
    (FORALL(d:BLOB,k,j:(asymKey?),auth:AUTHDATA,state:tpmAbsState) : 
      LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_CreateWrapKey(j,k,auth)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		  IF outWrapKey?(a) THEN
		       TPM_LoadKey2(owk(a)) ELSE TPM_Noop(a) ENDIF
		  >> Tspi_Data_Bind(k,d)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		  IF outBlob?(a) AND encryptBlob?(obl(a)) THEN
		       TPM_UnBind(obl(a),private(k)) ELSE TPM_Noop(a) ENDIF)
 		  (state) IN 
 	  j = srk(s) OR  member(j,keys(s)) => out = outBlob(d,TPM_SUCCESS)
	 );


  %% Monotonicity of locality
  %% Assuming that we're not resetting or powering on, locality goes down
  %% or remains the same
  %% unproven - Wed Jun 13 23:15:36 CDT 2012
  monotonic_locality: THEOREM (FORALL (s:tpmAbsState,c:tpmAbsInput) :
    not(ABS_Init?(c) or ABS_Startup?(c)) =>
      locality(s) >= locality(executeCom(s,c)));


  pcrs_unchanged: THEOREM (FORALL (s:tpmAbsState,c:tpmAbsInput) :
    not(ABS_Extend?(c) or 
    	ABS_Startup?(c) or 
	ABS_sinit?(c) or 
	ABS_senter?(c) or 
	ABS_Init?(c)) =>
      pcrs(s) = pcrs(executeCom(s,c)));

  srk_unchanged: THEOREM (FORALL (s:tpmAbsState,c:tpmAbsInput) :
    not(ABS_Startup?(c) or ABS_Init?(c)) =>
      srk(s) = srk(executeCom(s,c)));

  ek_unchanged: THEOREM (FORALL (s:tpmAbsState,c:tpmAbsInput) :
    not(ABS_Startup?(c) or ABS_Init?(c)) =>
      ek(s) = ek(executeCom(s,c)));

  keys_unchanged: THEOREM (FORALL (s:tpmAbsState,c:tpmAbsInput) :
    not(ABS_Startup?(c) or ABS_Init?(c) or 
    	ABS_LoadKey2?(c) or ABS_ActivateIdentity?(c)) =>
      keys(s) = keys(executeCom(s,c)));

  postInit_unchanged: THEOREM (FORALL (s:tpmAbsState,c:tpmAbsInput) :
    not(ABS_Startup?(c) or ABS_Init?(c)) =>
      postInit(s) = postInit(executeCom(s,c)));

  
  %% Prove that skipping SENTER is detectable by showing the quote following
  %% a command differs when SENTER is excluded.
  %% proved - Tue Jun 12 15:34:24 CDT 2012
  no_senter: THEOREM (FORALL (k:wrapKey,hv:HV,n:BLOB,pcrMask:PCRMASK,state:tpmAbsState) :
    runState(
      TPM_Init
      >> TPM_Startup(TPM_ST_CLEAR)
      >> CPU_senter
      >> CPU_sinit
      >> TPM_Extend(hv,0)
      >> TPM_Quote(k,n,pcrMask))
      (state)
    /=
    runState(
      TPM_Init
      >> TPM_Extend(hv,0)
      >> TPM_Quote(k,n,pcrMask))
      (state))

  %% TPMs will not lie about who they are.  If the AIK cannot be installed
  %% then no quote will be generated
  %% proved - Wed Jul 11 11:28:46 EDT 2012
  aik_binding : THEOREM
    FORALL (aik:wrapKey,b:BLOB,pm:PCRMASK,state:tpmAbsState) :
      LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_Quote(aik,b,pm))
		  (state) IN
       NOT checkKeyRoot(aik,srk(s)) => out=outError(TPM_INVALID_KEYUSAGE);              

   %% Simple verification of the quote generation process from init
   %% through generation of the appraiser's quote.  Yay.  This is what
   %% I was after!!
   %%
   %% Memory map:  
   %% 0 -> identity
   %% 1 -> CA cert
   %% 2 -> TPM quote
   %%
   %% Note that the identity is not used in building the final
   %% appraiser's quote
   %% proved Sat Jul 14 11:19:56 CDT 2012
   cert_and_quote_with_prev_key: THEOREM
     FORALL (aik:(asymKey?),
             state:tpmAbsState,
	     n:BLOB,
	     pm:PCRMASK,
	     k:(symKey?),
	     sml:SML,
	     auth:AUTHDATA) :
       LET (out,s) = runState(
                   TPM_Init
 		   >> TPM_Startup(TPM_ST_CLEAR)
 		   >> CPU_senter
 		   >> CPU_sinit
 		   >> TPM_MakeIdentity(aik,k,auth) % identity is output
		   >>= CPU_saveOutput(0)
		   >>= (LAMBDA (a:tpmAbsOutput) :
		         CASES a OF
			   outIdentity(x,oic,rc) : CA_certify(oic)
			   ELSE TPM_Noop(a)
			 ENDCASES)
	           >>= CPU_saveOutput(1)
	           >>= (LAMBDA (a:tpmAbsOutput) :
		         CASES a OF
			   outIdentActivation(actc,sk,actek,rc) : TPM_ActivateIdentity(wkey(actc),k)
			   ELSE TPM_Noop(a)
			 ENDCASES)
		   >> CPU_read(0)
		   >>= (LAMBDA (a:tpmAbsOutput) :
		         CASES a OF 
			   outIdentity(aik,ic,rc) : TPM_Quote(aik,n,pm)
			   ELSE TPM_Noop(a)
			 ENDCASES)
		   >>= CPU_saveOutput(2) % Quote is saved in 2
		   >> CPU_BuildQuoteFromMem(2,1,1,sml) % Build the quote
		   )
 		   (state) IN
		   LET wk:wrapKey = (# parentKey:= private(asymKey(srkKeyVal)),
                                       childKey := aik #)
				       IN
         out = outFullQuote(certBlob(private(asymKey(caKeyVal)),wk),
                               sml,
                               outQuote(private(aik),
                                        n,
                                        map
                                        ((pcrsReset(pcrFlags(s))
                                          WITH [(0)
                                                := extend
                                                   (extend
                                                    (reset, hash(sinit)),
                                                    hash(mle))]),
                                         pm),
					 TPM_SUCCESS),
				TPM_SUCCESS)	    
END tpm
