%% ----
%%
%% TPM Theory
%%
%% Author: Perry Alexander, Brigid Halling
%% Date: Mon Nov 28 01:09:39 CST 2011
%%
%% Description: Basic model of a TPM using a monadic state model
%% 
%% Dependencies:
%%  StateMonad.pvs
%%  key.pvs
%%  pcr.pvs
%%
%% Todo: (key - => pending, + => done)
%%  - AIKs are all wrapped by EK - no chaining allowed
%%  - AIKs need to be installed, not just checked, when used
%%  + MakeIdentity creates a pair
%%  - data sent to the CA is encrypted with the CA public key
%% ----

tpm [ B:TYPE+, % BLOB
      HV:TYPE+,% Hash value
      hash:[B->HV], % Hash function
      K:TYPE+ % Key
     ] : THEORY

  BEGIN

  ASSUMING
    % Assume that different blobs always have different hashes
    unique_hash: ASSUMPTION
      FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
  ENDASSUMING

  IMPORTING pcr[HV];
  IMPORTING key[B,K,HV];

  %% State monad input type.  All inputs are in the form of a command with
  %% parameters.
  tpmInput : DATATYPE
  BEGIN
    decryptKeyCom(d:(encrypt?)) : decryptKeyCom?
    encryptCom(en:BLOB) : encryptCom? % unimplemented
    %% Startup commands
    ABS_Init : ABS_Init? % TPM goes into a state where only ABS_startup
                         % is allowed.  This is a hardware signal and cannot
			 % be invoked by software
    ABS_Startup : ABS_Startup? % clear - all variables back to default values
                               % save - restore from ABS_SaveState
			       % deactivated - turn off and wait for ABS_init
    ABS_SaveState : ABS_SaveState? % unimplemented
    %% PCRs, quotes, seals and keys
    ABS_Extend(h:HV,i:PCRINDEX) : ABS_Extend?
    ABS_Unseal(s:(seal?),uk:(asymKey?)) : ABS_Unseal?   
    ABS_Seal(sk:(asymKey?),data:BLOB) : ABS_Seal?
    ABS_LoadKey2(lk:(wrapKey?)): ABS_LoadKey2? 
    ABS_CreateWrapKey(parentk,wk:(asymKey?),wk_auth:AUTHDATA): ABS_CreateWrapKey?
    %% Quotes and Identities
    ABS_Quote(aik:(wrapKey?),nonce:BLOB,pm:PCRMASK) : ABS_Quote? % partially implemented
    ABS_MakeIdentity(naik:(asymKey?),k:(symKey?),auth:AUTHDATA) : ABS_MakeIdentity?
    ABS_ActivateIdentity(caik:(wrapKey?),k:(symKey?)) : ABS_ActivateIdentity? % unimplemented
    %% Ownership management
    ABS_TakeOwnership : ABS_TakeOwnership?
    ABS_OwnerClear : ABS_OwnerClear? % unimplemented
    ABS_ForceClear : ABS_ForceClear? % unimplemented
    ABS_DisableOwnerClear : ABS_DisabelOwnerClear? % unimplemented
    %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    %% CA Commands
    ABS_certify(cr:(certReq?)) : AVS_certify?
    %% Invented, imaginary Commands
    noopCom : noopCom?
    offCom : offCom?
    revokeKeyCom(rk:(wrapKey?)): revokeKeyCom?

  END tpmInput;

  %% State monad output type
  tpmAbsOutput : DATATYPE
  BEGIN
    outNothing : outNothing?
    outError(s:string) : outError?
    outNat(n:nat) : outNat?
    outQuote(qk:KEY,non:BLOB,pcrs:list[PCR]) : outQuote?
    outBlob(bl:BLOB) : outBlob?
    outKey(k:KEY) : outKey?
  END tpmAbsOutput;

  %% sinit blob instance for measurement
  sinit : B;

  %% mle blob instance for measurement
  mle : B;

  %% Locality type - check with spec
  LOCALITY : TYPE = {n:nat | n<=4};

  %% Uninterpreted Key values.
  ekKeyVal : K;
  srkKeyVal : K;
  caKeyVal : K

  %% Key definitions that make ek and srk values asymmetric keys.
  ekVal : KEY = asymKey(ekKeyVal);
  srkVal : KEY = asymKey(srkKeyVal);
  caVal : KEY = asymKey(caKeyVal); % Certificate Authority key

  %% Abstract TPM State with keys, PCR array and locality
  tpmAbsState : TYPE = [#
                       postInit : bool,
                       srk : (asymKey?),
		       ek : (asymKey?),
		       keys : KEYSET,
                       pcrs : PCRS,
		       locality : LOCALITY
		    #];

  IMPORTING StateMonad[tpmAbsOutput,tpmAbsState];

  %% Define some common TPM states and state operations
  
  %% Unknown state
  tpmUnknown : tpmAbsState

  %% Power on state after init is raised by hardwer
  tpmPostInit : tpmAbsState = (#
                         pcrs:=pcrsPower
			 , postInit:=true
                         , locality:=4
			 , keys:=emptyset
			 , srk:=private(srkVal)
			 , ek:=private(ekVal)
			 #);

  %% Standard initial state following startup command.  Technically, there
  %% will be many results of TPM_Startup, but this is a good starting point
  tpmStartup : tpmAbsState = (#
                         pcrs:=pcrsReset
			 , postInit:=false
			 , locality:=4
			 , keys:=emptyset
			 , srk:=private(srkVal)
			 , ek:=private(ekVal)
			 #);

  %% Predicate to determine if startup has occured.  Used as types
  %% (afterInit?) is the set of states occuring immediately after TPM_Init
  %% (afterStartup?) is the set of states occuring immediately after
  %% TPM_Startup
  afterInit?(s:tpmAbsState):bool = postInit(s);
  afterStartup?(s:tpmAbsState):bool = NOT postInit(s);

  %% Standard operations on TPM state definition above.  All such
  %% functions end with State to indicate they operate on the state
  %% value rather than on the TPM monad.  Note that key set and pcr
  %% manipulation functions are defined externally in key.pvs and
  %% pcr.pvs respectively

  %% Reset PCRs as performed by SENTER.
  pcrsResetSenterState(s:tpmAbsState) : tpmAbsState =
    s WITH [`pcrs := pcrsReset];

  %% Decrease locality value
  changeLocalityState(s:tpmAbsState) : tpmAbsState =
    s WITH [`locality := IF locality(s) > 0
                         THEN locality(s) - 1
			 ELSE 0
			 ENDIF];
  
  %% Extend operation on TPM state
  extendState(s:tpmAbsState,n:PCRINDEX,h:HV) : tpmAbsState =
    s WITH [`pcrs := pcrsExtend(pcrs(s),n,h)];

  %% Install key operation on TPM state.
  loadKey2State(s:tpmAbsState,k:(wrapKey?)) : tpmAbsState =
    s WITH [`keys := addKey(k,srk(s),keys(s))];

  %% Revoke key operation on TPM state
  revokeKeyState(s:tpmAbsState,k:(wrapKey?)) : tpmAbsState =
    s WITH [`keys := removeKey(k,keys(s))];

  %% Decrypt a secret encrypted with a wrapped key
  decryptKeyState(s:tpmAbsState,d:(encrypt?)) : BLOB =
    CASES key(d) OF
      wrapKey(w,k,a) : IF member(private(w),add(srk(s),keys(s)))
                        THEN blob(d)
			ELSE nothing ENDIF
      ELSE nothing
    ENDCASES;

  % Use an AIK.  This is currently unimplemented.
  activateIdentityState(s:tpmAbsState,a:(wrapKey?),k:(symKey?)) : tpmAbsState =
    loadKey2State(s,a);

  %% What we want to generate with each command is a pair of type
  %% [tpmAbsOut,tpmAbsState].  executeCom generates the the state
  %% from a TPM state and command while the upcoming outputCom
  %% generates the corresponding output.  Thus, to execute any
  %% operation, both executeCom and outputCom must be used

  %% Run if TPM_Init has run but TPM_Startup has not
  executeComPostInit(s:(afterInit?),c:tpmInput) : tpmAbsState =
    CASES c OF
      ABS_Startup : tpmStartup
      ELSE s
    ENDCASES;

  %% Run if ABS_Startup has run
  executeComStartup(s:(afterStartup?),c:tpmInput) : tpmAbsState = 
    CASES c OF
      ABS_Extend(h,n) : extendState(s,n,h),
      ABS_LoadKey2(k): loadKey2State(s,k), 
      revokeKeyCom(k): revokeKeyState(s,k),
      noopCom : s,
      offCom : tpmUnknown,
      ABS_Init : tpmPostInit,
      ABS_Startup : s,
      ABS_senter : 
        changeLocalityState(extendState(pcrsResetSenterState(s),0,hash(sinit))),
      ABS_sinit : changeLocalityState(extendState(s,0,hash(mle))),
      ABS_Quote(k,n,pm) : s,
      decryptKeyCom(d) : s,
      ABS_Unseal(d,k) : s,
      ABS_Seal(k,data) : s,
      ABS_TakeOwnership : s,
      ABS_CreateWrapKey(k,parent,a): s,
      ABS_ActivateIdentity(a,k) : activateIdentityState(s,a,k)
      ELSE s
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInit=true.
  executeCom(s:tpmAbsState,c:tpmInput) : tpmAbsState =
    IF afterInit?(s)
       THEN executeComPostInit(s,c)
       ELSE executeComStartup(s,c)
    ENDIF;

  % Generate a NEW RANDOM key pair.
  createWrapKeyOut(parent,k:(asymKey?),k_auth:AUTHDATA):tpmAbsOutput = 
     outKey(wrapKey(parent,k,k_auth));

  % NEED TO ENSURE NEW, RANDOM SRK KEY PAIR
  takeOwnershipOut : tpmAbsOutput =
     outKey(srkVal);
  
  % Output PCRs from a state as quote
  quoteOut(s:tpmAbsState,k:(wrapKey?),n:BLOB,pm:PCRMASK) : tpmAbsOutput =
    IF checkKeyRoot(k,srk(s))
    THEN outQuote(private(key(k)),n,getPCRs(s`pcrs,pm))
    ELSE outNothing
    ENDIF;

  % Output a newly generated AIK.  Note that a simulates the new aik.
  makeIdentityOut(s:tpmAbsState,a:(asymKey?),k:(symKey?),auth:AUTHDATA) : tpmAbsOutput =
    LET waik:(wrapKey?) = wrapKey(srk(s),a,auth) IN
      outBlob(identity(waik,certReq(waik,ekVal,k)));

  % Output decypted key
  decryptKeyOut(s:tpmAbsState,d:(encrypt?)) : tpmAbsOutput = 
    outBlob(decryptKeyState(s,d));

  % Output secret unsealed with an asymetric key and PCRs 
  unsealOut(s:tpmAbsState,d:(seal?),k:(asymKey?)) : tpmAbsOutput = 
    outBlob(unseal(d,pcrs(s),k));

  % Output secret sealed with asymetric key 
  sealOut(s:tpmAbsState,k:(asymKey?),data:BLOB) : tpmAbsOutput = 
    outBlob(seal(k,pcrs(s),data));

  % Generate a certified AIK from an AIK.  Certification assumes that the
  % EK really does belong to the TPM.  We're abstracting away that check.
  certOut(s:tpmAbsState,cr:(certReq?)) : tpmAbsOutput =
    outBlob(identActivation(cert(private(caVal),key(aik(cr))),k(cr),ek(cr)))

  % Retrieve a key if a can be installed
  activateIdentityOut(s:tpmAbsState,a:(wrapKey?),k:(symKey?)) : tpmAbsOutput =
    IF checkKeyRoot(a,srk(s)) THEN outBlob(key(k)) ELSE outNothing ENDIF;

  %% Generate output from a command and state
  outputCom(s:tpmAbsState,c:tpmInput) : tpmAbsOutput = 
    CASES c OF
      ABS_Extend(h,n) : outNothing,
      ABS_LoadKey2(k): outNothing, 
      revokeKeyCom(k): outNothing,
      noopCom : outNothing,
      offCom : outNothing,
      ABS_Init : outNothing,
      ABS_senter : outNothing,
      ABS_sinit : outNothing,
      ABS_Quote(k,n,pm) : quoteOut(s,k,n,pm),
      ABS_MakeIdentity(a,k,auth) : makeIdentityOut(s,a,k,auth), 
      ABS_ActivateIdentity(a,k) : activateIdentityOut(s,a,k),
      decryptKeyCom(d) : decryptKeyOut(s,d),
      ABS_Unseal(d,k) : unsealOut(s,d,k),
      ABS_Seal(k,data) : sealOut(s,k,data),
      ABS_TakeOwnership : takeOwnershipOut,
      ABS_CreateWrapKey(k,parent,a) : createWrapKeyOut(k,parent,a),
      ABS_certify(cr) : certOut(s,cr)
    ELSE outNothing
  ENDCASES;

  %% Monotonicity of locality
  %% Assuming that we're not resetting or powering on, locality goes down
  %% or remains the same
  %% unproven - Wed Jun 13 23:15:36 CDT 2012
  monotonic_locality: THEOREM (FORALL (s:tpmAbsState,c:tpmInput) :
    not(offCom?(c) or ABS_Init?(c) or ABS_Startup?(c)) =>
      locality(s) >= locality(executeCom(s,c)));

  %% Minor Support Lemmas

  %% Extend is antisymmetric if the hash values used for extension are
  %% not equal.  In this example we use the LET form to define
  %% commands directly with monad functions defined in StateMonad.pvs
  antisymmetryMonad: THEOREM (FORALL (hv0,hv1:HV):
    LET f1:State =
          modify(outNothing,
                 (LAMBDA (s:tpmAbsState):s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv0)])),
      	f2:State =
          modify(outNothing,
                 (LAMBDA (s:tpmAbsState):s WITH [`pcrs:=pcrsExtend(pcrs(s),0,hv1)])) IN
      hv0/=hv1 =>
        runState(
          f2 >>= (LAMBDA (x:tpmAbsOutput): f1 >>= unit))(tpmStartup)
        /=
        runState(
          f1 >>= (LAMBDA (x:tpmAbsOutput): f2 >>= unit))(tpmStartup))

  %% TPM Command Definitions - Note that all commands used by the TPM
  %% have the TPM suffix to distinguish from operations on tpm state.
  %% Commands thus far are defined as state transforming or output
  %% generating.  This does not exclude the eventuality of doing both.

  %% Extend PCR n with hash value h.
  TPM_Extend(h:HV,n:PCRINDEX):State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Extend(h,n))));

  %% Install key k in a TPM
  TPM_LoadKey2(k:(wrapKey?)):State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_LoadKey2(k))));

  %% Revoke key k from a TPM - unused - not a real TPM command
  TPM_RevokeKey(k:(wrapKey?)):State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,revokeKeyCom(k))));

  %% Noe-op - not a real TPM command
  TPM_Noop : [tpmAbsOutput -> State] =
    (LAMBDA (a:tpmAbsOutput): state((LAMBDA(s:tpmAbsState) : (a,s))));

  %% TPM is off - not a real TPM command
  TPM_Off : State = put(outNothing,tpmUnknown);

  %% Power up the TPM and hit the TPM_Init signal
  TPM_Init : State = put(outNothing,tpmPostInit);

  %% Start up the TPM after TPM_Init
  TPM_Startup : State =
    modify(outNothing,
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Startup)));
  
  %% The only command that can run and do anyting folling a TPM_Init is 
  %% TPM_Startup.  If anything else tries to run, nothing happens.  Note
  %% the use of an "anything" command in the first command sequence.
  startup_after_init : THEOREM FORALL
    (s0:tpmAbsState,a:tpmAbsOutput,c:tpmInput) :
      NOT ABS_Startup?(c) =>
        runState(TPM_Init
               >> state(LAMBDA (s:tpmAbsState):(a,executeCom(s,c)))
	       >>= unit)
	       (s0)`2
        =
        runState(TPM_Init
               >>= unit)
	      (s0)`2
                    
  %% Call SENTER 
  CPU_senter : State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_senter)));

  %% Reset the TPM by senter call - depreciated - DO NOT USE
  senterResetTPM : State = put(outNothing,tpmStartup);

  %% Measure sinit by senter call - depreciated - DO NOT USE
  senterHashSinitTPM : State = TPM_Extend(hash(sinit),0);

  %% Call sinit for initial measurements - currently unused
  CPU_sinit : State =
    modify(outNothing,
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_sinit)));
  
  %% Establish SRK
  TPM_TakeOwnership : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_TakeOwnership)));

  %% Wrap new key k with parent key
  TPM_CreateWrapKey(parent,k:(asymKey?),k_auth:AUTHDATA) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_CreateWrapKey(parent,k,k_auth))));
		
  %% Generate and output a quote
  TPM_Quote(k:(wrapKey?),n:BLOB,pm:PCRMASK) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Quote(k,n,pm))));

  %% Make a new identity and output it
  TPM_MakeIdentity(n:(asymKey?),k:(symKey?),a:AUTHDATA) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_MakeIdentity(n,k,a))));

  %% Use an AIK
  TPM_ActivateIdentity(a:(wrapKey?),k:(symKey?)) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ActivateIdentity(a,k))));

  %% Decrypt and output a blob (should be a key)
  TPM_Decrypt(d:(encrypt?)) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,decryptKeyCom(d))));

  %% Unseal and output a blob (should be binary or data)
  TPM_Unseal(d:(seal?),k:(asymKey?)) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Unseal(d,k))));

  %% Seal and output a blob (should be binary or data)
  TPM_Seal(k:(asymKey?),data:BLOB) : State = 
     output(outNothing,
            (LAMBDA (s:tpmAbsState): outputCom(s,ABS_Seal(k,data))));

  %% Invoke the certification authority
  CA_certify(cr:(certReq?)) : State =
     output(outNothing,
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_certify(cr))));

  %% Extending a reset PCR is antisymmetric if the two values are not equal
  %% Let form used to defined commands for bind.  Will use command forms
  %% later in antisymmetryMonad3
  antisymmetryMonad2: THEOREM (FORALL (hv0,hv1:HV) :
    LET 
        f1:State = TPM_Extend(hv0,0),
      	f2:State = TPM_Extend(hv1,0) IN
      (hv0/=hv1 =>
        runState(f2 >> f1 >>= unit)(tpmStartup)
        /=
        runState(f1 >> f2 >>= unit)(tpmStartup)))


  %% Extending a reset PCR is antisymmetric if the two values are not equal.
  %% No let form - commands appear directly in bind
  %% Theorem is now false when PCRs other than PCR0 are included.
  antisymmetryMonad3: THEOREM (FORALL (hv0,hv1:HV) :
    hv0/=hv1 =>
       runState(
         TPM_Extend(hv1,0)
	 >> TPM_Extend(hv0,0)
	 >>= unit)
	 (tpmStartup)
       /=
       runState(
         TPM_Extend(hv0,0)
	 >> TPM_Extend(hv1,0)
	 >>= unit)
	 (tpmStartup))

  %% Prove that senter after power up results in reset PCRs followed by sinit
  %% measurement.
  %% proved - Tue Jun 12 15:31:12 CDT 2012
  resetMonad: THEOREM (FORALL (hv:HV) :
    LET (a,s) = runState(
      	          TPM_Init
      		  >> TPM_Startup
      		  >> CPU_senter
      		  >> CPU_sinit
      		  >>= unit)
      		  (tpmUnknown)
      IN s = changeLocalityState(changeLocalityState(extendState((extendState(tpmStartup,0,hash(sinit))),0,hash(mle)))))

  %% Prove that quote generation returns the correct PCR.  This theorem
  %% needs to be updated with something cleaner.
  %% proven - Wed Jul 11 10:40:28 EDT 2012
  quoteMonad: THEOREM (FORALL (k:(wrapKey?),hv:HV,n:BLOB) :
        LET (a,s) = runState(
          TPM_Init
          >> TPM_Startup
      	  >> CPU_senter
	  >> CPU_sinit
      	  >> TPM_Extend(hv,0)
      	  >> TPM_Quote(k,n,cons(0,null))
      	  >>= unit)
      	  (tpmUnknown)
	IN wrappingKey(k) = private(asymKey(srkKeyVal)) =>
        a = outQuote(private(key(k)),
	             n,
		     cons(
		       extend(
		     	 extend(
		       	   extend(reset,hash(sinit)),hash(mle)),hv),null)))

 
  %% If nonces don't match, quotes don't match.  We don't care about this
  %% if the a quote cannot be produced.
  %% proved - Fri Jun 22 16:55:16 CDT 2012
  badNonce: THEOREM (FORALL(k:(wrapKey?), n1,n2:BLOB, pm:PCRMASK, s:tpmAbsState) :
     n1/=n2 AND checkKeyRoot(k,srk(s)) =>
       runState(
         TPM_Quote(k,n1,pm))
	 (s)
       /=
       runState(
	 TPM_Quote(k,n2,pm))
	 (s));
  
  %% Bad Signing Key - Man in the Middle Attack - we don't care about this
  %% if either key won't produce a quote.
  %% proved - Fri Jun 22 16:55:56 CDT 2012
  badSigningKey: THEOREM (FORALL(n:BLOB, pm:PCRMASK, k0,k1:(wrapKey?), s:tpmAbsState) :
     LET (a0,s0) = runState(TPM_Quote(k0,n,pm))(s) IN
       LET (a1,s1) = runState(TPM_Quote(k1,n,pm))(s) IN
         private(key(k0)) /= private(key(k1)) 
	 AND checkKeyRoot(k0,srk(s))
	 AND checkKeyRoot(k1,srk(s))
         =>
	 a0 /= a1);
     
  %% Output after going through tpm commands is same as grabbing pcrs
  %% This is one of those theorems where assert must be called before grind
  %% proved - Fri Jun 22 16:56:08 CDT 2012
  checkPCRS: THEOREM (FORALL(k:(wrapKey?),hv:HV,pm:PCRMASK,n:BLOB) :
    LET (a,s) =
      runState(
        TPM_Init
        >> TPM_Startup
        >> CPU_senter
        >> CPU_sinit
        >> TPM_Extend(hv,0)
        >> TPM_Quote(k,n,pm)
        >>= unit)
      (tpmUnknown) IN
    checkKeyRoot(k,srk(s)) => 
      a = outQuote(private(key(k)),n,map(s`pcrs,pm)));

  %% Checks three parts of outQuote (key, nonce, pcrs)
  %checkQuote: THEOREM(badNonce AND badSigningKey AND checkPCRS);

  %% Prove that skipping SENTER is detectable by showing the quote following
  %% a command differs when SENTER is excluded.
  %% proved - Tue Jun 12 15:34:24 CDT 2012
  noSenter: THEOREM (FORALL (k:(wrapKey?),hv:HV,n:BLOB,pcrMask:PCRMASK) :
    runState(
      TPM_Init
      >> TPM_Startup
      >> CPU_senter
      >> CPU_sinit
      >> TPM_Extend(hv,0)
      >> TPM_Quote(k,n,pcrMask)
      >>= unit)
      (tpmUnknown)
    /=
    runState(
      TPM_Init
      >> TPM_Extend(hv,0)
      >> TPM_Quote(k,n,pcrMask)
      >>= unit)
      (tpmUnknown))

  %% Decryption will fail if no keys are installed
  %% Now proved.  Problem was with grind, not pvs generally.
  %% proved - Tue Jun 12 15:36:53 CDT 2012  
  decrypt_key_fail: THEOREM FORALL (k:(wrapKey?),b:BLOB) :
    LET (out,s) = runState(
                  TPM_Init
		  >> TPM_Startup
                  >> CPU_senter
                  >> CPU_sinit
                  >> TPM_Decrypt(encrypt(k,b))
                  >>= unit)
                  (tpmUnknown) IN
      private(wrappingKey(k))/=private(srkVal) => out = outBlob(nothing);

  %% Key chaining theorem.  If k is wrapped with srk and encrypts b,
  %% b will decrypt if k is installed
  %% proved - Tue Jun 12 15:37:29 CDT 2012
  decrypt_key_success: THEOREM FORALL (k:(wrapKey?),b:BLOB):
    LET (out,s) = runState(
                  TPM_Init
		  >> TPM_Startup
	  	  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_LoadKey2(k)
		  >> TPM_Decrypt(encrypt(k,b))
		  >>= unit)
		  (tpmPostInit) IN
        private(wrappingKey(k))=srk(s) => out=outBlob(b)


  % A key is installed if it is wrapped with SRK
  % proved - Tue Jun 12 15:37:56 CDT 2012
  install_key_success: THEOREM FORALL (k:(wrapKey?)) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_LoadKey2(k)
		  >>= unit)
		  (tpmUnknown) IN
      wrappingKey(k) = srk(s) => member(key(k),keys(s));

  %% A key is installed if it is wrapped with an installed key
  %% proved - Tue Jun 12 15:38:22 CDT 2012
  install_key_success2: THEOREM FORALL (j,k:(wrapKey?)) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_LoadKey2(k)
		  >> TPM_LoadKey2(j)
		  >>= unit)
		  (tpmUnknown) IN
      wrappingKey(j) = key(k) AND wrappingKey(k) = srk(s) =>
         member(key(j),keys(s));

  %% Unseal a secret successfully - This is not right yet 
  unseal_secret_success: THEOREM FORALL (j,k:(asymKey?),hv:HV,b:BLOB,pcrs:PCRS) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_Extend(hv,0)
		  >> TPM_Unseal(seal(k,pcrs,b),j)
		  >>= unit)
		  (tpmUnknown) IN
      IF j=private(k) AND pcrs=pcrs(s)
         THEN out=outBlob(b)
         ELSE out=outBlob(nothing)
      ENDIF;

  %% Seal a secret successfully
  seal_secret_success: THEOREM FORALL (j,k:(asymKey?),hv:HV,b:BLOB,s:tpmAbsState) :
    LET (out,s) = runState(
     	 	  TPM_Init
      		  >> TPM_Startup
 		  >> CPU_senter
 		  >> CPU_sinit
 		  >> TPM_Extend(hv,0)
 		  >> TPM_Seal(k,b)
		  >>= unit)
 		  (tpmUnknown) IN
      j = private(k) =>
      unseal(bl(out),s`pcrs,j) = b;
  

  %% Regression theorems for testing only

  test1a: THEOREM (unit(outNat(3))) =
           (state(LAMBDA (s:tpmAbsState) : (outNat(3),s)))
  test1b: THEOREM (runState(unit(outNat(3)))) =
           (runState(state(LAMBDA (s:tpmAbsState) : (outNat(3),s))))
  test1c: THEOREM (runState(unit(outNat(3))))(tpmStartup) =
           (runState(state(LAMBDA (s:tpmAbsState) : (outNat(3),s))))(tpmStartup)

  test2:  THEOREM (runState(unit(outNat(3))))(tpmStartup) = (outNat(3),tpmStartup)

  % Random hash values
  hv0, hv1, hv2 : HV

  % reset followed by a copy
  test3: THEOREM
    runState(modify(outNat(0),(LAMBDA (s:tpmAbsState):s)) >>= unit)(tpmStartup)
    =
    (outNat(0),tpmStartup)

  % reset followed by two copies
  test4: THEOREM
    runState(
       modify(outNat(0),(LAMBDA (s:tpmAbsState):s)) >>=
       (LAMBDA (x:tpmAbsOutput):
         modify(outNat(1),(LAMBDA (s:tpmAbsState):s)) >>= unit))(tpmStartup)
     =
    (outNat(1),tpmStartup)

  % Take the output of the previous command execution and attempt to install
  % it as akey.  Note the use of useOutputState to create a function for bind
  % rather than sequence.  The big difference is that the output from the
  % previous command executing is bound to a and can be used in the
  % morphism.  Note also that outKey? and wrapKey? that would usually be
  % used as predicate subtypes cannot be as we'll never guarantee the
  % output argument will be a key or a wrapped key.  This does not complicate
  % the proof, so it's not a big deal.
  TPM_InstallPrev:[tpmAbsOutput->State] =
    useOutputState(outNothing,
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    IF outKey?(a) AND wrapKey?(k(a))
		    THEN executeCom(s,ABS_LoadKey2(k(a)))
		    ELSE executeCom(s,noopCom)
		    ENDIF)));
                 
  
  % Generate a key and immediately install it.  Note the use of bind rather
  % sequence to capture the TPM_CreateWrapKey output and use it as input to
  % the TPM_InstallPrev command.  Specifically, the output of
  % TPM_CreateWrapKey is bound to a in TPM_InstallPrev then used in that
  % command.  Classic use of bind!!
  install_prev_key_success: THEOREM FORALL (k,p:(asymKey?),a:AUTHDATA) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup
		  >> CPU_senter
		  >> CPU_sinit
                  >> TPM_CreateWrapKey(p,k,a)
		  >>= TPM_InstallPrev
		  >>= unit)
		  (tpmUnknown)
      IN member(p,keys(s)) OR p=srk(s)
       => member(k,keys(s));

  %%install nested wrapped keys?
  nested_wrapped_keys_success: THEOREM FORALL (k,j,p:(asymKey?),a1,a2:AUTHDATA) :
     LET (out,s) = runState(
     	 	   TPM_Init
      		   >> TPM_Startup
		   >> CPU_senter
		   >> CPU_sinit
		   >> TPM_TakeOwnership
		   >> TPM_CreateWrapKey(p,k,a1)
		   >>= TPM_InstallPrev
		   >> TPM_CreateWrapKey(k,j,a2)
		   >>= TPM_InstallPrev
		   >>= unit)
		   (tpmUnknown) IN
	member(p,keys(s)) OR p=srk(s)
	=>
	%% Does member(j,keys(s)) automatically imply member(k,keys(s))?
	%% member(j,keys(s)) pops out with grind, but I can't get the k part to pop out.
	member(j,keys(s)) AND member(k,keys(s));
	
  % Take the output of the previous command execution and attempt to unseal
  % it.  Note the use of useOutputState to create a function for bind
  % rather than sequence.
  TPM_UnsealPrev(k:(asymKey?)):[tpmAbsOutput->State] =
    useOutputState(outNothing,
		(LAMBDA (a:tpmAbsOutput):
		  (LAMBDA (s:tpmAbsState):
		    IF outBlob?(a) AND seal?(bl(a))
		    THEN executeCom(s, ABS_Unseal(bl(a),k))
		    ELSE executeCom(s,noopCom)
		    ENDIF)));

  %% Create a seal and immediately unseal it.
  unseal_prev_seal_success: THEOREM FORALL (k,j:(asymKey?),data:BLOB,pcrs:PCRS) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup
		  >> CPU_senter
		  >> CPU_sinit
                  >> TPM_Seal(k,data)
		  >>= TPM_UnsealPrev(j)
		  >>= unit)
		  (tpmUnknown) IN  
	(j=private(k) AND pcrs=pcrs(s))
          => blob(bl(out)) = data
	 %ELSE out = outBlob(nothing)

  %% Seal and unseal a secret successfully 
  seal_unseal_secret_success: THEOREM FORALL (j,k:(asymKey?),hv:HV,b:BLOB,pcrs:PCRS) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_Extend(hv,0)
		  >> TPM_Seal(k,b)
		  >>= TPM_UnsealPrev(j)
		  >>= unit)
		  (tpmUnknown) IN
      (j=private(k) AND pcrs=pcrs(s))
	=> blob(bl(out))=b
     % ELSE out=outBlob(nothing)

  %% TPMs will not lie about who they are.  If the AIK cannot be installed
  %% then no quote will be generated
  %% proved - Wed Jul 11 11:28:46 EDT 2012
  aik_binding : THEOREM FORALL (aik:(wrapKey?),b:BLOB,pm:PCRMASK) :
    LET (out,s) = runState(
                  TPM_Init
      		  >> TPM_Startup
		  >> CPU_senter
		  >> CPU_sinit
		  >> TPM_Quote(aik,b,pm)
		  >>= unit)
		  (tpmUnknown) IN
       NOT checkKeyRoot(aik,srk(s)) => out=outNothing;    

  %% Assure the CA generates an appropriate cert from the AIK and Ek
  %% proved - Wed Jul 11 13:14:11 EDT 2012
  gen_cert : THEOREM FORALL (aik:(wrapKey?),ek:(asymKey?),k:(symKey?)) :
    LET (out,s) = runState(
                  CA_certify(certReq(aik,ek,k))
		  >>= unit)
		  (tpmStartup) IN
      out = outBlob(identActivation(cert(private(asymKey(caKeyVal)),key(aik)),
                                    k,
				    ek))

  %% Assure that activate idenity installs its AIK and returns K if AIK can
  %% be installed.
  %% proved - Thu Jul 12 10:26:02 EDT 2012
  activate_identity : THEOREM FORALL (aik:(wrapKey?),k:(symKey?)) :
    LET (out,s) = runState(
                  TPM_ActivateIdentity(aik,k)
		  >>= unit)
		  (tpmStartup) IN
      out = IF checkKeyRoot(aik,srk(s))
            THEN outKey(key(symKey?))
	    ELSE outNothing
	    ENDIF
      AND checkKeyRoot(aik,srk(s)) => member(aik,keys(s));
      

  %% Generate a quote from an AIK generated by the previous command
  TPM_QuotePrev(n:BLOB,pm:PCRMASK):[tpmAbsOutput->State] =
    useOutputOutput(outNothing,
		(LAMBDA (a:tpmAbsOutput):
		  (LAMBDA (s:tpmAbsState):
		    IF outBlob?(a) AND identity?(bl(a))
		    THEN outputCom(s,ABS_Quote(aik(bl(a)),n,pm))
		    ELSE outputCom(s,noopCom)
		    ENDIF)));

  %% Generate an AIK and use it for a quote.
  %% proved - Wed Jul 11 13:47:33 EDT 2012
  quote_with_prev_key:
    THEOREM FORALL (k:(asymKey?),s:tpmAbsState,n:BLOB,pm:PCRMASK,sessk:(symKey?),a:AUTHDATA) :
     LET (out,s) = runState(
                   TPM_Init
		   >> TPM_Startup
		   >> CPU_senter
		   >> CPU_sinit
		   >> TPM_MakeIdentity(k,sessk,a)
		   >>= TPM_QuotePrev(n,pm))
		   (tpmUnknown) IN
        out = outQuote(private(k),
	               n,
                       map((pcrsReset WITH [(0) := extend(extend(reset, hash(sinit)),hash(mle))]),pm));

  %% Certify the previous key.  Use with bind after an AIK is generated.
  %% After this execution, the result of certification is sitting on
  %% the output.  Note that ekVal is used directly because  it is the public
  %% half of the TPM EK
  CA_CertPrev(n:BLOB,pm:PCRMASK,sessk:(symKey?)):[tpmAbsOutput->State] =
     useOutputOutput(outNothing,
 		(LAMBDA (a:tpmAbsOutput):
 		  (LAMBDA (s:tpmAbsState):
 		    IF outBlob?(a) AND identity?(bl(a))
 		    THEN outputCom(s,ABS_certify(c(bl(a))))
 		    ELSE outputCom(s,noopCom)
 		    ENDIF)));

  %% Generate a new key, certify it, generate a quote, and send it along.
  %% Somehow need to get two bound outputs.  This is nowhere close to working
  %% Use the pair to grab blobs from the output and output them again with 
  %% new results.  At the end of the command sequence, you should have the
  %% pair that gets sent to the appraiser with the AIK cert and the TPM quote.
   cert_and_quote_with_prev_key:
     THEOREM FORALL (aik:(asymKey?),s:tpmAbsState,n:BLOB,pm:PCRMASK,k:(symKey?),a:AUTHDATA) :
      LET (out,s) = runState(
                    TPM_Init
 		   >> TPM_Startup
 		   >> CPU_senter
 		   >> CPU_sinit
 		   >> TPM_MakeIdentity(aik,k,a)
 		   >>= CA_CertPrev(n,pm,k)
%		   >>= TPM_QuotePrev(n,pm)
		   )
 		   (tpmUnknown) IN
         out = outNothing;


END tpm
