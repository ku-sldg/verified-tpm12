%%
%% ----
%% TPM Theory
%%
%% Author: Perry Alexander, Brigid Halling
%% Date: Mon Nov 28 01:09:39 CST 2011
%%
%% Description: Basic model of a TPM using a monadic state model
%% 
%% Dependencies:
%%  StateMonad.pvs
%%  ReturnCodes.pvs
%%  memory.pvs 
%%  StclearFlags.pvs
%%  startupData.pvs
%%  PermanentData.pvs
%%  StanyData.pvs
%%  StanyFlags.pvs
%%  key.pvs
%%  data.pvs
%%  keyData.pvs
%%  pcr.pvs	
%%  authdata.pvs
%%  PermanentFlags.pvs
%%
%% Todo: (key - => pending, + => done)
%% ----

%% Standard Error IDs
%%  0 = "Bad identity record"
%%  1 = "Bad input key"
%%  2 = "bad session key"
%%  4 = "bad quote parts"
%%  5 = "Clear Disabled"

tpm[HV:TYPE+] : THEORY

  BEGIN

%   ASSUMING
%   % Assume that different blobs always have different hashes
%     unique_hash: ASSUMPTION
%       FORALL (b0,b1:B) : hash(b0)=hash(b1) iff b0=b1;
%   ENDASSUMING

  K : TYPE = nat;

  IMPORTING ReturnCodes;
  IMPORTING startupData[K,HV];

  %% random number
%  RAND : (RNG?);

  OAEPdecode(d:tpmData) : tpmData =%(tpmMigrateAsymkey?) = 
    IF d/=badData AND OAEP?(d)
    THEN m(d)
    ELSE badData
    ENDIF

  %% State monad output type
  tpmAbsOutput : DATATYPE
  BEGIN
    OUT_Nothing : OUT_Nothing?
    OUT_Error(m:ReturnCode) : OUT_Error?
    OUT_CPUError(m:cpuReturn) : OUT_CPUError?
    OUT_Data_Bind(boundData:(encrypted?),m:cpuReturn) : OUT_Data_Bind?
    OUT_Certify(k:(tpmKey?),dat:(encrypted?),m:cpuReturn) : OUT_Certify?
    	% added k here for proofs... helps when sequencing.
	% potentially look for better way to do this.
    OUT_FullQuote(quote:(tpmQuote?),idBind:(signed?),m:cpuReturn) 
    	: OUT_FullQuote?
  %% Admin Startup and State (3)
    OUT_Init(m:ReturnCode) : OUT_Init?
    OUT_Startup(m:ReturnCode) : OUT_Startup?
    OUT_SaveState(m:ReturnCode) : OUT_SaveState?
  %% Admin Testing (4)
%     OUT_SelfTestFull
%     OUT_ContinueSelfTest
%     OUT_GetTestResult
  %% Admin Opt-in (5)
    OUT_SetOwnerInstall(m:ReturnCode) : OUT_SetOwnerInstall?
    OUT_OwnerSetDisable(o1:authOut,m:ReturnCode) : OUT_OwnerSetDisable?
    OUT_PhysicalEnable(m:ReturnCode) : OUT_PhysicalEnable?
    OUT_PhysicalDisable(m:ReturnCode) : OUT_PhysicalDisable?
    OUT_PhysicalSetDeactivated(m:ReturnCode) : OUT_PhysicalSetDeactivated?
    OUT_SetTempDeactivated(a:authOut,m:ReturnCode) : OUT_SetTempDeactivated?
    OUT_SetOperatorAuth(m:ReturnCode) : OUT_SetOperatorAuth?
  %% Admin Ownership (6)
    OUT_TakeOwnership(srk:(tpmKey?),a:authOut,m:ReturnCode) : OUT_TakeOwnership?
    OUT_OwnerClear(a:authOut,m:ReturnCode) : OUT_OwnerClear? 
    OUT_ForceClear(m:ReturnCode) : OUT_ForceClear? 
    OUT_DisableOwnerClear(a:authOut,m:ReturnCode) : OUT_DisableOwnerClear? 
    OUT_DisableForceClear(m:ReturnCode) : OUT_DisableForceClear? 
    OUT_PhysicalPresence(m:ReturnCode) : OUT_PhysicalPresence?
    OUT_ResetEstablishmentBit(m:ReturnCode) : OUT_ResetEstablishmentBit?
  %% Capability Commands (7)
%     OUT_GetCapability
%     OUT_SetCapability
%     OUT_GetCapabilityOwner
  %% Auditing (8)
%     OUT_GetAuditDigest
%     OUT_GetAuditDigestSigned
%     OUT_SetOrdinalAuditStatus
  %% Administrative Functions - Management (9)
%     OUT_FieldUpgrade
%     OUT_SetRedirection
%     OUT_ResetLockValue
  %% Storage Functions (10)
    OUT_Seal(sealedData:(tpmStoredData?),a:authOut,m:ReturnCode) : OUT_Seal?
    OUT_Unseal(secret:tpmData,a,da:authOut,m:ReturnCode) : OUT_Unseal?
    OUT_UnBind(boundData:tpmData,a:authOut,m:ReturnCode) : OUT_UnBind?
    OUT_CreateWrapKey(wrappedKey:(tpmKey?),a:authOut,m:ReturnCode) : 
    	OUT_CreateWrapKey?
    OUT_LoadKey2(inkeyHandle:(tpmKey?),a:authOut,m:ReturnCode) : OUT_LoadKey2?
    OUT_GetPubKey(pubKey:(tpmPubkey?),a:authOut,m:ReturnCode) : OUT_GetPubKey?
%    OUT_Sealx(sealedData:(tpmStoredData?),a:authOut,m:ReturnCode) : OUT_Sealx?
  %% Migration (11)
    OUT_CreateMigrationBlob(random:(RNG?),blobData:(encrypted?),a1,a2:authOut,
	m:ReturnCode) : OUT_CreateMigrationBlob?
    OUT_ConvertMigrationBlob(convertData:tpmData,a:authOut,
	m:ReturnCode) : OUT_ConvertMigrationBlob? %(encrypted?)
    OUT_AuthorizeMigrationKey(autData:(tpmMigKeyAuth?),a:authOut,m:ReturnCode):
    	OUT_AuthorizeMigrationKey?
    OUT_MigrateKey(migData:(encrypted?),a:authOut,m:ReturnCode) :OUT_MigrateKey?
    OUT_CMK_SetRestrictions(a:authOut,m:ReturnCode) : OUT_CMK_SetRestrictions?
    OUT_CMK_ApproveMA(approveData:(tpmDigest?),a:authOut,m:ReturnCode) : 
        OUT_CMK_ApproveMA?
    OUT_CMK_CreateKey(wk:(tpmKey?),a:authOut,m:ReturnCode) : OUT_CMK_CreateKey?
    OUT_CMK_CreateTicket(sigTic:(tpmDigest?),a:authOut,m:ReturnCode) : 
        OUT_CMK_CreateTicket?
    OUT_CMK_CreateBlob(random:(RNG?),data:tpmData,a:authOut,m:ReturnCode) :
        OUT_CMK_CreateBlob?
    OUT_CMK_ConvertMigration(data:tpmData,a:authOut,m:ReturnCode) : 
        OUT_CMK_ConvertMigration?
  %% Maintenance Functions (optional) (12)
%     OUT_CreateMaintenanceArchive
%     OUT_LoadMaintenanceArchive
%     OUT_KillMaintenanceFeature
%     OUT_LoadManuMaintPub
%     OUT_ReadManuMaintPub
  %% Cryptographic Functions (13)
    OUT_SHA1Start(m:ReturnCode) : OUT_SHA1Start?
    OUT_SHA1Update(m:ReturnCode) : OUT_SHA1Update?
    OUT_SHA1Complete(hv:(tpmDigest?),m:ReturnCode) : OUT_SHA1Complete?
    OUT_SHA1CompleteExtend(hv:(tpmDigest?),d:(tpmDigest?),m:ReturnCode) : 
      	OUT_SHA1CompleteExtend?				  
    OUT_Sign(sig:tpmData,m:ReturnCode) : OUT_Sign?
    OUT_GetRandom(br:(RNG?),m:ReturnCode) : OUT_GetRandom?
    OUT_StirRandom(m:ReturnCode) : OUT_StirRandom?
    OUT_CertifyKey(c:(tpmCertifyInfo?),od:(signed?),o1,o2:authOut,m:ReturnCode):
    	OUT_CertifyKey?
  %% Endorsement Key Handling (14)
    OUT_CreateEndorsementKeyPair(pubEk:(tpmKey?),checksum:(tpmDigest?),
	m:ReturnCode) : OUT_CreateEndorsementKeyPair?
    OUT_CreateRevocableEK(pubEK:(tpmPubkey?),checksum:(tpmDigest?),
	outputEKreset:(tpmNonce?),m:ReturnCode) : OUT_CreateRevocableEK?
    OUT_RevokeTrust(m:ReturnCode) : OUT_RevokeTrust?
    OUT_ReadPubek(pubEk:(tpmKey?),checksum:(tpmDigest?),m:ReturnCode) : 
    	OUT_ReadPubek?
    OUT_OwnerReadInternalPub(k:(tpmPubkey?),a:authOut,m:ReturnCode) : 
    	OUT_OwnerReadInternalPub?
  %% Identity Creation and Activation (15)
    OUT_MakeIdentity(idKey:(tpmKey?),idBinding:(signed?),a1,a2:authOut,
	m:ReturnCode) : OUT_MakeIdentity?
    OUT_ActivateIdentity(symmKey:(tpmSessKey?),a1,a2:authOut,m:ReturnCode) : 
   	OUT_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
    OUT_Extend(outDigest:(tpmDigest?),m:ReturnCode) : OUT_Extend?
    OUT_PCRRead(outDigest:(tpmDigest?),m:ReturnCode) : OUT_PCRRead?
    OUT_Quote(pcrData:(tpmPCRComposite?),sigD:(signed?),a:authOut,m:ReturnCode):
    	OUT_Quote?
    OUT_PCR_Reset(m:ReturnCode) : OUT_PCR_Reset?
%    OUT_Quote2() : OUT_Quote2
  %% Changing AuthData (17)
    OUT_ChangeAuth(data:(encrypted?),o1,o2:authOut,m:ReturnCode):OUT_ChangeAuth?
    OUT_ChangeAuthOwner(o1:authOut,m:ReturnCode) : OUT_ChangeAuthOwner?
  %% Authorizaton Sessions (18)
%     OUT_OIAP(auth:(tpmAuthData?),even:(tpmNonce?),m:ReturnCode) : OUT_OIAP?
%     OUT_OSAP(auth:(tpmAuthData?),e,eOSAP:(tpmNonce?),m:ReturnCode) : OUT_OSAP?
%     OUT_DSAP
%     OUT_SetOwnerPointer(m:ReturnCode) : OUT_SetOwnerPointer?
  %% Delegation Commands (19)
%     OUT_Delegate_Manage(rD:tpmData,a:authOut,m:ReturnCode):OUT_Delegate_Manage?
%     OUT_Delegate_CreateKeyDelegation(b:(tpmDelegatekeyBlob?),a:authOut,
% 	m:ReturnCode) : OUT_Delegate_CreateKeyDelegation?
%     OUT_Delegate_CreateOwnerDelegation(b:(tpmDelegateOwnerBlob?),a:authOut,
% 	m:ReturnCode) : OUT_Delegate_CreateOwnerDelegation?
%     OUT_Delegate_LoadOwnerDelegation(a:authOut,m:ReturnCode) : 
%     	OUT_Delegate_LoadOwnerDelegation?
%     OUT_Delegate_ReadTable(fT:(tpmFamilyTableEntry?),dT:(tpmDelegateIndex?),
% 	m:ReturnCode) : OUT_Delegate_ReadTable?
%     OUT_Delegate_UpdateVerification(oD:(tpmDelegateKeyBlob?),a:authOut,
% 	m:ReturnCode) : OUT_Delegate_UpdateVerification?
%     OUT_Delegate_VerifyDelegation(m:ReturnCode) : OUT_Delegate_VerifyDelegation?
  %% Non-volatile Storage (20)
%     OUT_NV_DefineSpace(a:authOut,m:ReturnCode) : OUT_NV_DefineSpace?
%     OUT_NV_WriteValue(a:authOut,m:ReturnCode) : OUT_NV_WriteValue?
%     OUT_NV_WriteValueAuth(a:authOut,m:ReturnCode) : OUT_NV_WriteValueAuth?
%     OUT_NV_ReadValue(d:tpmData,a:authOut,m:ReturnCode) : OUT_NV_ReadValue?
%     OUT_NV_ReadValueAuth(d:tpmData,a:authOut,m:ReturnCode):OUT_NV_ReadValueAuth?
  %% Session Management (21)
%     OUT_KeyControlOwner(a:authOut,m:ReturnCode) : OUT_KeyControlOwner?
%     OUT_SaveContext(cb:(tpmContextBlob?),m:ReturnCode) : OUT_SaveContext?
%     OUT_LoadContext(h:(tpmHandle?),m:ReturnCode) : OUT_LoadContext?
  %% Eviction (22)
    OUT_FlushSpecific(m:ReturnCode) : OUT_FlushSpecific?
  %% Timing Ticks (23)
%     OUT_GetTicks(cT:(tpmCurrentTicks?),m:ReturnCode) : OUT_GetTicks?
%     OUT_TickStampBlob(ct:(tpmCurrentTicks?),sig:(signed?),a:authOut,
% 	m:ReturnCode) : OUT_TickStampBlob?
  %% Transport Sessions (24)
%     OUT_EstablishTransport(tH:(tpmTransHandle?),l:(tpmModifierIndicator?),
% 	cT:(tpmCurrentTicks?),a:authOut,m:ReturnCode) : OUT_EstablishTransport?
%     OUT_ExecuteTransport(ct:int,l:(tpmModifierIndicator?),wR:tpmData,
% 	a:authOut,m:ReturnCode) : OUT_ExecuteTransport?
%     OUT_ReleaseTransportSigned(l:(tpmModifierIndicator?),cT:(tpmCurrentTicks?),
% 	sig:(signed?),a1,a2:authOut,m:ReturnCode) : OUT_ReleaseTransportSigned?
  %% Monotonic Counter (25)
%     OUT_CreateCounter(cid:(tpmCountId?),cv:(tpmCounterValue?),a:authOut,
% 	m:ReturnCode) : OUT_CreateCounter?
%     OUT_IncrementCounter(c:(tpmCounterValue?),a:authOut,m:ReturnCode) : 
%       	OUT_IncrementCounter?
%     OUT_ReadCounter(c:(tpmCounterValue?),m:ReturnCode) : OUT_ReadCounter?
%     OUT_ReleaseCounter(a:authOut,m:ReturnCode) : OUT_ReleaseCounter?
%     OUT_ReleaseCounterOwner(a:authOut,m:ReturnCode) : OUT_ReleaseCounterOwner?
  %% DAA Commands (26)
    OUT_DAA_Join(outputData:tpmData,a:authOut,m:ReturnCode) : OUT_DAA_Join?
    OUT_DAA_Sign(outputData:tpmData,a:authOut,m:ReturnCode) : OUT_DAA_Sign?
  %% Depreciated Commands (27)
  %% Deleted Commands (28)
  END tpmAbsOutput;

  % grind, decompose-equality
  unique_error: LEMMA 
    FORALL (b0,b1:ReturnCode) : OUT_Error(b0)=OUT_Error(b1) iff b0=b1;

  % assumption 
  sigQuote: LEMMA 
    FORALL (out:(OUT_Quote?)) :  
        tpmQuote?(signData(sigD(out)));


  IMPORTING memory[tpmAbsOutput,OUT_Nothing];
  

  %% State monad input type.  All inputs are in the form of a command with
  %% parameters.
  tpmAbsInput : DATATYPE
  BEGIN
  %% Admin Startup and State commands (3)
    ABS_Reset : ABS_Reset? %unimplemented
    ABS_Init : ABS_Init? 
    ABS_Startup(startupType : TPM_STARTUP_TYPE) : ABS_Startup?
    ABS_SaveState : ABS_SaveState?
  %% Admin Opt-in (5)
    ABS_SetOwnerInstall(state:bool) : ABS_SetOwnerInstall?
    ABS_OwnerSetDisable(disableState:bool,i:authIn) : ABS_OwnerSetDisable?
    ABS_PhysicalEnable : ABS_PhysicalEnable?
    ABS_PhysicalDisable : ABS_PhysicalDisable?
    ABS_PhysicalSetDeactivated(state:bool) : ABS_PhysicalSetDeactivated?
    ABS_SetTempDeactivated(i:authIn) : ABS_SetTempDeactivated?
    ABS_SetOperatorAuth(opAuth:(tpmSecret?)) : ABS_SetOperatorAuth?
  %% Admin Ownership Commands (6)
    ABS_TakeOwnership(oA,sA:(encrypted?),srk:(tpmKey?),a:authIn) : 
    	ABS_TakeOwnership?
    ABS_OwnerClear(a:authIn) : ABS_OwnerClear? 
    ABS_ForceClear : ABS_ForceClear? 
    ABS_DisableOwnerClear(a:authIn) : ABS_DisableOwnerClear? 
    ABS_DisableForceClear : ABS_DisableForceClear? 
    ABS_PhysicalPresence(p:PHYSPRES) : ABS_PhysicalPresence?
    ABS_ResetEstablishmentBit : ABS_ResetEstablishmentBit?
  %% Protected Storage Commands (10)
    ABS_Seal(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : ABS_Seal?	%encAuth:(tpmAuthData?)
    ABS_Unseal(parent:(tpmKey?),inData:(tpmStoredData?),a,da:authIn) : 
    	ABS_Unseal?   
    ABS_UnBind(key:(tpmKey?),inData:(encrypted?),a:authIn) : ABS_UnBind?
    ABS_CreateWrapKey(parentH,keyInfo:(tpmKey?),dUA,dMA:(tpmEncAuth?),a:authIn):
	ABS_CreateWrapKey?
    ABS_LoadKey2(parent,inKey:(tpmKey?),a:authIn): ABS_LoadKey2? 
    ABS_GetPubKey(key:(tpmKey?),a:authIn): ABS_GetPubKey? 
    ABS_Sealx(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : ABS_Sealx?
  %% Migration Commands (11)
    ABS_CreateMigrationBlob(p:(tpmKey?),m:(tpmMigScheme?),mKA:(tpmMigKeyAuth?),
	encData:(encrypted?),a1,a2:authIn) : ABS_CreateMigrationBlob?
    ABS_ConvertMigrationBlob(parent:(tpmKey?),inData:(encrypted?),
	random:(RNG?),a:authIn) : ABS_ConvertMigrationBlob?
    ABS_AuthorizeMigrationKey(migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : ABS_AuthorizeMigrationKey?
    ABS_MigrateKey(ma,pub:(tpmKey?),inData:(encrypted?),a:authIn) : 
        ABS_MigrateKey?
    ABS_CMK_SetRestrictions(restr:(tpmCMKDelegate?),i:authIn) : 
        ABS_CMK_SetRestrictions?
    ABS_CMK_ApproveMA(migAuth:(tpmDigest?),i:authIn) : ABS_CMK_ApproveMA?
    ABS_CMK_CreateKey(p:(tpmKey?),dataUsageAuth:(tpmEncAuth?),k:(tpmKey?),
        migAuthApp:(tpmDigest?),migAuthDig:(tpmDigest?),i:authIn) : 
        ABS_CMK_CreateKey?
    ABS_CMK_CreateTicket(verifKey:(tpmPubkey?),signedData:(tpmDigest?),
        sigVal:tpmData,i:authIn) : ABS_CMK_CreateTicket?
    ABS_CMK_CreateBlob(p:(tpmKey?),t:(tpmMigScheme?),mkAuth:(tpmMigKeyAuth?),
        psk:(tpmDigest?),msaList:(tpmMSAComposite?),restrTicket:(tpmCMKAuth?),
        sigTicket:(tpmDigest?),encData:(encrypted?),i:authIn) : 
	ABS_CMK_CreateBlob?
    ABS_CMK_ConvertMigration(p:(tpmKey?),restrTick:(tpmCMKAuth?),
        sigTick:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),
	rand:(RNG?),i:authIn) : ABS_CMK_ConvertMigration?
  %% Cryptographic Commands (13)
    ABS_SHA1Start : ABS_SHA1Start?
    ABS_SHA1Update(hd:tpmData) : ABS_SHA1Update?
    ABS_SHA1Complete(hd:tpmData) : ABS_SHA1Complete?
    ABS_SHA1CompleteExtend(p:PCRINDEX,hd:tpmData) : ABS_SHA1CompleteExtend?
    ABS_Sign(keyHandle:(tpmKey?),areaToSign:tpmData) : ABS_Sign?
    ABS_GetRandom : ABS_GetRandom?
    ABS_StirRandom(i:nat) : ABS_StirRandom?
    ABS_CertifyKey(c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) : ABS_CertifyKey?
  %% Endorsement Key Handling (14)
    ABS_CreateEndorsementKeyPair(antiReplay:(tpmNonce?),keyInfo:(tpmKey?)) : 
    	ABS_CreateEndorsementKeyPair?
    ABS_CreateRevocableEK(antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	genReset:bool,inputEKreset:(tpmNonce?)) : ABS_CreateRevocableEK?
    ABS_RevokeTrust(EKReset:(tpmNonce?)) : ABS_RevokeTrust?
    ABS_ReadPubek(n:(tpmNonce?)) : ABS_ReadPubek?
    ABS_OwnerReadInternalPub(k:(tpmKey?),a:authIn) : ABS_OwnerReadInternalPub?
  %% Identity Creation and Activation (15)
    ABS_MakeIdentity(idAuth:(tpmEncAuth?),CADigest:(tpmDigest?),idKey:(tpmKey?),
	a1,a2:authIn) : ABS_MakeIdentity?
    ABS_ActivateIdentity(aik:(tpmKey?),b:(encrypted?),a1,a2:authIn):
    	ABS_ActivateIdentity?
  %% Integrity Collection and Reporting (16)
    ABS_Extend(pcrNum:PCRINDEX,d:HV) : ABS_Extend?
    ABS_PCRRead(ind:PCRINDEX) : ABS_PCRRead?
    ABS_Quote(aik:(tpmKey?),nonce:(tpmNonce?),pm:PCR_SELECTION,i:authIn) : 
    	ABS_Quote?
    ABS_PCR_Reset(pcrSelect:PCR_SELECTION) : ABS_PCR_Reset?
  %% Changing AuthData (17)
    ABS_ChangeAuth(p:(tpmKey?),newA:(tpmEncAuth?),d:(encrypted?),i1,i2:authIn) :
    	ABS_ChangeAuth?
    ABS_ChangeAuthOwner(newA:(tpmEncAuth?),i:authIn) : ABS_ChangeAuthOwner?
  %% Authorizaton Sessions (18)
    ABS_OIAP : ABS_OIAP?
    ABS_OSAP(oOSAP:(tpmNonce?)) : ABS_OSAP?
  %% Eviction (22)
    ABS_FlushSpecific(h:tpmData) : ABS_FlushSpecific?
  %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    ABS_save(i:nat,v:tpmAbsOutput) : ABS_save?
    ABS_read(i:nat) : ABS_read?
    ABS_Data_Bind(k:(tpmKey?),d:tpmData) : ABS_Data_Bind?
    ABS_buildQuoteFromMem(q,i:nat) : ABS_buildQuoteFromMem?
  %% CA Commands
    ABS_certify(aik:(tpmKey?),certReq:(signed?)) : ABS_certify?
  %% Invented, imaginary Commands
    noopCom : noopCom?
  END tpmAbsInput;

  %% sinit blob instance for measurement
  %sinit : B;
  sinitHash : HV;

  %% mle blob instance for measurement
  %mle : B;
  mleHash : HV;


  %% Initial key values not generated by TPM
  ekKeyVal : K = 1;
  srkKeyVal : K = 2;
  caKeyVal : K = 3;

  %% Initial key count value for initializing TPM
  initKeyVal : K = 100;
  initSessKeyVal : K = 50;

  %% Key definitions that make ek and srk values asymmetric keys.
  %% TODO: I mostly just made this stuff up... needs to be checked and changed
  ekVal:(tpmKey?) = tpmKey(ekKeyVal,
			   storage,				% 5.8.1
			   keyFlagsF,
			   always,
			   keyParmsDef,
			   %encr_alg is MGF1			% 5.8.1
			   pcrInfoLongDefault,
			   storeAsymkeyDefault(ekKeyVal,ekKeyVal));
  srkVal:(tpmKey?) = tpmKey(srkKeyVal,storage,keyFlagsF,	
			    always,keyParmsDef,
			    pcrInfoLongDefault,
			    storeAsymkeyDefault(srkKeyVal,ekKeyVal));
  caVal:(tpmKey?) = tpmKey(caKeyVal,storage,keyFlagsF,
			   always,keyParmsDef,
			   pcrInfoLongDefault,
			   storeAsymkeyDefault(caKeyVal,ekKeyVal)); 
			   % Certificate Authority key

  %% Abstract TPM State with keys, PCR array and locality
  tpmAbsState : TYPE = [# restore : restoreStateData
                        , memory : mem
                        , srk : (tpmKey?)	%TODO: where should this be?
                        , ek : (tpmKey?)	%TODO: where should this be?
                        , keyGenCnt : K
                        , keys : KEYSET
                        , pcrs : PCRVALUES	% stClearData`PCR?
                        , locality : LOCALITY
                        , permFlags : PermFlags
                        , permData : PermData
                        , stanyFlags : StanyFlags
                        , stanyData : StanyData
                        , stclearFlags : StclearFlags
                        , stclearData : StclearData
                        , outData : list[tpmData] %%TURN INTO LIST
		        , randCnt : K
                        #];

  %% Well formedness condition for abstract states.  Currently unused, but we
  %% should show that forall commands, well formed input generates well formed
  %% output.

  wellFormed?(s:tpmAbsState):bool = wellFormedRestore?(restore(s));

  IMPORTING StateMonad[tpmAbsOutput,tpmAbsState];

  %% Define some common TPM states and state operations
  
  %% Unknown state
  tpmUnknown : tpmAbsState

  tpmDefault : (wellFormed?) = (#
                         pcrs:=pcrsPower
                         , locality:=4
			 , keys:=(#vals:=emptyset,keys:=emptyset#)
			 , srk:=invalidKey
			 , ek:=TPM_KH_EK
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=initSaveData
			 , permFlags:=permFlagsDefault
			 , permData:=permDataDefault
			 , stanyFlags:=stanyFlagsDefault
			 , stanyData:=stanyDataDefault
			 , stclearFlags:=stclearFlagsDefault % TODO: check
			 , stclearData :=stclearDataDefault  % TODO: check
			 , outData := null
			 , randCnt := 0
			 #);

  removeKeysStartup(ks:KEYSET) : KEYSET = addKey(TPM_KH_EK,ks) %%TODO!!
  %TODO!!
%     LAMBDA (k:privKVAL) :
%       IF parentPCRStatus OR isVolatile
%       THEN flushSpecificOut(keyHandle)
%       ELSE noop %TODO
%       ENDIF

  %% Power on state after init is raised by hardware.
  tpmPostInit : (wellFormed?) = tpmDefault WITH 
  	      		      	  [`stanyFlags(postInitialize):=TRUE]

  %% Standard initial state following startup command with the TPM_ST_CLEAR
  %% option set.  Note that this should be checked against the spec before
  %% asserting goodness. 
  tpmStartup(s:tpmAbsState) : (wellFormed?) = 				% 2
    tpmDefault WITH [%TODO
    	       	     %Sess RT_CONTEXT,RT_AUTH,RT_DAA,RT_TRANS invalid 	% 2a
    	       	     %stclearData`PCR default 			  	% 2b
		     `stclearFlags(physicalPresence):=
			physicalPresenceDef				% 2ci
		    ,`stclearFlags(physicalPresenceLock):=
			physicalPresenceLockDef				% 2cii
		    ,`stclearFlags(disableForceClear):=
			disableForceClearDef				% 2ciii
		    % TODO? auditDigest					% 2d
		    ,`stclearFlags(deactivated):=s`permFlags`deactivated% 2e
		    ,`stanyData(contextNonceSession):=tpmNonceZero	% 2fi
		    ,`stanyData(contextCount):=0			% 2fii
		    ,`stanyData(contextList):=0				% 2fiii
		    ,`stclearData(contextNonceKey):=tpmNonceZero	% 2gi
		    %,`stclearData(countId):=0				% 2gii
		    ,`stclearData(ownerReference):=key(TPM_KH_OWNER)	% 2giii
		    ,`stclearFlags(bGlobalLock):=FALSE			% 2hi
		    ,`keys:=removeKeysStartup(s`keys)			% 2i
		    ,`restore:=tpmRestoreUnknown %TODO			% 5
		    ,`stanyFlags(postInitialize):=FALSE]		% 6
  	       		  

  %% Generate a new state from restore data.  Basically this is a clear
  %% restart with pcrs, keys, and pcr flags coming from the restore
  %% data.  Note that this function assumes valid data and will behave
  %% badly otherwise
  tpmRestore(rd:(wellFormedRestore?)) : (wellFormed?) = (#
                         pcrs:=pcrs(rd)
			 , locality:=4
			 , keys:=keys(rd)
			 , srk:=srkVal
			 , ek:=ekVal
		         , keyGenCnt:=initKeyVal
			 , memory:=empty
			 , restore:=rd
			 , permFlags:=permFlags(rd)
			 , permData:=permData(rd)
			 , stanyFlags:=stanyFlags(rd)
			 , stanyData:=stanyData(rd)
			 , stclearFlags:=stclearFlagsDefault
			 , stclearData :=stclearDataDefault
			 , outData := null
			 , randCnt := 0
                         #)

 
  %% Predicate to determine if startup has occured.  Used as types
  %% (afterInit?) is the set of states occuring immediately after TPM_Init
  %% (afterStartup?) is the set of states occuring immediately after
  %% TPM_Startup
  afterInit?(s:tpmAbsState):bool = postInitialize(stanyFlags(s));
  afterStartup?(s:tpmAbsState):bool = NOT postInitialize(stanyFlags(s));

  %% Standard operations on TPM state definition above.  All such
  %% functions end with State to indicate they operate on the state
  %% value rather than on the TPM monad.  Note that key set and pcr
  %% manipulation functions are defined externally in key.pvs and
  %% pcr.pvs respectively

  %% Reset PCRs as performed by SENTER.
  pcrsResetSenterState(s:tpmAbsState) : tpmAbsState =
    s WITH [`pcrs := pcrsSenter(pcrs(s),pcrAttrib(permData(s)))];

  %% Decrease locality value
  changeLocalityState(s:tpmAbsState) : tpmAbsState =
    s WITH [`locality := IF locality(s) > 0
                         THEN locality(s) - 1
			 ELSE 0
			 ENDIF];
    
  %% Generate a new key
  genKeyState(s:tpmAbsState) : tpmAbsState =
    s WITH [`keyGenCnt := keyGenCnt(s)+1];

  gen_key_state : THEOREM FORALL (state:tpmAbsState,i:nat) : 
    LET s=genKeyState(state WITH [`keyGenCnt:=i]) IN
	keyGenCnt(s)=i+1;

  %% Increment randCnt to get next random number
  randState(s:tpmAbsState) : tpmAbsState =
    s WITH [`randCnt := randCnt(s)+1];

  rand_state : THEOREM FORALL (state:tpmAbsState,i:nat) : 
    LET s=randState(state WITH [`randCnt:=i]) IN
	randCnt(s)=i+1;

%  saveStateKeys(s:tpmAbsState) : KEYSET = 
%     IF parentPCRStatus THEN Keep					% 5
%     ELSIF TPM_KEY_CONTROL_OWNER_EVICT THEN Keep			% 6
%     ELSIF %The contents of any key that is currently loaded MAY be preserved
% 	  keep all							% 7

  saveState(s:tpmAbsState) : tpmAbsState =
    % TODO PCRs								% 1
    % TODO auditDigest							% 2
    % TODO sessions							% 8
    s WITH [`restore:=saveState(keys(s)					% 5,6,7
                               ,ek(s)
		      	       ,srk(s)
			       ,keyGenCnt(s)
		      	       ,pcrs(s)
		      	       ,permFlags(s)
		      	       ,permData(s)
			       ,stanyFlags(s)
			       ,stanyData(s)
			       ,stclearFlags(s)				% 4
			       ,stclearData(s)				% 3
		      		)];

  setOwnerInstallState(s:tpmAbsState,state:bool) : tpmAbsState = 
    IF not(invalidAuth?(s`permData`ownerAuth)) 				% 1
    THEN s
    ELSIF s`stclearFlags`physicalPresence				% 2
    THEN s WITH [`permFlags`ownership:=state]
    ELSE s
    ENDIF;

  setOwnerInstallOut(s:tpmAbsState,state:bool) : tpmAbsOutput =
    IF not(invalidAuth?(s`permData`ownerAuth)) 				% 1
    THEN OUT_SetOwnerInstall(TPM_SUCCESS)	
    ELSIF s`stclearFlags`physicalPresence				% 2
    THEN OUT_SetOwnerInstall(TPM_SUCCESS)
    ELSE OUT_Error(TPM_INSTALL_DISABLED) %TODO: double check
    ENDIF;

  ownerSetDisableState(s:tpmAbsState,disableState:bool,i:authIn) : tpmAbsState =
    % Authenticate command as coming form TPM Owner. If unsuccessful 
    % THEN OUT_Error(TPM_AUTHFAIL)					% 1
    s WITH [`permFlags`disable:=disableState]				% 2

  ownerSetDisableOut(s:tpmAbsState,disableState:bool,i:authIn) : tpmAbsOutput =
    % Authenticate command as coming form TPM Owner. If unsuccessful 
    % THEN OUT_Error(TPM_AUTHFAIL)					% 1
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
    OUT_OwnerSetDisable(o1,TPM_SUCCESS);
    
  physicalEnableState(s:tpmAbsState) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=FALSE]				% 2
    ENDIF;
    
  physicalEnableOut(s:tpmAbsState) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalEnable(TPM_SUCCESS)
    ENDIF;

  physicalDisableState(s:tpmAbsState) : tpmAbsState = 
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=TRUE]				% 2
    ENDIF;

  physicalDisableOut(s:tpmAbsState) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalDisable(TPM_SUCCESS)
    ENDIF;

  physicalSetDeactivatedState(s:tpmAbsState,state:bool) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permFlags`disable:=state]				% 2
    ENDIF;

  physicalSetDeactivatedOut(s:tpmAbsState,state:bool) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_PhysicalSetDeactivated(TPM_SUCCESS)
    ENDIF;

  setTempDeactivatedState(s:tpmAbsState,i:authIn) : tpmAbsState =
    IF not s`permFlags`operator						% 1a
    THEN s
    ELSIF % Validate command and params using ownerAuth(i) else		% 1b
    	 % OUT_Error(TPM_AUTHFAIL)
    	 not s`stclearFlags`physicalPresence				% 2
    THEN s
    ELSE s WITH [`stclearFlags`deactivated:=TRUE]			% 3
    ENDIF;

  setTempDeactivatedOut(s:tpmAbsState,i:authIn) : tpmAbsOutput =
    IF not s`permFlags`operator						% 1a
    THEN OUT_Error(TPM_NOOPERATOR)
    ELSIF % Validate command and params using ownerAuth(i) else		% 1b
    	 % OUT_Error(TPM_AUTHFAIL)
    	 not s`stclearFlags`physicalPresence				% 2
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
 	OUT_SetTempDeactivated(o1,TPM_SUCCESS)
    ENDIF;

  setOperatorAuthState(s:tpmAbsState,opAuth:(tpmSecret?)) : tpmAbsState =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN s
    ELSE s WITH [`permData`operatorAuth:=opAuth				% 2
    	   	,`permFlags`operator:=TRUE]				% 3
    ENDIF;

  setOperatorAuthOut(s:tpmAbsState,opAuth:(tpmSecret?)) : tpmAbsOutput =
    IF not s`stclearFlags`physicalPresence				% 1
    THEN OUT_Error(TPM_BAD_PRESENCE)
    ELSE OUT_SetOperatorAuth(TPM_SUCCESS)
    ENDIF;


  takeOwnership?(s:tpmAbsState,k:(tpmKey?),oa,sa:(encrypted?)) : bool =
    COND
      i(s`permData`ownerAuth)/=INVALIDAUTH -> FALSE,			% 1
      not s`permFlags`ownership -> FALSE,				% 2
      not goodkey?(key(s`ek)) -> FALSE,					% 3
      %not OIAP?(authHandle) -> FALSE,					% 4
      %not protocolID = TPM_PID_OWNER -> FALSE,				% 5
      %  not length(A1)=20bytes -> FALSE,	     			% 6
      %not command, params using A1, ownerAuth -> FALSE,		% 7
      not storage?(keyUsage(k)) -> FALSE,   				% 8a
      migratable(keyFlags(k)) -> FALSE,					% 8b
      not RSA?(algoId(algoParms(k))) -> FALSE,				% 8c
      not SHA1_MGF1?(encScheme(algoParms(k))) -> FALSE,			% 8d    
      not none?(sigScheme(algoParms(k))) -> FALSE,			% 8e
      %length(parms(algoParms(k)))<2048 -> FALSE,			% 8f
      %expSize(parms(algoParms(k)))/=0 -> FALSE,			% 8g
      s`permFlags`FIPS AND never?(authDataUsage(k))-> FALSE,		% 8h
      ELSE -> TRUE
    ENDCOND;

  takeOwnershipState(s:tpmAbsState,encOwnerA,encSrkA:(encrypted?),
	k:(tpmKey?),a:authIn) : tpmAbsState =
    COND
      NOT takeOwnership?(s,k,encOwnerA,encSrkA) -> s,			% 1-8
      ELSE -> LET A2=decrypt(encSrkA,private(s`ek),s`keys),		% 10
      	      	  A1=decrypt(encOwnerA,private(s`ek),s`keys) IN		% 6
	      LET asymkey=tpmStoreAsymkey(A2,	 			% 10c
			    migrationAuth(encData(encDat(k))),
			    pubDataDigest(encData(encDat(k))),
			    private(k)) IN %TODO
	      LET K1=tpmKey(key(k),keyUsage(k),keyFlags(k),
				authDataUsage(k),algoParms(k),		% 9
		      		PCRInfo(k),encrypt(asymkey,0)) IN %TODO!
	      s WITH [`srk:=K1						% 11
		     ,`permData(ownerAuth):=A1				% 12
		     % TODO: 
		     %,`permData(contextKey)?				% 13
		     %,`permData(delegateKey)?				% 14
		     ,`permData(tpmProof):=tpmSecret(n(RNG(s`randCnt)))	% 15
		     ,`permFlags(readPubek):=FALSE			% 17
		     ,`outData:=cons(K1,outData(s))
		     ,`randCnt:=randCnt(s)+1]
    ENDCOND;

  takeOwnershipOut(s:tpmAbsState,encOwnerA,encSrkA:(encrypted?),
	k:(tpmKey?),a:authIn) : tpmAbsOutput =
    LET A1=decrypt(encOwnerA,private(s`ek),s`keys),			% 6
        A2=decrypt(encSrkA,private(s`ek),s`keys) IN 			% 10
    IF NOT takeOwnership?(s,k,encOwnerA,encSrkA)
    THEN IF i(s`permData`ownerAuth)/=INVALIDAUTH % TODO: CHECK 
      	 THEN OUT_Error(TPM_OWNER_SET)					% 1
     	 ELSIF not s`permFlags`ownership 
      	 THEN OUT_Error(TPM_INSTALL_DISABLED)				% 2
     	 ELSIF not goodkey?(key(s`ek)) 
      	 THEN OUT_Error(TPM_NO_ENDORSEMENT)				% 3
%% TODO:
%   	 ELSIF not OIAP?(a`authHandle) 
% 	 THEN OUT_Error(TPM_AUTHFAIL)					% 4
%   	 ELSIF not protocolID = TPM_PID_OWNER 
% 	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 5
% 	 ELSIF not length(A1)=20bytes 
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 6
%   	 ELSIF not command, params using A1, ownerAuth 
% 	 THEN OUT_Error(TPM_AUTHFAIL)					% 7
     	 ELSIF not storage?(keyUsage(k)) 
	 THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 8a
     	 ELSIF migratable(keyFlags(k)) 
	 THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 8b
     	 ELSIF NOT RSA?(algoId(algoParms(k))) 
	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8c
  	 ELSIF not SHA1_MGF1?(encScheme(algoParms(k))) 
	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8d    
  	 ELSIF not none?(sigScheme(algoParms(k))) 
	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8e
%   	 ELSIF length(parms(algoParms(k)))<2048 
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8f
%   	 ELSIF expSize(parms(algoParms(k)))/=0
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 8g
     	 ELSIF s`permFlags`FIPS AND never?(authDataUsage(k))
	 THEN OUT_Error(TPM_NOTFIPS)					% 8h
% 	 ELSIF not length(A2)=20bytes 
% 	 THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 10b
     	 ELSE OUT_Error(TPM_SUCCESS) % should never reach here
    	 ENDIF 
    ELSE %takeOwnership?(s,k)
        LET asymkey=tpmStoreAsymkey(A2,					% 10c
			migrationAuth(encData(encDat(k))),
			pubDataDigest(encData(encDat(k))),
			private(k)) IN
        % Structure containing all params of new SRK. srkPub.encData is set to 0
        LET K1=tpmKey(key(k),keyUsage(k),keyFlags(k),
		      authDataUsage(k),algoParms(k),
		      PCRInfo(k),encrypt(asymkey,0)),  %TODO!		% 9
	    aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			    contAuthSess:=TRUE,resAuth:=A1#) IN		% 18
    	    OUT_TakeOwnership(K1,aOut,TPM_SUCCESS)			% 16
    ENDIF;


  clear(s:tpmAbsState) : tpmAbsState = %not fully implemented
    s WITH [`keys:=(#vals:=emptyset,keys:=emptyset#) 
	   ,`permData(ownerAuth):=tpmSecret(INVALIDAUTH)		% 5a
      	   ,`srk:=tpmKey(0,keyUsage(s`srk),keyFlags(s`srk),
			 authDataUsage(s`srk),algoParms(s`srk),
			 PCRInfo(s`srk),encDat(s`srk))			% 5b
	   %,`permData(delegateKey):=badkey				% 5c
	   %,`permData(delegateTable):=invalid				% 5d
	   %,`permData(contextKey):=badkey				% 5e
	   ,`permData(tpmProof):=tpmSecret(INVALIDPROOF)		% 5f
	   ,`permData(operatorAuth):=tpmSecret(INVALIDAUTH)		% 5g
	   %,`permData(noOwnerNVWrite):=0				% 6a
	   %,`permData(ordinalAuditStatus):=default			% 6b
	   %,`permData(restrictDelegate):=default			% 6c
	   ,`stanyData:=stanyDataDefault				% 7
	   %TODO : nonces shall be reset, lists invalidated
	   ,`stclearData:=stclearDataDefault 
	   			WITH [`PCR:=PCR(stclearData(s))]	% 8
	   %TODO:nonces shall be reset, lists invalidated, defPhysPresence=0
	   ,`permFlags(disable):=disableDef				% 9a
	   ,`permFlags(deactivated):=deactivatedDef			% 9b
	   ,`permFlags(readPubek):=readPubekDef				% 9c
	   ,`permFlags(disableOwnerClear):=disableOwnerClearDef		% 9d
	   ,`permFlags(disableFullDALogicInfo):=disableFullDALogicInfoDef% 9e
	   ,`permFlags(allowMaintenance):=allowMaintenanceDef		% 9f
	   ,`permFlags(readSRKPub):=readSRKPubDef			% 9g
      	   ,`permFlags(ownership):=TRUE					% 10a
	   ,`permFlags(operator):=FALSE					% 10b
	   ,`permFlags(maintenanceDone):=FALSE				% 10c
	   %,`permData(monotonicCounter):= release all values		% 11
	   % TODO: 12-14
      	   ]

  ownerClearState(s:tpmAbsState,a:authIn) : tpmAbsState =
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> s,
      s`permFlags`disableOwnerClear -> s,				% 2
      ELSE -> clear(s)		      	 				% 3-14
    ENDCOND;

  ownerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    COND
    % TODO: Verify that the TPM Owner authorizes the command and all of the input,% 1
    %    else -> TPM_Error(TPM_AUTHFAIL),
      disableOwnerClear(permFlags(s)) -> OUT_Error(TPM_CLEAR_DISABLED),	% 2 
      ELSE -> LET a:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			     contAuthSess:=FALSE,resAuth:=ownerAuth(a)#) IN
      	      OUT_OwnerClear(a,TPM_SUCCESS)				% 3-14
    ENDCOND;

  forceClearState(s:tpmAbsState) : tpmAbsState = 
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN s								% 2
    	 ELSE clear(s)							% 3
    	 ENDIF
    ELSE s								% 1
    ENDIF
  
  forceClearOut(s:tpmAbsState) : tpmAbsOutput =
    IF s`stclearFlags`physicalPresence					% 1
    THEN IF s`stclearFlags`disableForceClear
    	 THEN OUT_Error(TPM_CLEAR_DISABLED)   	 	  	      	% 2
    	 ELSE OUT_ForceClear(TPM_SUCCESS)				% 3
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PRESENCE)					% 1
    ENDIF

  disableOwnerClearState(s:tpmAbsState,a:authIn) : tpmAbsState = 
  % 1. TPM verifies authHandle properly authorizes owner
    s WITH [`permFlags(disableOwnerClear):=TRUE];			% 2

  disableOwnerClearOut(s:tpmAbsState,a:authIn) : tpmAbsOutput = 
    LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=TRUE,resAuth:=ownerAuth(a)#) IN
    OUT_DisableOwnerClear(a1,TPM_SUCCESS)				
    % TODO: 3. When this flag is TRUE... Prove this?

  disableForceClearState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`stclearFlags(disableForceClear):=TRUE];			% 1

  disableForceClearOut(s:tpmAbsState) : tpmAbsOutput = 
    OUT_DisableForceClear(TPM_SUCCESS)

  physicalPresenceState(s:tpmAbsState,p:PHYSPRES) : tpmAbsState =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN s								% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN s								% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN s								% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN s								% 2d
	 ELSE s WITH [`permFlags`physicalPresenceHWEnable:=
			IF member(HW_ENABLE,p) THEN TRUE		% 2e
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2f
			ELSE s`permFlags`physicalPresenceHWEnable ENDIF,
		      `permFlags`physicalPresenceCMDEnable:=
			IF member(CMD_ENABLE,p) THEN TRUE		% 2g
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2h
			ELSE s`permFlags`physicalPresenceCMDEnable ENDIF,
		      `permFlags`physicalPresenceLifetimeLock:=
			IF member(LIFETIME_LOCK,p) THEN TRUE		% 2i
			ELSE s`permFlags`physicalPresenceLifetimeLock ENDIF]
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN s								% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN s								% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN s								% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN s								% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN s								% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE		% 3fi
	      	     ,`stclearFlags`physicalPresenceLock:=TRUE]		% 3fii
    	 ELSIF member(PRESENT,p)					% 3g
	 THEN s WITH [`stclearFlags`physicalPresence:=TRUE]		% 3gi
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN s WITH [`stclearFlags`physicalPresence:=FALSE]		% 3hi
	 ELSE s % should never get to this case.
    	 ENDIF
    ELSE s								% 4
    ENDIF

  physicalPresenceOut(s:tpmAbsState,p:PHYSPRES) : tpmAbsOutput =
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)			% 2
    THEN IF s`permFlags`physicalPresenceLifetimeLock
    	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 2d
	 ELSE OUT_PhysicalPresence(TPM_SUCCESS)				% 2j
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)	% 3
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3a
	 ELSIF s`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3d
	 ELSIF s`stclearFlags`physicalPresenceLock
	 THEN OUT_Error(TPM_BAD_PARAMETER)				% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3fiii
    	 ELSIF member(PRESENT,p) 					% 3g
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN OUT_PhysicalPresence(TPM_SUCCESS)				% 3i
	 ELSE OUT_Error(TPM_BAD_PARAMETER) % should never get here
    	 ENDIF
    ELSE OUT_Error(TPM_BAD_PARAMETER)					% 4
    ENDIF
  
  resetEstablishment?(s:tpmAbsState) : bool = 
    s`locality=3 or s`locality=4;

  resetEstablishmentBitState(s:tpmAbsState) : tpmAbsState = 
    IF resetEstablishment?(s)						% 1
    THEN s WITH [`permFlags(tpmEstablished):=FALSE]			% 2
    ELSE s
    ENDIF

  resetEstablishmentBitOut(s:tpmAbsState) : tpmAbsOutput = 
    IF resetEstablishment?(s)						% 1
    THEN OUT_ResetEstablishmentBit(TPM_SUCCESS)				% 3
    ELSE OUT_Error(TPM_BAD_LOCALITY)					%TODO
    ENDIF
  
  seal?(k:(tpmKey?)) : bool =
    storage?(keyUsage(k)) AND not(migratable(keyFlags(k)))
    
  sealState(s:tpmAbsState,kH:(tpmKey?),enc:(tpmEncAuth?),p:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : tpmAbsState =
    IF not seal?(kH)
    THEN s								% 3,4
    ELSE LET h2=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(p),% 11bvi 
				   s`pcrs)) IN
    	 LET s1=tpmStoredData(tpmPCRInfoLong(				% 11
				s`stanyFlags`localityModifier,		% 11viii
				locAtRelease(p),			% 11bv
				creationPCRSelect(p),			% 11bii
				releasePCRSelect(p),			% 11biii
				h2,					% 11bvii
				digAtRelease(p))			% 11biv
			     ,tpmNull					% 9
			     ) IN
	     % decrypting encAuth according to the ADIP indicated by authHandle
	 LET a1=decryptADIP(enc,authHandle(a)), % TODO: incorrect	% 12
	     h3:(tpmDigest?)=SHA1(s1) IN	  			% 14c
    	 LET S2=tpmSealedData(a1,		 			% 14,e
			      s`permData`tpmProof,			% 14b
			      h3,					% 14d
    	     		      inData) IN				% 14g
	% Validate the size(S2) can be encrypted by kH,TPM_BAD_DATASIZE % 15
	 LET S3=encrypt(S2,key(kH)) IN					% 16
	 LET S1=tpmStoredData(sealInfo(s1),S3)  	  		% 11,19
    	     IN s WITH [`outData:=cons(S1,outData(s))]			% 20
    ENDIF

  % Output secret sealed with asymmetric key 
  % crs(S1) encrypts S2
  sealOut(s:tpmAbsState,kH:(tpmKey?),enc:(tpmEncAuth?),p:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : tpmAbsOutput = 
    % Validate the authorization to use the key pointed to by kH	% 1
    % IF inDataSize = 0 THEN OUT_Error(TPM_BAD_PARAMETER)     		% 2
    IF not seal?(kH)
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 3,4
    % TODO: Determine version of pcrInfo				% 5
    ELSE LET h2=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(p),	% 11bvi 
				   s`pcrs)) IN
    	 LET s1=tpmStoredData(tpmPCRInfoLong(				% 11
				s`stanyFlags`localityModifier,		% 11viii
				locAtRelease(p),			% 11bv
				creationPCRSelect(p),			% 11bii
				releasePCRSelect(p),			% 11biii
				h2,					% 11bvii
				digAtRelease(p))			% 11biv
			     ,tpmNull					% 9
			     ) IN
	     % decrypting encAuth according to the ADIP indicated by authHandle
	 LET a1=decryptADIP(enc,authHandle(a)), % TODO: incorrect	% 12
	     h3:(tpmDigest?)=SHA1(s1) IN	  			% 14c
    	 LET S2=tpmSealedData(a1,		 			% 14,e
			      s`permData`tpmProof,			% 14b
			      h3,					% 14d
    	     		      inData) IN				% 14g
	% Validate the size(S2) can be encrypted by kH,TPM_BAD_DATASIZE % 15
	 LET S3=encrypt(S2,key(kH)) IN					% 16
	 LET S1=tpmStoredData(sealInfo(s1),S3),  	  		% 11,19
	     A:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,				% 17
			resAuth:=usageAuth(encData(encDat(kH)))#)
    	     IN OUT_Seal(S1,A,TPM_SUCCESS)				% 20
    ENDIF

  unseal?(s:tpmAbsState,p:(tpmKey?),d:(tpmStoredData?)) : bool =
    LET d1=decrypt(encrData(d),private(p),s`keys),			% 5
	S2=tpmStoredData(sealInfo(d),tpmNull),				% 4
	h2=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(sealInfo(d)),
			      s`pcrs)) IN				% 7bii
    storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND		% 2,3
    tpmSealedData?(d1) AND	   			   		% 5
    not(not(tpmProof(d1)=tpmProof(s`permData) AND			% 6b
        SHA1(S2)=storedDigest(d1))) AND	      				% 6e,f
    locAtRelease(sealInfo(S2))=localityModifier(s`stanyFlags) AND	% 7biii 
    h2=digAtRelease(sealInfo(S2))			      		% 7c

  unsealState(s:tpmAbsState,parent:(tpmKey?),inData:(tpmStoredData?),
	pa,da:authIn) : tpmAbsState = 
    LET d1=decrypt(encrData(inData),private(parent),s`keys),	  	% 5
	S2=tpmStoredData(sealInfo(inData),tpmNull),			% 4
	h2=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(sealInfo(inData)),
			      s`pcrs)) IN				% 7bii
    IF not unseal?(s,parent,inData)
    THEN s
    ELSE s WITH [`outData:=cons(sealedData(d1),outData(s))]		% 20
    ENDIF

  % Output secret unsealed with an asymmetric key and PCRs 
  unsealOut(s:tpmAbsState,parent:(tpmKey?),inData:(tpmStoredData?),
	pa,da:authIn) : tpmAbsOutput = 
    % Validate that pa authorizes the use of the key in p TPM_AUTHFAIL	% 1
    LET d1=decrypt(encrData(inData),private(parent),s`keys),	  	% 5
	S2=tpmStoredData(sealInfo(inData),tpmNull),			% 4
	h2=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(sealInfo(inData)),
			      s`pcrs)) IN				% 7bii
    IF not(storage?(keyUsage(parent)) AND	  			% 2
       	   not(migratable(keyFlags(parent))))				% 3
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not tpmSealedData?(d1)					% 5
    THEN OUT_Error(TPM_NOTSEALED_BLOB)
    ELSIF not(tpmProof(d1)=tpmProof(s`permData) AND			% 6b
       	  		SHA1(S2)=storedDigest(d1))			% 6e,f
       % TODO: 6g,
    THEN OUT_Error(TPM_NOTSEALED_BLOB)					% 6h
    ELSIF not locAtRelease(sealInfo(S2))=localityModifier(s`stanyFlags) % 7biii
    THEN OUT_Error(TPM_BAD_LOCALITY)
    ELSIF not h2=digAtRelease(sealInfo(S2))				% 7c
    THEN OUT_Error(TPM_WRONGPCRVAL)
    % validate authorization to use d1 by checking the HMAC calculation using 
    % authData(d1) as the shared secret matches the ownerAuth(da) TPM_AUTHFAIL 
    % on mismatch     	  	 		    		  	% 8
    % TODO: authdata stuff						% 9
    ELSE let a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
    	     resAuth:=usageAuth(encData(encDat(parent)))#) IN	% TODO: made up
    	 OUT_Unseal(sealedData(d1),a,a,TPM_SUCCESS) 		      % 10,11,12
    ENDIF;
  
  unBind?(k:(tpmKey?)) : bool =
    legacy?(keyUsage(k)) OR bind?(keyUsage(k))				% 3
  
  unBindState(s:tpmAbsState,k:(tpmKey?),d:(encrypted?),a:authIn) : tpmAbsState =
    LET d1=decrypt(d,private(k),s`keys) IN    	   	      	 	% 4  
    IF not unBind?(k) 
    THEN s
    ELSIF not tpmBoundData?(d1) OR
          (not SHA1_MGF1?(encScheme(algoParms(k))) AND			% 5
	       legacy?(keyUsage(k)))
    THEN s WITH [`outData:=cons(d1,outData(s))]
    ELSE s WITH [`outData:=cons(payloadData(d1),outData(s))]
    ENDIF;

  % Output decrypted key
  unBindOut(s:tpmAbsState,k:(tpmKey?),d:(encrypted?),a:authIn):tpmAbsOutput=
    % if inDataSize=0 OUT_Error(TPM_BAD_PARAMETER)			% 1
    % validate the AuthData to use the key pointed to by k		% 2
    LET d1=decrypt(d,private(k),s`keys),     	   	      	 	% 4
    	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#) IN 
    IF not unBind?(k)							% 3
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not tpmBoundData?(d1) OR
          (not SHA1_MGF1?(encScheme(algoParms(k))) AND			% 5
	       legacy?(keyUsage(k)))
    THEN OUT_UnBind(d1,a,TPM_SUCCESS)					% 6,7
    ELSE OUT_UnBind(payloadData(d1),a,TPM_SUCCESS)			% 6,7
    ENDIF  	    

  checkFIPS?(s:tpmAbsState,k:(tpmKey?)) : bool =
    IF s`permFlags`FIPS AND
       	   (%keySize(k) < 1024 OR
    	    never?(authDataUsage(k)) OR
	    legacy?(keyUsage(k)))	
    THEN FALSE
    ELSE TRUE
    ENDIF

  checkKey?(k:(tpmKey?)) : bool = 
    not((storage?(keyUsage(k)) or migrate?(keyUsage(k)))		% 8
    	 AND not RSA?(algoId(algoParms(k)))				% 8i
       )
%     IF (storage?(keyUsage(k)) or migrate?(keyUsage(k)))		% 8
%     	AND not RSA?(algoId(algoParms(k)))				% 8i
%   	  AND not SHA1_MGF1?(encScheme(algoParms(srkParms))) 		% 8ii
%   	  AND not SS_NONE?(sigScheme(algoParms(srkParms))) 		% 8iii
%   	  AND length(parms(algoParms(srkParms)))/=2048 			% 8iv
%   	  AND expSize(parms(algoParms(srkParms)))/=0			% 8v
%     THEN FALSE
%     ELSE TRUE
%     ENDIF

  createWrapKey?(p,k:(tpmKey?)):bool = 
    storage?(keyUsage(p)) AND						% 4
    IF migratable(keyFlags(p)) AND not(migratable(keyFlags(k)))		% 5
    THEN FALSE 
    ELSE IF identity?(keyUsage(k)) OR authChange?(keyUsage(k))		% 6a
    	 THEN FALSE
	 ELSE not(migrateAuthority(keyFlags(k)))			% 6b
	 ENDIF
    ENDIF;

  createWrapKeyState(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsState =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN s
    ELSIF not checkFIPS?(s,k)					% 7
       THEN s
    ELSIF not checkKey?(k)						% 8
       THEN s
    % Determine version of key						% 9
    ELSE LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),		% 10
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)) IN		% 11
	LET h=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(PCRInfo(k)),
			      s`pcrs)) IN				% 15d
	LET encData=encrypt(tpmStoreAsymkey(DU1,			% 14a
	    			IF migratable(keyFlags(k)) THEN DM1	% 14b
				ELSE s`permData`tpmProof ENDIF, 	% 14c
				%TODO: next line is incorrect?
				pubDataDigest(encData(encDat(k))),
				inverse(s`keyGenCnt))
			   ,key(p)),
	    pcrs=tpmPCRInfoLong(s`locality,				% 15e	
				locAtRelease(PCRInfo(k)),		% 15c
				creationPCRSelect(PCRInfo(k)),		% 15c
				releasePCRSelect(PCRInfo(k)),		% 15c
				h,					% 15d
				digAtRelease(PCRInfo(k))) IN		% 15c
    	 genKeyState(s) WITH [`outData:=cons(tpmKey(s`keyGenCnt,
							keyUsage(k),
				    			keyFlags(k),
				    			authDataUsage(k),
				    			algoParms(k),
				    			pcrs,		% 15c
				    			encData),
						outData(s))]
    ENDIF;

  % Generate a NEW RANDOM key pair.
  createWrapKeyOut(s:tpmAbsState,p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
	a:authIn) : tpmAbsOutput =
    %validate the AuthData to use the key pointed to by p. TPM_AUTHFAIL	% 1 
    %validate the session type for p is OSAP	     	   		% 2
    IF not createWrapKey?(p,k)				    		% 4,5,6
       THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not checkFIPS?(s,k)						% 7
       THEN OUT_Error(TPM_NOTFIPS)
    ELSIF not checkKey?(k)						% 8
       THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    % determine version of key						% 9
    ELSE 
    	 LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),		% 10
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)),		% 11
	     b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 12
			resAuth:=usageAuth(encData(encDat(p)))#) IN
	LET h=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(PCRInfo(k)),
			      s`pcrs)) IN				% 15d
	LET encData=encrypt(tpmStoreAsymkey(DU1,			% 14a
	    			IF migratable(keyFlags(k)) THEN DM1	% 14b
				ELSE s`permData`tpmProof ENDIF, 	% 14c
				%TODO: next line is incorrect?
				pubDataDigest(encData(encDat(k))),
				inverse(s`keyGenCnt))
			   ,key(p)),
	    pcrs=tpmPCRInfoLong(s`locality,				% 15e	
				locAtRelease(PCRInfo(k)),		% 15c
				creationPCRSelect(PCRInfo(k)),		% 15c
				releasePCRSelect(PCRInfo(k)),		% 15c
				h,					% 15d
				digAtRelease(PCRInfo(k))) IN		% 15c
      	   OUT_CreateWrapKey(tpmKey(s`keyGenCnt,			% 13,14
				    keyUsage(k),
				    keyFlags(k),
				    authDataUsage(k),
				    algoParms(k),
				    pcrs,				% 15c
				    encData),
			     b,TPM_SUCCESS)
    ENDIF
    

  validateEncrSigSchemes(k:(tpmKey?)) : bool = 
    validEncScheme(keyUsage(k),encScheme(algoParms(k))) AND 
    validSigScheme(keyUsage(k),sigScheme(algoParms(k)))

  checkKeyUsage(k:(tpmKey?)) : bool = 
    CASES keyUsage(k) OF
      storage : RSA?(algoId(algoParms(k))) AND				% 7gi
	 	     none?(sigScheme(algoParms(k))),			% 7giv
      migrate : RSA?(algoId(algoParms(k))) AND				% 7gi
	 	     none?(sigScheme(algoParms(k))),			% 7giv
      identity: RSA?(algoId(algoParms(k))) AND				% 7hi
	 	     none?(encScheme(algoParms(k)))			% 7hiv
      ELSE TRUE
      ENDCASES
  
  validateKeyConsistency(s:tpmAbsState,p,k:(tpmKey?),e:(tpmStoreAsymkey?)):nat= 
    IF migratable(keyFlags(k))=0 AND
    	 migrationAuth(e)/=tpmProof(permData(s)) 			% 7d
    THEN 4
    ELSIF not validateEncrSigSchemes(k)					% 7e  
    THEN 4				
    ELSIF FIPS(permFlags(s)) AND 
    	  (never?(authDataUsage(k)) OR legacy?(keyUsage(k))) 
    THEN 3								% 7f
    ELSIF not checkKeyUsage(k)						% 7g,h
    THEN 4
    %TODO if pcrInfo(k)=null then set internal indicator key not using pcrs% 7i
    ELSE 0 
    ENDIF

  validateLoadKey2(s:tpmAbsState,p,k:(tpmKey?)) : nat = 
    %Validate cmd & params using ownerAuth(a) and usageAuth(encDat(p))	% 1 
    IF not storage?(keyUsage(p)) 	      	  			% 2  
    THEN 1 	      				
    %If not designed to operate on key type(k) TPM_BAD_KEY_PROPERTY 	% 3
    ELSE LET d1=decrypt(encDat(k),private(p),s`keys) IN  		% 5
    %Reproduce pubDataDigest(encDat(k)) = pubDataDigest(d1)		% 6
    %TODO:IF migratable(keyFlags(k)) THEN verify consistency		% 7a
         CASES keyUsage(k) OF
    	 identity: IF migratable(keyFlags(k))=FALSE			% 7b
	 	   THEN validateKeyConsistency(s,p,k,d1)
	 	   ELSE 1  
		   ENDIF,
	 authChange: 1							% 7c
	 ELSE validateKeyConsistency(s,p,k,d1)
	 ENDCASES
    ENDIF;

  loadKey2?(state:tpmAbsState,p,k:(tpmKey?)) : bool = 
    validateLoadKey2(state,p,k)=0

  %% Install key operation on TPM state.
  loadKey2State(s:tpmAbsState,p,k:(tpmKey?),a:authIn) : tpmAbsState =
    IF validateLoadKey2(s,p,k)=0  
    THEN s with [`keys:=loadKey(k,p,keys(s),pcrs(s))
    	   	,`outData:=cons(k,outData(s))]
    ELSE s
    ENDIF;

  loadKey2Out(s:tpmAbsState,parentH,inKey:(tpmKey?),a:authIn) : tpmAbsOutput = 
    LET num=validateLoadKey2(s,parentH,inKey) IN	      		% 1-7
      COND 
      num=0 -> LET aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN % TODO: resAuth!
		OUT_LoadKey2(inKey,aOut,TPM_SUCCESS),			% 9
	       % TODO: 8,10-12
      num=1 -> OUT_Error(TPM_INVALID_KEYUSAGE),
      num=3 -> OUT_Error(TPM_NOTFIPS),
      ELSE  -> OUT_Error(TPM_FAIL) %TODO: madeup which error message to use
      ENDCOND;


  getPubKey?(s:tpmAbsState,key:(tpmKey?)) : bool = 
    %Validate cmd params using usageAuth(encDat(key)) TPM_AUTHFAIL	% 1a
    never?(authDataUsage(key)) AND s`permFlags`readSRKPub
    AND %pcrInfoSize(key)/=0						% 4
    (pcrIgnoredOnRead(keyFlags(key))					% 4a
    OR dig(digAtRelease(PCRInfo(key)))= 				% 4ai
    	tpmPCRComposite(select(dig(digAtRelease(PCRInfo(key)))),s`pcrs))
  
  getPubKeyState(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsState =
    IF not getPubKey?(s,k)
    THEN s
    ELSE LET pubKey=tpmPubkey(algoParms(k),key(k)) IN
    	 s WITH [`outData:=cons(pubKey,outData(s))]
    ENDIF;

  getPubKeyOut(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsOutput =
    %Validate cmd params using usageAuth(encDat(key)) TPM_AUTHFAIL	% 1a
    IF not never?(authDataUsage(k)) 
    THEN OUT_Error(TPM_AUTHFAIL)					% 2a
    ELSIF not(s`permFlags`readSRKPub)
    THEN OUT_Error(TPM_INVALID_KEYHANDLE)				% 3a	
    ELSIF %pcrInfoSize(key)/=0						% 4
    	  not(pcrIgnoredOnRead(keyFlags(k)))				% 4a
    	  AND dig(digAtRelease(PCRInfo(k)))/=				% 4ai
    	      tpmPCRComposite(select(dig(digAtRelease(PCRInfo(k)))),
			s`pcrs)	
    THEN OUT_Error(TPM_WRONGPCRVAL)
    %TODO: If specified, validate any locality requests			% 4aii
    ELSE LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#),
	     pubKey=tpmPubkey(algoParms(k),key(k)) IN
    	 OUT_GetPubKey(pubKey,aOut,TPM_SUCCESS)				% 5
    ENDIF;
    
%TODO: Sealx   
   sealxState(s:tpmAbsState,k:(tpmKey?),encAuth:(tpmEncAuth?),
	p:(tpmPCRInfoLong?),inData:tpmData,a:authIn) : tpmAbsState

%    sealxOut(s:tpmAbsStatek:(tpmKey?),encAuth:(tpmEncAuth?),p:(tpmPCRInfoLong?),
% 	inData:tpmData,a:authIn) : tpmAbsOutput = 
%    %Validate the authorization to use k					% 1
%    %IF inDataSize=0 THEN OUT_Error(TPM_BAD_PARAMETER)			% 2
%    IF not seal?(k)
%    THEN OUT_Error(TPM_INVALID_KEYUSAGE)					% 3,4
%    ELSE LET h2=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(p),		% 9f
% 				  s`pcrs)) IN
%    	LET S1=tpmStoredData(tpmPCRInfoLong(
% 				s`stanyFlags`localityModifier,		% 9h
% 				locAtRelease(p),			% 9e
% 				creationPCRSelect(p),			% 9b
% 				releasePCRSelect(p),			% 9c
% 				h2,					% 9g
% 				digAtRelease(p)),			% 9d
% 			     tpmNull,					% 6,7
% 			     clear)
% 	LET a1=decryptADIP(encAuth,authHandle(a)),			% 11
% 	    % TODO: 11 a,b, 13
% 	    % TODO: o1=decrypt(,inData)					% 14
% 	    h3=SHA1(S1) IN						% 15c
% 	LET S2=tpmSealedData(a1,					% 10,15e
% 	    		     s`permData`tpmProof,			% 15b
% 			     h3,					% 15d
% 			     o1,					% 15g
% 			     ) IN
% 	LET S3=tpmSealedData(
			     

  checkMigKeyAuth?(s:tpmAbsState,a:(tpmMigKeyAuth?)):bool =		% 5
    digest(a)=SHA1(concat(key(a),concat(scheme(a),s`permData`tpmProof)))
  
  createMigBlob?(s:tpmAbsState,p:(tpmKey?),m:(tpmMigScheme?),
	a:(tpmMigKeyAuth?),e:(encrypted?)) : bool = 
    storage?(keyUsage(p)) AND						% 2
    LET d1=decrypt(e,private(p),s`keys) IN				% 3
    tpmStoreAsymkey?(d1) AND						% 3
    checkMigKeyAuth?(s,a) AND						% 5
    CASES migScheme(m) OF
    	  migrate : TRUE,
	  rewrap  : TRUE
	  ELSE FALSE							% 8
    ENDCASES	

  createMigBlobState(s:tpmAbsState,p:(tpmKey?),migType:(tpmMigScheme?),
	mKeyAuth:(tpmMigKeyAuth?),encData:(encrypted?),a1,a2:authIn) :
	tpmAbsState = 
    LET d1=decrypt(encData,private(p),s`keys) IN			% 3
    IF createMigBlob?(s,p,migType,mKeyAuth,encData)
    THEN CASES migScheme(migType) OF
	       migrate: LET K1=privKey(d1),				% 6ai
	       		    K2=privKey(d1) IN				% 6aii
				% only supposed to be part of private key... 
	       		LET M1=tpmMigrateAsymkey(
				        usageAuth(d1),			% 6bii
					pubDataDigest(d1),		% 6biii
					K2) IN				% 6bv
			LET o1=OAEP(M1,migrationAuth(d1),K1),		% 6c
			    r1=RNG(s`randCnt) IN			% 6d
			LET x1=encrypt(tpmXOR(o1,r1)			% 6e
				      ,key(key(mKeyAuth))) IN 		% 6g
    	 		randState(s) WITH 
				[`outData:=cons(r1,cons(x1,outData(s)))],% 6f
	       rewrap : s WITH [`outData:=cons(encrypt(d1,key(key(mKeyAuth))),
					   cons(RNG(0),outData(s)))]	% 7
	       ELSE s							% 8
	 ENDCASES
    ELSE s
    ENDIF;

  createMigBlobOut(s:tpmAbsState,p:(tpmKey?),migType:(tpmMigScheme?),
	mKeyAuth:(tpmMigKeyAuth?),encData:(encrypted?),a1,a2:authIn) :
	tpmAbsOutput =
    %TODO: Validate ownerAuth(a1) authorizes use of p			% 1
    LET d1=decrypt(encData,private(p),s`keys),				% 3
    	ao1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(p)))#),
    	ao2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(key(mKeyAuth))))#) IN
    IF not storage?(keyUsage(p))       	      				% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not tpmStoreAsymkey?(d1)					% 3
    THEN OUT_Error(TPM_BAD_MIGRATION) %TODO: made up which error to use
    %Validate ownerAuth(a2) authorizes migration of d1, 		% 4
    % 	   	 must use migrationAuth(d1) as secret.
    ELSIF not checkMigKeyAuth?(s,mKeyAuth)				% 5
    THEN OUT_Error(TPM_AUTHFAIL)
    ELSE CASES migScheme(migType) OF
	       migrate: LET K1=privKey(d1),				% 6ai
	       		    K2=privKey(d1) IN				% 6aii
				% only supposed to be part of private key... 
	       		LET M1=tpmMigrateAsymkey(
				        usageAuth(d1),			% 6bii
					pubDataDigest(d1),		% 6biii
					K2) IN				% 6bv
			LET o1=OAEP(M1,migrationAuth(d1),K1),		% 6c
			    r1=RNG(s`randCnt) IN			% 6d
			LET x1=encrypt(tpmXOR(o1,r1)			% 6e
				      ,key(key(mKeyAuth))) IN 		% 6g
			OUT_CreateMigrationBlob(r1,			% 6f
				x1,
				ao1,ao2,
				TPM_SUCCESS),
	       rewrap : OUT_CreateMigrationBlob(RNG(0),			% 7b
				encrypt(d1,key(key(mKeyAuth))),		% 7a
				ao1,ao2,
				TPM_SUCCESS)
	       ELSE OUT_Error(TPM_BAD_PARAMETER)			% 8
	 ENDCASES
    ENDIF
	 
  convertMigBlob?(s:tpmAbsState,p:(tpmKey?),d:(encrypted?),r:(RNG?)) : bool =
    storage?(keyUsage(p)) AND
    LET d1=decrypt(d,private(p),s`keys) IN				% 3
    LET o1=unXOR(d1,r) IN						% 4
    LET m1=OAEPdecode(o1),%TODO: seed,pHash				% 5
	pHash:(tpmSecret?)=tpmSecret(1) IN 
    LET k1:privKVAL=partPrivKey(m1) IN %TODO:combine seed		% 6
    	tpmMigrateAsymkey?(m1) 		    		  		% 7a


  convertMigBlobState(s:tpmAbsState,parent:(tpmKey?),inData:(encrypted?),
	rand:(RNG?),a:authIn) : tpmAbsState =
    LET d1=decrypt(inData,private(parent),s`keys) IN			% 3
    IF not convertMigBlob?(s,parent,inData,rand) 
    THEN s
    ELSE LET o1=unXOR(d1,rand) IN					% 4
    	 LET m1=OAEPdecode(o1),						% 5
	     pHash:(tpmSecret?)=tpmSecret(1) IN
	 LET k1:privKVAL=partPrivKey(m1) IN %TODO:combine seed		% 6
	 	 IF not tpmMigrateAsymkey?(m1)
	 THEN s
	 ELSE LET d2=encrypt(tpmStoreAsymkey(%TPM_PT_ASYM,		% 7b
	     			usageAuth(m1),				% 7c
				pHash,					% 7d
				pubDataDigest(m1),			% 7e
				k1),					% 7f
			  key(parent)) IN 				% 8
	      s WITH [`outData:=cons(d2,outData(s))]
ENDIF
    ENDIF;

  convertMigBlobOut(s:tpmAbsState,parent:(tpmKey?),inData:(encrypted?),
	rand:(RNG?),a:authIn) : tpmAbsOutput =
    % TODO: Validate authData to use key in parent			% 1
    LET d1=decrypt(inData,private(parent),s`keys),			% 3
    	aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(parent)))#) IN
    IF not storage?(keyUsage(parent))					% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSE LET o1=unXOR(d1,rand) IN					% 4
	 LET m1=OAEPdecode(o1),%TODO: seed,pHash			% 5
	     pHash:(tpmSecret?)=tpmSecret(1) IN %TODO
 	 LET k1:privKVAL=partPrivKey(m1) IN %TODO:combine seed		% 6
 	 IF not tpmMigrateAsymkey?(m1) 		    		  	% 7a
 	 THEN OUT_Error(TPM_BAD_MIGRATION) %TODO: made up which error
	 ELSE LET d2=encrypt(tpmStoreAsymkey(%TPM_PT_ASYM,		% 7b
	     			usageAuth(m1),				% 7c
				pHash,					% 7d
				pubDataDigest(m1),			% 7e
				k1),					% 7f
			  key(parent)), 				% 8
	          aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
				contAuthSess:=TRUE,
				resAuth:=usageAuth(encData(encDat(parent)))#) IN
	      OUT_ConvertMigrationBlob(d2,aOut,TPM_SUCCESS)
	 ENDIF
    ENDIF
    
  authorizeMigKeyState(s:tpmAbsState,migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : tpmAbsState = 
    s WITH [`outData:=cons(tpmMigKeyAuth(migKey,			% 3,5
				migScheme,				% 6
				SHA1(concat(migKey,
					concat(migScheme,
						s`permData`tpmProof)))	% 7,8,9
				),
			outData(s))]
  
  authorizeMigKeyOut(s:tpmAbsState,migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : tpmAbsOutput = 
    % Check cryptographic strength of migrationKey >=2048RSA		% 1
    % Validate authdata to use the TPM by the TPM owner			% 2
%     IF TODO: not MGF1?(encScheme(algoParms(migKey)))	  		% 4
%     THEN OUT_Error(TPM_INAPPROPRIATE_ENC)
%     ELSE 
    	 OUT_AuthorizeMigrationKey(
		tpmMigKeyAuth(migKey,					% 3,5
			migScheme,					% 6
			SHA1(concat(migKey,
				concat(migScheme,s`permData`tpmProof))) % 7,8,9
		),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(a)#),
		TPM_SUCCESS)
%     ENDIF;

  migrateKey?(m:(tpmKey?)) : bool =
  	migrate?(keyUsage(m)) AND SHA1_MGF1?(encScheme(algoParms(m)))

  migrateKeyState(s:tpmAbsState,m,p:(tpmKey?),d:(encrypted?),a:authIn) : 
  	tpmAbsState =
    LET d1=decrypt(d,private(m),s`keys) IN
    IF not migrateKey?(m) 
    THEN s
    ELSE s WITH [`outData:=cons(encrypt(d1,key(p)),outData(s))]		% 4
    ENDIF;

  %% Decrypts the input packet (coming from TPM_CreateMigrationBlob) and then 
  %% re-encrypts it with the input public key. The output would then be sent to 
  %% TPM_ConvertMigrationBlob on the target TPM.
  migrateKeyOut(s:tpmAbsState,m,p:(tpmKey?),d:(encrypted?),a:authIn) : 
  	tpmAbsOutput =
    LET d1=decrypt(d,private(m),s`keys) IN 
    % Validate ownerAuth(a) authorizes use of m			  	% 1
    IF not migrate?(keyUsage(m))       	      				% 2
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not SHA1_MGF1?(encScheme(algoParms(m)))			% 2
    THEN OUT_Error(TPM_INAPPROPRIATE_ENC)
    ELSE LET d1=decrypt(d,private(m),s`keys) IN
    	 OUT_MigrateKey(encrypt(d1,key(p)),				% 4
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(m)))#),
		TPM_SUCCESS)
    ENDIF

  CMKSetRestr?(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : bool =
    %permData(restrictDelegate) is used as follows:
    %sessionType = TPM_PID_DSAP AND			    		% 1
%        migrateAuthority(keyFlags(_)) %TODO: WHICH KEY?
%        AND (signing?(keyUsage(_)) AND r(delegateSigning)) OR	% 1a
%            (storage?(keyUsage(_)) AND r(delegateStorage)) OR
%            (bind?(keyUsage(_)) AND r(delegateBind)) OR
% 	   (legacy?(keyUsage(_)) AND r(delegateLegacy)) OR
% 	   (migrate?(keyUsage(_)) AND r(delegateMigrate))
	   TRUE;


  CMKSetRestrState(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : tpmAbsState =
    IF CMKSetRestr?(s,r,i)
    THEN %key can be used
    	 %Validate ordinal and parameters using TPM Owner authentication
	 %on error, OUT_Error(TPM_AUTHFAIL)
	 s WITH [`permData(restrictDelegate):=r]			% 2
    ELSE s
    ENDIF;

  CMKSetRestrOut(s:tpmAbsState,r:(tpmCMKDelegate?),i:authIn) : tpmAbsOutput =
    IF CMKSetRestr?(s,r,i)
    THEN %key can be used
    	 %TODO Validate ordinal and parameters using TPM Owner authentication
	 %on error, OUT_Error(TPM_AUTHFAIL)				% 1
	 LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i)#) IN
	 OUT_CMK_SetRestrictions(a,TPM_SUCCESS)				% 3
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF;

  CMKApproveMAState(s:tpmAbsState,migAuth:(tpmDigest?),i:authIn) : tpmAbsState =
    LET M2=tpmCMKMAApproval(migAuth) IN	     	 			% 2
    s WITH [`outData:=cons(tpmHMAC(M2,s`permData`tpmProof),outData(s))]

  CMKApproveMAOut(s:tpmAbsState,migAuth:(tpmDigest?),i:authIn) : tpmAbsOutput = 
    %TODO Validate AuthDat to use the TPM by TPM Owner			% 1
    LET M2=tpmCMKMAApproval(migAuth),	     	 			% 2
	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(i)#) IN
    OUT_CMK_ApproveMA(tpmHMAC(M2,s`permData`tpmProof),a,TPM_SUCCESS);	% 3

  validateMigrateAuthority?(s:tpmAbsState,m,a:(tpmDigest?)) : bool =
    LET M1=tpmCMKMAApproval(m) IN					% 8ai
    a=tpmHMAC(M1,s`permData`tpmProof)					% 8b

  validateKeyParams?(k:(tpmKey?)) : bool =
    not(identity?(keyUsage(k)) or authChange?(keyUsage(k)))		% 9

  CMKCreateKey?(s:tpmAbsState,p:(tpmKey?),k:(tpmKey?),m,a:(tpmDigest?)) : bool =
    storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND		% 4,5
    migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k))		% 6,7
    AND validateMigrateAuthority?(s,m,a) 				% 8  
    AND validateKeyParams?(k)						% 9
    AND checkFIPS?(s,k)							% 10
    AND checkKey?(k)							% 11

  CMKCreateKeyState(s:tpmAbsState,p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
    a:(tpmDigest?),m:(tpmDigest?),i:authIn) : tpmAbsState = 
    IF not CMKCreateKey?(s,p,k,m,a)
    THEN s
    ELSE LET DU1=decryptADIP(d,authHandle(i)),				% 14
	     pcr=tpmPCRInfoLong(s`stanyFlags`localityModifier,		% 18d
				locAtRelease(PCRInfo(k)), 
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				tpmCompositeHash(
					tpmPCRComposite(creationPCRSelect(
								PCRInfo(k)),
							s`pcrs)),	% 18c
				digAtRelease(PCRInfo(k))),
	     M2=tpmCMKMigAuth(m,					% 17di
             		      SHA1(tpmPubkey(algoParms(k),key(k)))) IN	% 17dii
	 LET enc=encrypt(tpmStoreAsymkey(DU1,				% 17a
	     			%tpmHMAC(M2,s`permData`tpmProof),	% 17e
 				tpmSecret(1),
% 				%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				pubDataDigest(encData(encDat(k))),
				private(k))
			   ,key(p)) IN					% 19
    	 LET wrappedKey=tpmKey(key(k),					% 13,17
	     		       keyUsage(k),
			       keyFlags(k),
			       authDataUsage(k),
			       algoParms(k),
			       pcr,					% 18
			       enc) IN
    	 s WITH [`outData:=cons(wrappedKey,outData(s))]
    ENDIF

  CMKCreateKeyOut(s:tpmAbsState,p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
    a:(tpmDigest?),m:(tpmDigest?),i:authIn) : tpmAbsOutput = 
    %TODO: Validate AuthData to use key pointed to by p. OUT_Error(TPM_AUTHFAIL)
    % Validate session type for p is OSAP				% 2
    % IF TPM not designed to create key of type requested in k, OUT_ERROR(TPM_BAD_KEY_PROPERTY) % 3
    IF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND	% 4,5
    migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k)))		% 6,7
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not(validateMigrateAuthority?(s,m,a))				% 8
    THEN OUT_Error(TPM_MA_AUTHORITY)
    ELSIF not(validateKeyParams?(k))					% 9
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				
    ELSIF not(checkFIPS?(s,k))						% 10
    THEN OUT_Error(TPM_NOTFIPS)
    ELSIF not(checkKey?(k))						% 11
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    %TODO 12
    ELSE LET DU1=decryptADIP(d,authHandle(i)),				% 14
    	     ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 15
			resAuth:=usageAuth(encData(encDat(p)))#),
	     pcr=tpmPCRInfoLong(s`stanyFlags`localityModifier,		% 18d
				locAtRelease(PCRInfo(k)), 
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				tpmCompositeHash(
					tpmPCRComposite(creationPCRSelect(
							PCRInfo(k)),
						s`pcrs)),		% 18c
				digAtRelease(PCRInfo(k))),
	     M2=tpmCMKMigAuth(m,					% 17di
             		      SHA1(tpmPubkey(algoParms(k),key(k)))) IN	% 17dii
	 LET enc=encrypt(tpmStoreAsymkey(DU1,				% 17a
	     			%tpmHMAC(M2,s`permData`tpmProof),	% 17e
 				tpmSecret(1),
% 				%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				pubDataDigest(encData(encDat(k))),
				private(k))
			   ,key(p)) IN					% 19
    	 LET wrappedKey=tpmKey(key(k),					% 13,17
	     		       keyUsage(k),
			       keyFlags(k),
			       authDataUsage(k),
			       algoParms(k),
			       pcr,					% 18
			       enc) IN
	 OUT_CMK_CreateKey(wrappedKey,ao,TPM_SUCCESS)
    ENDIF;

  validateKeyAlgo?(k:(tpmPubkey?)) : bool = 
    RSA?(algoId(algoParms(k)))
       %AND NONE?(encScheme(algoParms(verifKey)))
       %AND (SHA1?(sigScheme(algoParms(verifKey))) OR 
       % INFO?(sigScheme(algoParms(verifKey))))
  
  CMKCreateTicket?(k:(tpmPubkey?),signedData:(tpmDigest?)) : bool = 
    validateKeyAlgo?(k) AND
    checkSig?(pubKey(k),signedData)
    
  CMKCreateTicketState(s:tpmAbsState,verifKey:(tpmPubkey?)
    ,signedData:(tpmDigest?),sigVal:tpmData,i:authIn) : tpmAbsState = 
    IF not CMKCreateTicket?(verifKey,signedData)
    THEN s
    ELSE LET M2=tpmCMKSigTicket(SHA1(verifKey),signedData) IN		% 4
    	 s WITH [`outData:=cons(tpmHMAC(M2,s`permData`tpmProof),outData(s))]
    ENDIF;
    
  CMKCreateTicketOut(s:tpmAbsState,verifKey:(tpmPubkey?),signedData:(tpmDigest?)
    ,sigVal:tpmData,i:authIn) : tpmAbsOutput = 
    %TODO Validate Owner authentication					% 1
    IF not(validateKeyAlgo?(verifKey))					% 2
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)	%TODO: CHECK
    ELSIF not(checkSig?(pubKey(verifKey),signedData))			% 3
    THEN OUT_Error(TPM_BAD_SIGNATURE)
    ELSE LET M2=tpmCMKSigTicket(SHA1(verifKey),signedData),		% 4
    	     a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,%TODO: FLAG?
			resAuth:=ownerAuth(i)#) IN%TODO: CHANGED... DOUBLE CHECK
    	 OUT_CMK_CreateTicket(tpmHMAC(M2,s`permData`tpmProof),a,TPM_SUCCESS)%5,6
    ENDIF;


  CMKCreateBlob?(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      encData:(encrypted?)) : bool =
    LET d1=decrypt(encData,private(p),s`keys),				% 4
    	M2=tpmCMKMigAuth(SHA1(msaList),psk) IN				% 7a
    % Validate i authorizes use of key pointed to by p			% 1
    IF t=scheme(mkAuth)
    THEN FALSE								% 2
    ELSIF migratable(keyFlags(p))=TRUE
    THEN FALSE								% 3
    % Verify digest within mkAuth is legal for ths tpm and public key	% 5
    % Verify d1->payload = Migrate_restricted or migrate_external 	% 6
    % Verify mig authorities in msaList are authorized to migrate this key % 7
    ELSIF migrationAuth(d1)/=tpmHMAC(M2,s`permData`tpmProof)
    THEN FALSE								% 7b
    ELSE CASES migScheme(scheme(mkAuth)) OF
    	   restrictMigrate: 						% 8
	      %Verify intended migration destination is MA:
	      %IF member(SHA1(key(mkAuth)),migAuthDigest(msaList))	% 8a
	      %   RSA?(algoId(algoParms(key(mkAuth)))) 			% 8bi
	      %TODO							% 8biii
	      TRUE,
    	   restrictApprove:						% 9
	      %TODO: 9i
	      % LET V1=tpmCMKSigTicket(migAuthDigest(msaList),SHA1(resTic)
	      %IF member(,migAuthDigest(msaList)) 
	      %OUT_Error(TPM_MA_DESTINATION) OUT_Error(TPM_MA_SOURCE)
	      TRUE
	   ELSE FALSE							% 10
    	 ENDCASES
    ENDIF;

   
  CMKCreateBlobOut2(s:tpmAbsState,p:(tpmKey?),mkAuth:(tpmMigKeyAuth?),
      psk:(tpmDigest?),msaList:(tpmMSAComposite?),d1:(tpmStoreAsymkey?),
      i:authIn) : tpmAbsOutput =
    LET K1=privKey(d1),							% 11a
    	K2=privKey(d1) IN						% 11b
    LET M1=tpmMigrateAsymkey(usageAuth(d1),				% 12b
    			pubDataDigest(d1),				% 12c
			K2) IN						% 12e
    LET o1=OAEP(M1,							% 13a
		SHA1(concat(SHA1(msaList),psk)),			% 13b
		K1),							% 13c
        r1=RNG(s`randCnt) IN						% 14
    LET x1=tpmXOR(o1,r1),						% 15
    	a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,%TODO: FLAG?
			resAuth:=usageAuth(encData(encDat(p)))#) IN
        OUT_CMK_CreateBlob(r1,						% 16
		encrypt(x1,key(key(mkAuth))),a,TPM_SUCCESS)		% 17
		
  CMKCreateBlobState(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      resTic:(tpmCMKAuth?),sigTic:(tpmDigest?),encData:(encrypted?),
      i:authIn) : tpmAbsState =
    LET d1=decrypt(encData,private(p),s`keys) IN
    IF CMKCreateBlob?(s,p,t,mkAuth,psk,msaList,encData)
    THEN LET a=CMKCreateBlobOut2(s,p,mkAuth,psk,msaList,d1,i) IN
    	 CASES a OF
	   OUT_CMK_CreateBlob(r,e,o1,m) : 
	   	randState(s) WITH [`outData:=cons(r,cons(e,outData(s)))]
	   ELSE s
	 ENDCASES
    ELSE s
    ENDIF;

  CMKCreateBlobOut(s:tpmAbsState,p:(tpmKey?),t:(tpmMigScheme?),
      mkAuth:(tpmMigKeyAuth?),psk:(tpmDigest?),msaList:(tpmMSAComposite?),
      resTic:(tpmCMKAuth?),sigTic:(tpmDigest?),encData:(encrypted?),
      i:authIn) : tpmAbsOutput =
    LET d1=decrypt(encData,private(p),s`keys),				% 4
    	M2=tpmCMKMigAuth(SHA1(msaList),psk) IN				% 7a
    % TODO:
    % Validate i authorizes use of key pointed to by p			% 1
    IF t=scheme(mkAuth)							% 2
    THEN OUT_Error(TPM_BAD_MODE)
    ELSIF migratable(keyFlags(p))=TRUE					% 3
    THEN OUT_Error(TPM_BAD_KEY_PROPERTY)
    % TODO:
    % Verify digest within mkAuth is legal for ths tpm and public key	% 5
    % Verify d1->payload = Migrate_restricted or migrate_external 	% 6
    % Verify mig authorities in msaList are authorized to migrate this key % 7
    ELSIF migrationAuth(d1)/=tpmHMAC(M2,s`permData`tpmProof)
    THEN OUT_Error(TPM_MA_AUTHORITY)					% 7b
    ELSE CASES migScheme(scheme(mkAuth)) OF
    	   restrictMigrate: 						% 8
    	      % TODO:
	      %Verify intended migration destination is MA:
	      %IF member(SHA1(key(mkAuth)),migAuthDigest(msaList))	% 8a
	      %   RSA?(algoId(algoParms(key(mkAuth)))) 			% 8bi
	      %TODO							% 8biii
	      CMKCreateBlobOut2(s,p,mkAuth,psk,msaList,d1,i),
    	   restrictApprove:						% 9
	      %TODO: 9i
	      % LET V1=tpmCMKSigTicket(migAuthDigest(msaList),SHA1(resTic)
	      %IF member(,migAuthDigest(msaList)) 
	      %OUT_Error(TPM_MA_DESTINATION) OUT_Error(TPM_MA_SOURCE)
	      CMKCreateBlobOut2(s,p,mkAuth,psk,msaList,d1,i)
	   ELSE OUT_Error(TPM_BAD_PARAMETER)				% 10
    	 ENDCASES
    ENDIF;

  CMKConvertMigration?(s:tpmAbsState,p:(tpmKey?),r:(tpmCMKAuth?),m:(tpmKey?),
	l:(tpmMSAComposite?),o1:(OAEP?)) : bool =
    LET m1:(tpmMigrateAsymkey?)=OAEPdecode(o1),				% 5
	migratedPubKey=tpmPubkey(algoParms(m),key(m)) IN		% 6
    LET k1=partPrivKey(m1), %todo: should be seed & partprivkey		% 7
        M2=tpmCMKMigAuth(SHA1(l),SHA1(migratedPubKey)) IN		% 18
    LET d2=encrypt(tpmStoreAsymkey(usageAuth(m1),		     	% 8b
			%HMAC(M2,s`permData`tpmProof),			% 19
			tpmSecret(1),
			%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
			pubDataDigest(m1),k1)				% 8c,a
		   ,key(p)),						% 20
        parentPubKey=tpmPubkey(algoParms(p),key(p)) IN		   	% 12
    storage?(keyUsage(p)) AND						% 2
    pHash(o1)=SHA1(concat(SHA1(l),SHA1(migratedPubKey))) AND		% 6
    not(migratable(keyFlags(p))) AND				        % 9
    tpmMigrateAsymkey?(m1) AND	 					% 10
    destKey(r)=SHA1(parentPubKey) AND					% 13
    (private(m)=privKey(encData(d2)) AND
     pubDataDigest(encData(encDat(m)))=pubDataDigest(encData(d2)) AND
     usageAuth(encData(encDat(m)))=usageAuth(encData(d2))) AND		% 14
    migratable(keyFlags(m)) AND						% 15
    migrateAuthority(keyFlags(m)) AND					% 16
    sourceKey(r)=SHA1(migratedPubKey)					% 17

  CMKConvertMigrationState(s:tpmAbsState,p:(tpmKey?),resTic:(tpmCMKAuth?),
      sigTic:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),rand:(RNG?),
      i:authIn) : tpmAbsState =
    LET d1=decrypt(encDat(mk),private(p),s`keys) IN  			% 3
    LET o1=unXOR(d1,rand) IN    					% 4
    IF not CMKConvertMigration?(s,p,resTic,mk,msaList,o1)
    THEN s
    ELSE LET m1:(tpmMigrateAsymkey?)=OAEPdecode(o1),%TODO 		% 5
	          migratedPubKey=tpmPubkey(algoParms(mk),key(mk)) IN	% 6
    	 LET k1=partPrivKey(m1), %todo: should be seed & partprivkey	% 7
             M2=tpmCMKMigAuth(SHA1(msaList),SHA1(migratedPubKey)) IN	% 18
    	 LET d2=encrypt(tpmStoreAsymkey(usageAuth(m1),		  	% 8b
					%HMAC(M2,s`permData`tpmProof),	% 19
					tpmSecret(1),
					%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
					pubDataDigest(m1),k1),		% 8c,a
		   		key(p)) IN				% 20
	     s WITH [`outData:=cons(d2,outData(s))]
    ENDIF;

  CMKConvertMigrationOut(s:tpmAbsState,p:(tpmKey?),resTic:(tpmCMKAuth?),
      sigTic:(tpmDigest?),mk:(tpmKey?),msaList:(tpmMSAComposite?),rand:(RNG?),
      i:authIn) : tpmAbsOutput =
    %TODO: Validate authdata to use key in p				% 1
    LET d1=decrypt(encDat(mk),private(p),s`keys) IN  			% 3
    LET o1=unXOR(d1,rand) IN    					% 4
    LET m1:(tpmMigrateAsymkey?)=OAEPdecode(o1),%TODO 			% 5
	migratedPubKey=tpmPubkey(algoParms(mk),key(mk)) IN		% 6
    LET k1=partPrivKey(m1), %todo: should be seed & partprivkey		% 7
        M2=tpmCMKMigAuth(SHA1(msaList),SHA1(migratedPubKey)) IN		% 18
    LET d2=encrypt(tpmStoreAsymkey(usageAuth(m1),		     	% 8b
				%HMAC(M2,s`permData`tpmProof),		% 19
				tpmSecret(1),
				%TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				pubDataDigest(m1),k1),			% 8c,a
		   key(p)) IN						% 20
    LET parentPubKey=tpmPubkey(algoParms(p),key(p)) IN			% 12
    	IF not(storage?(keyUsage(p)))					% 2
    	THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    	ELSIF pHash(o1)/=
			SHA1(concat(SHA1(msaList),SHA1(migratedPubKey)))% 6a
    	THEN OUT_Error(TPM_SHA_ERROR) %TODO
    	ELSIF migratable(keyFlags(p))					% 9
    	THEN  OUT_Error(TPM_BAD_KEY_PROPERTY)
    	ELSIF not tpmMigrateAsymkey?(m1)	
	THEN OUT_Error(TPM_BAD_MIGRATION) %TODO: made up which error	% 10
    	% TODO 11
    	ELSIF destKey(resTic)/=SHA1(parentPubKey)			% 13
    	THEN OUT_Error(TPM_MA_DESTINATION)
    	ELSIF not(private(mk)=privKey(encData(d2)) AND
    	       	  pubDataDigest(encData(encDat(mk)))=
				pubDataDigest(encData(d2)) AND
		  usageAuth(encData(encDat(mk)))=
				usageAuth(encData(d2)))			% 14
    	THEN OUT_Error(TPM_BAD_KEY_PROPERTY) %TODO
    	ELSIF not(migratable(keyFlags(mk))) OR				% 15
    	       	   not(migrateAuthority(keyFlags(mk)))			% 16
    	THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    	ELSIF sourceKey(resTic)/=SHA1(migratedPubKey)			% 17
    	THEN OUT_Error(TPM_MA_SOURCE)
    	ELSE LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(p)))#) IN % TODO
		  OUT_CMK_ConvertMigration(d2,a,TPM_SUCCESS)
    	ENDIF;

  %% Cryptographic Functions (13)
  SHA1CompleteState(s:tpmAbsState,hd:tpmData) : tpmAbsState =
    s WITH [`outData:=cons(SHA1(hd),outData(s))];

  SHA1CompleteOut(hd:tpmData) : tpmAbsOutput =
    OUT_SHA1Complete(SHA1(hd),TPM_SUCCESS)

  SHA1CompleteExtend?(s:tpmAbsState,p:PCRINDEX,inDigest:tpmData) : bool =
    LET L1=s`stanyFlags`localityModifier,
    	P1=pcrExtendLocal(s`permData`pcrAttrib(p)) IN
    (0<=p<=23) AND member(L1,P1);

  SHA1CompleteExtendState(s:tpmAbsState,p:PCRINDEX,hd:tpmData) : tpmAbsState =
    IF SHA1CompleteExtend?(s,p,hd)
    THEN LET H1:HV=mleHash IN %TODO
    	 s WITH [`pcrs := pcrsExtend(pcrs(s),p,H1)
	   	,`outData:=cons(tpmPCRValue(extend(s`pcrs(p),H1)),
				cons(SHA1(hd),outData(s)))]
    ELSE s
    ENDIF

  SHA1CompleteExtendOut(s:tpmAbsState,p:PCRINDEX,hd:tpmData) : tpmAbsOutput =
    IF 0<=p<=23
    THEN LET L1=s`stanyFlags`localityModifier,				% 7
             P1=pcrExtendLocal(s`permData`pcrAttrib(p)) IN
    	 IF not member(L1,P1)						% 8
	 THEN OUT_Error(TPM_BAD_LOCALITY)
	 ELSE LET H1:HV=mleHash IN %TODO				% 9
	      OUT_SHA1CompleteExtend(SHA1(hd),
			tpmPCRValue(extend(s`pcrs(p),H1)),		% 10
			TPM_SUCCESS)
	 ENDIF
    ELSE OUT_Error(TPM_BADINDEX)
    ENDIF

  sign?(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : bool = 
    signing?(keyUsage(key)) OR legacy?(keyUsage(key))

  signState(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : tpmAbsState=
    IF not sign?(s,key,areaToSign)
    THEN s
    ELSIF not(member(private(key),vals(s`keys))) OR cryptoError?(areaToSign)
    THEN s
    ELSE s WITH[`outData:=cons(sign(areaToSign,private(key),s`keys),outData(s))]
    ENDIF;

  % Sign a blob if signing key isn't aik
  % TODO: add signature scheme (makes this more complicated)
  signOut(s:tpmAbsState,key:(tpmKey?),areaToSign:tpmData) : tpmAbsOutput=
    IF signing?(keyUsage(key)) OR legacy?(keyUsage(key)) 
    THEN IF member(private(key),vals(s`keys)) and not(cryptoError?(areaToSign))
    	 THEN OUT_Sign(sign(areaToSign,private(key),s`keys),TPM_SUCCESS)
	 ELSE OUT_CPUError(CPU_SIGN_ERROR)
	 ENDIF
    ELSE OUT_Error(TPM_INVALID_KEYUSAGE)
    ENDIF;

  getRandomState(s:tpmAbsState) : tpmAbsState = 
    s WITH [`outData:=cons(RNG(s`randCnt),outData(s))];

  getRandomOut(s:tpmAbsState) : tpmAbsOutput = 
    OUT_GetRandom(RNG(s`randCnt),TPM_SUCCESS);


  stirRandomState(s:tpmAbsState,inData:nat) : tpmAbsState = 
    s WITH [`randCnt:=randCnt(s)+inData]

  stirRandomOut(s:tpmAbsState,inData:int) : tpmAbsOutput = 
    %If size(inData)>=256 OUT_Error(TPM_BAD_PARAMETER)
    OUT_StirRandom(TPM_SUCCESS);


  certifyKey?(s:tpmAbsState,c,k:(tpmKey?)) : bool = 
    IF identity?(keyUsage(c)) AND migratable(keyFlags(c))
    THEN FALSE					% 4a
    ELSIF not(signing?(keyUsage(c)) OR identity?(keyUsage(c)) OR
    	  	legacy?(keyUsage(c)))
    THEN FALSE				% 5
    ELSIF not(signing?(keyUsage(k)) OR storage?(keyUsage(k)) OR
    	  	identity?(keyUsage(k)) OR bind?(keyUsage(k)) OR
		legacy?(keyUsage(k)))
    THEN FALSE				% 6
    %TODO: Version 							% 7,8
    % pcrInfoSize(key)=0 => PCRInfo(k)=pcrInfoNull			% 9/10
    ELSIF pcrIgnoredOnRead(keyFlags(k))=FALSE				% 9a
    THEN LET dAR=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(PCRInfo(k)),
				   s`pcrs)) IN
	 IF dAR/=digAtRelease(PCRInfo(k))				% 9ai
	 THEN FALSE	
	 ELSE %If specified, validate any locality requests 
	      % On error OUT_Error(TPM_BAD_LOCALITY)			% 9aii
	      true				% 9b
	 ENDIF
    ELSE true					% 9b
    ENDIF

  certifyKeyOut2(c,k:(tpmKey?),ar:(tpmNonce?),i1,i2:authIn) : tpmAbsOutput =
    CASES k OF
      tpmKey(k,u,f,ad,al,p,e) : 
	LET H1=SHA1(k) IN %TODO						% 11
	LET C1=tpmCertifyInfo(u,f,ad,al,				% 9c
				H1,					% 12
				ar,					% 13
				FALSE,%TODO!				
				p) IN				    % 9civ,10
       LET m1=SHA1(C1),			 				% 15 
           o1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(c)))#), % TODO
           o2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#) IN %TODO
       OUT_CertifyKey(C1,signed(m1,private(c)),	%TODO FIX		% 14
			o1,o2,TPM_SUCCESS)
    ENDCASES

  certifyKeyState(s:tpmAbsState,c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) :
  	tpmAbsState = 
    IF not certifyKey?(s,c,k)
    THEN s
    ELSE LET out=certifyKeyOut2(c,k,n,i1,i2) IN
         CASES out OF
         OUT_CertifyKey(c,od,o1,o2,m) : 
       		s WITH [`outData:=cons(c,cons(od,outData(s)))]
         ENDCASES
    ENDIF

  certifyKeyOut(s:tpmAbsState,c,k:(tpmKey?),ar:(tpmNonce?),i1,i2:authIn) : 
  	tpmAbsOutput = 
    %TODO: Verify c has sig scheme of _SHA1 or _INFO			% 1
    %TODO: Verify command and key AuthData values			% 2
    %TODO: If not asym?(payload(k)) THEN OUT_ERROR(TPM_INVALID_KEYUSAGE)% 3
    IF identity?(keyUsage(c)) AND migratable(keyFlags(c))
    THEN OUT_Error(TPM_MIGRATEFAIL)					% 4a
    ELSIF not(signing?(keyUsage(c)) OR identity?(keyUsage(c)) OR
    	  	legacy?(keyUsage(c)))
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 5
    ELSIF not(signing?(keyUsage(k)) OR storage?(keyUsage(k)) OR
    	  	identity?(keyUsage(k)) OR bind?(keyUsage(k)) OR
		legacy?(keyUsage(k)))
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 6
    %TODO: Version 							% 7,8
    % pcrInfoSize(key)=0 => PCRInfo(k)=pcrInfoNull			% 9/10
    ELSIF pcrIgnoredOnRead(keyFlags(k))=FALSE				% 9a
    THEN LET dAR=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(PCRInfo(k)),
				   s`pcrs)) IN
	 IF dAR/=digAtRelease(PCRInfo(k))				% 9ai
	 THEN OUT_Error(TPM_WRONGPCRVAL)	
	 ELSE %If specified, validate any locality requests 
	      % On error OUT_Error(TPM_BAD_LOCALITY)			% 9aii
	      certifyKeyOut2(c,k,ar,i1,i2)				% 9b
	 ENDIF
    ELSE certifyKeyOut2(c,k,ar,i1,i2)					% 9b
    ENDIF

  createEKPairState(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?)) : tpmAbsState = 
    IF goodkey?(key(ek(s)))				       		% 1
    THEN s
    ELSE s WITH [`ek:=k							% 5
%     	   	,`permData(tpmDAASeed):=rand				% 6
% 		,`permData(daaProof):=rand				% 7
% 		,`permData(daaBlobKey):=rand				% 8
    	   	,`permFlags(CEKPUsed):=TRUE				% 9
		,`permFlags(enableRevokeEK):=FALSE			% 10
		,`outData:=cons(k,cons(SHA1(concat(k,r)),outData(s)))]
    ENDIF;

  % If ek doesn't exist, create a new ek from keyInfo
  createEKPairOut(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?)) : tpmAbsOutput = 
    IF goodkey?(key(s`ek))				     		% 1
    THEN OUT_Error(TPM_DISABLED_CMD)
    % Validate k parameters for key description?			% 2
%     ELSIF RSA?(algoId(algoParms(k))) AND length(k)<2048		% 2b
%     THEN OUT_Error(TPM
    ELSE LET checksum=SHA1(concat(k,r)) IN				% 4
    	 OUT_CreateEndorsementKeyPair(k,checksum,TPM_SUCCESS)		% 3
    ENDIF;

  createRevEKState(s:tpmAbsState,antiReplay:(tpmNonce?),keyInfo:(tpmKey?),
	generateReset:bool,inputEKreset:(tpmNonce?)) : tpmAbsState =
    IF goodkey?(key(s`ek))
    THEN s
    ELSE LET s1=createEKPairState(s,antiReplay,keyInfo),
    	     o1=createEKPairOut(s,antiReplay,keyInfo) IN
	 CASES o1 OF
	 OUT_CreateEndorsementKeyPair(e,c,m) :
    	 s1 WITH [`permFlags(enableRevokeEK):=TRUE			% 3
	     	 ,`permData(ekReset):=IF generateReset 
				      THEN tpmNonce(n(RNG(s`randCnt)))	% 3a
				      ELSE inputEKreset			% 3b
				      ENDIF
		,`outData:=cons(tpmPubkey(algoParms(e),key(e)),
				cons(c,cons(IF generateReset 
					  THEN tpmNonce(n(RNG(s`randCnt)))% 3a
			   		  ELSE inputEKreset ENDIF,	% 3b
					 outData(s))))
		,`randCnt:=randCnt(s)+1] % may not need it, but just in case
	ELSE s
	ENDCASES
    ENDIF;
    
  createRevEKOut(s:tpmAbsState,r:(tpmNonce?),k:(tpmKey?),genReset:bool,
	i:(tpmNonce?)) : tpmAbsOutput = 
    IF goodkey?(key(s`ek))						% 1
    THEN OUT_Error(TPM_DISABLED_CMD) 
    ELSE LET o1=createEKPairOut(s,r,k) IN				% 2
    	 CASES o1 OF
	 OUT_CreateEndorsementKeyPair(e,c,m) :
	 	OUT_CreateRevocableEK(tpmPubkey(algoParms(e),key(e)),c,	% 4
			IF genReset THEN tpmNonce(n(RNG(s`randCnt)))	% 3a
			   ELSE i ENDIF,				% 3b
			TPM_SUCCESS)
	ELSE o1								% 2
	ENDCASES
    ENDIF;

  revokeTrust?(s:tpmAbsState,ekReset:(tpmNonce?)) : bool =
    s`permFlags`enableRevokeEK AND s`permData`ekReset=ekReset AND
    	s`stclearFlags`physicalPresence

  revokeTrustState(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsState = 
    IF s`permFlags`enableRevokeEK AND ekReset(permData(s))=ekReset AND	% 1,2
       s`stclearFlags`physicalPresence					% 3
    THEN LET s1 = clear(s) IN						% 4
	 %TODO NV items with pubInfo->nvIndex D value must be deleted	% 4a
	 s1 WITH [`permFlags(nvLocked):=FALSE,				% 4b
% 	      	  `permData(tpmDAASeed):=,				% 5
% 		  `permData(daaProof):=,				% 6
% 		  `permData(daaBlobKey):=,				% 7
		  `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),		% 8
			      authDataUsage(s`ek),algoParms(s`ek),
			      PCRInfo(s`ek),encDat(s`ek))
		 ]
	% TODO: invalidate any internal state associated with EK	% 8
    ELSE s
    ENDIF;

  revokeTrustOut(s:tpmAbsState,ekReset:(tpmNonce?)) : tpmAbsOutput =
    IF not s`permFlags`enableRevokeEK					% 1
    THEN OUT_Error(TPM_PERMANENTEK)				 
    ELSIF not s`permData`ekReset=ekReset				% 2
    THEN OUT_Error(TPM_AUTHFAIL) 
    ELSIF not s`stclearFlags`physicalPresence				% 3
    THEN OUT_Error(TPM_BAD_MODE)     % todo: check
    ELSE OUT_RevokeTrust(TPM_SUCCESS)
    ENDIF;

  readPubek?(s:tpmAbsState,n:(tpmNonce?)) : bool = 
    readPubek(permFlags(s)) AND goodkey?(key(ek(s)))

  readPubekOut(s:tpmAbsState,n:(tpmNonce?)) : tpmAbsOutput =
    IF not s`permFlags`readPubek					% 1
    THEN OUT_Error(TPM_DISABLED_CMD)
    ELSIF not goodkey?(key(ek(s)))					% 2
    THEN OUT_Error(TPM_NO_ENDORSEMENT)
    ELSE LET pubEK=ek(s) IN
    	 LET checksum=SHA1(concat(pubEK,n)) IN				% 3
    	 OUT_ReadPubek(pubEK,checksum,TPM_SUCCESS)			% 4
    ENDIF;


  ownerReadInternalPubState(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsState = 
    LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN
    IF key(k)=ekKeyVal							% 2
    THEN s WITH [`outData:=cons(tpmPubkey(algoParms(k),key(k)),outData(s))]
    ELSIF key(k)=srkKeyVal						% 3  
    THEN s WITH [`outData:=cons(tpmPubkey(algoParms(k),key(k)),outData(s))]
    ELSE s								% 4
    ENDIF;  
    
  ownerReadInternalPubOut(s:tpmAbsState,k:(tpmKey?),a:authIn) : tpmAbsOutput = 
      % Validate the params and TPM Owner AuthData for this command	% 1
    LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(a)#) IN
    IF key(k)=ekKeyVal							% 2
    THEN OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,TPM_SUCCESS)
    ELSIF key(k)=srkKeyVal						% 3  
    THEN OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,TPM_SUCCESS)
    ELSE OUT_Error(TPM_BAD_PARAMETER)					% 4
    ENDIF;  


  makeIdentity?(s:tpmAbsState,k:(tpmKey?)):bool=
    identity?(keyUsage(k)) AND not(migratable(keyFlags(k)))
    AND not(s`permFlags`FIPS AND never?(authDataUsage(k)))

  setDigAtCreation(s:tpmAbsState,pcr:(tpmPCRInfoLong?)) : (tpmCompositeHash?) =
    LET digest=tpmPCRComposite(creationPCRSelect(pcr),		% 9
    			       pcrs(s))
    IN tpmCompositeHash(digest);

  makeIdentityLocality : LOCALITY

  makeIdentityState(s:tpmAbsState,iA:(tpmEncAuth?),CADig:(tpmDigest?),
	k:(tpmKey?),i1,i2:authIn) : tpmAbsState = 
    IF makeIdentity?(s,k) AND member(private(k),vals(s`keys))
    THEN LET a1=decryptADIP(iA,authHandle(i2)) IN			% 6
         LET pcr=tpmPCRInfoLong(makeIdentityLocality,			% 9
			locAtRelease(PCRInfo(k)),
			creationPCRSelect(PCRInfo(k)),
			releasePCRSelect(PCRInfo(k)),
			setDigAtCreation(s,PCRInfo(k)),			% 9
			digAtRelease(PCRInfo(k))),
	     encData=encrypt(tpmStoreAsymkey(a1,			% 11
				s`permData`tpmProof,			% 13
				pubDataDigest(encData(encDat(k))),
				private(k)),
			key(s`srk)) IN					% 15
      	LET idKey=tpmKey(s`keyGenCnt,					% 8
	    		keyUsage(k),
			keyFlags(k),
			authDataUsage(k),
			algoParms(k),
			pcr,
			encData) IN 
	LET idBind=sign(tpmIdContents(CADig,idKey),			% 16
			  private(idKey),s`keys) IN			% 17
    	 genKeyState(s) WITH [`outData:=cons(idKey,cons(idBind,outData(s)))]
    ELSE s
    ENDIF;

  % Output a newly generated AIK.  Note that a simulates the new aik.
  makeIdentityOut(s:tpmAbsState,iA:(tpmEncAuth?),CADig:(tpmDigest?),k:(tpmKey?),
	i1,i2:authIn) : tpmAbsOutput =
    % validate k params for key description				% 1
    % IF RSA?(algoId(algoParms(srk))) AND length(k) < 2048		% 1a
    %   OR if alg type not RSA, strength comparable to RSA 2048		% 1b
    % THEN OUT_Error(TPM_BAD_KEY_PROPERTY)				% 1c
    IF s`permFlags`FIPS AND never?(authDataUsage(k))			% 1d
    THEN OUT_Error(TPM_NOTFIPS)						% 1di
    % Use authHandle(i2) to verify Owner authorized input params	% 2
    % use authHandle(i1) to verify SRK owner authorized input params	% 3
    ELSIF not(identity?(keyUsage(k))) OR migratable(keyFlags(k))	% 4,5
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSE LET a1=decryptADIP(iA,authHandle(i2)),			% 6
    	     o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 7
			resAuth:=usageAuth(encData(encDat(s`srk)))#),
	     o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 7
			resAuth:=ownerAuth(i2)#) IN
         LET pcr=tpmPCRInfoLong(makeIdentityLocality,			% 9
			locAtRelease(PCRInfo(k)),
			creationPCRSelect(PCRInfo(k)),
			releasePCRSelect(PCRInfo(k)),
			setDigAtCreation(s,PCRInfo(k)),			% 9
			digAtRelease(PCRInfo(k))),
	     encData=encrypt(tpmStoreAsymkey(a1,			% 11
				s`permData`tpmProof,			% 13
				pubDataDigest(encData(encDat(k))),
				private(k)),
			key(s`srk)) IN					% 15
      	LET idKey=tpmKey(keyGenCnt(s),					% 8
	    		keyUsage(k),
			keyFlags(k),
			authDataUsage(k),
			algoParms(k),
			pcr,
			encData) IN 
	LET idBind=sign(tpmIdContents(CADig,idKey),			% 16
			  private(idKey),s`keys) IN			% 17
	IF cryptoError?(idBind)
	THEN OUT_CPUError(CPU_SIGN_ERROR)
	ELSE OUT_MakeIdentity(idKey,idBind,o1,o2,TPM_SUCCESS)
	ENDIF
    ENDIF;

  activateIdentity?(s:tpmAbsState,i:(tpmKey?),b:(encrypted?)) : bool=
    %Validate owners AuthData using authHandle(a1) to execute cmd & params  % 1
    %Use authHandle(a2) to validate the AuthData to execute cmd& params	% 2
    LET h1=tpmDigest(cons(tpmPubkey(algoParms(i),key(i)),null)), 	% 4
	b1=decrypt(b,private(s`ek),s`keys) IN				% 5
    IF not identity?(keyUsage(i)) 
    THEN FALSE								% 3
    ELSE CASES b1 OF			  				% 6
	 tpmEKBlob(blob) :						% 6ai
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :	
			LET C1=tpmCompositeHash(
					tpmPCRComposite(pcrSelect(p),	% 8di
    			        		s`pcrs)) IN
			IF h1/=d					% 8c
			THEN FALSE
			ELSIF not(null?(pcrSelect(p)))			% 8d
			      AND C1/=digAtRelease(p)
			THEN FALSE					% 8dii
			ELSIF not member(s`locality,locAtRelease(p))
			THEN FALSE					% 8e
			ELSE TRUE					% 8f
			ENDIF
		ELSE FALSE						% 8a
		ENDCASES,
	 tpmAsymCAContents(k,d) : h1=d 					% 6bi,7
	 ELSE TRUE
	 ENDCASES
    ENDIF;

  activateIdentityState(s:tpmAbsState,idKey:(tpmKey?),b:(encrypted?),
	i1,i2:authIn) : tpmAbsState =
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(idKey)))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#),
	h1=tpmDigest(cons(tpmPubkey(algoParms(idKey),key(idKey)),null)),% 4
	b1=decrypt(b,private(s`ek),s`keys) IN				% 5
    IF not activateIdentity?(s,idKey,b)
    THEN s
    ELSE CASES b1 OF			  				% 6
	 tpmAsymCAContents(k,d) : 					% 6bi
	 	IF h1=d							% 7
		THEN s WITH [`outData:=cons(k,outData(s))]		% 7b,9
		ELSE s							% 
		ENDIF,
	 tpmEKBlob(blob) :						% 6ai
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :	
			LET C1=tpmCompositeHash(
					tpmPCRComposite(pcrSelect(p),	% 8di
    			        			pcrs(s))) IN
			IF h1/=d					% 8c
			THEN s
			ELSIF not(null?(pcrSelect(p)))			% 8d
			      AND C1/=digAtRelease(p)
			THEN s						% 8dii
			ELSIF not member(s`locality,locAtRelease(p))
			THEN s						% 8e
			ELSE s WITH [`outData:=cons(k,outData(s))]	% 8f
			ENDIF
		ELSE s							% 8a
		ENDCASES
    	 ELSE s WITH [`outData:=cons(badData,outData(s))]
	 ENDCASES
    ENDIF;

  % Retrieve a key if a can be installed
  % The cmd assumes the availability of the priv key associated with th identity
  % The cmd will verify the association between the keys during the process.
  % The cmd will decrypt the input blob and extract the sess key and verify
  % the connection between the public and private keys. p 157
  activateIdentityOut(s:tpmAbsState,idKey:(tpmKey?),b:(encrypted?),
	i1,i2:authIn) : tpmAbsOutput =
    %Validate owners AuthData using authHandle(a1) to execute cmd & params  % 1
    %Use authHandle(a2) to validate the AuthData to execute cmd& params	% 2
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(idKey)))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#),
	h1=tpmDigest(cons(tpmPubkey(algoParms(idKey),key(idKey)),null)),% 4
	b1=decrypt(b,private(s`ek),s`keys) IN				% 5
    IF not identity?(keyUsage(idKey)) 
    THEN OUT_Error(TPM_BAD_PARAMETER)					% 3
    ELSE CASES b1 OF			  				% 6
	 tpmEKBlob(blob) :						% 6ai
	 	CASES blob OF
	 	tpmEKBlobActivate(k,d,p) :	
			LET C1=tpmCompositeHash(
					tpmPCRComposite(pcrSelect(p),	% 8di
    			        		pcrs(s))) IN
			IF h1/=d					% 8c
			THEN OUT_Error(TPM_BAD_PARAMETER)
			ELSIF not(null?(pcrSelect(p)))			% 8d
			      AND C1/=digAtRelease(p)
			THEN OUT_Error(TPM_WRONGPCRVAL)			% 8dii
			ELSIF not member(s`locality,locAtRelease(p))
			THEN OUT_Error(TPM_BAD_LOCALITY)		% 8e
			ELSE OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS)	% 8f
			ENDIF
		ELSE OUT_Error(TPM_BAD_TYPE)				% 8a
		ENDCASES,
	 tpmAsymCAContents(k,d) : 					% 6bi
	 	IF h1=d							% 7
		THEN OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS)		% 7b,9
		ELSE OUT_Error(TPM_BAD_PARAMETER)			% 7a
		ENDIF
	 ELSE OUT_ActivateIdentity(badData,o1 WITH [`resAuth:=badData],
	      			o2,TPM_SUCCESS)	
	 ENDCASES
    ENDIF;
        
  % For PCRS hashing is pcrsExtend instead of tpmDigest
  extend?(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : bool =
    LET L1=s`stanyFlags`localityModifier,				% 2
    	P1=pcrExtendLocal(s`permData`pcrAttrib(pcrNum)) IN		% 3
    (0<=pcrNum<=23) AND member(L1,P1);

  %% Extend operation on TPM state
  extendState(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsState =
    IF not extend?(s,pcrNum,inDigest)
    THEN s 
    ELSE LET s1=s WITH [`pcrs := pcrsExtend(pcrs(s),pcrNum,inDigest)] IN% 7
         IF s`permFlags`disable OR s`stclearFlags`deactivated		% 8
	 THEN s1 
	 ELSE s1 WITH [`outData:=cons(tpmPCRValue(extend(s`pcrs(pcrNum),
							inDigest)),
					outData(s1))]
	 ENDIF
    ENDIF;

  extendOut(s:tpmAbsState,pcrNum:PCRINDEX,inDigest:HV) : tpmAbsOutput = 
    LET L1=s`stanyFlags`localityModifier,				% 2
    	P1=pcrExtendLocal(s`permData`pcrAttrib(pcrNum)),		% 3
	H1=pcrsExtend(s`pcrs,pcrNum,inDigest) IN			% 4
    IF pcrNum > 23 OR pcrNum < 0
    THEN OUT_Error(TPM_BADINDEX)					% 1
    ELSIF not member(L1,P1)						% 4
    THEN OUT_Error(TPM_BAD_LOCALITY)
    ELSIF s`permFlags`disable OR s`stclearFlags`deactivated		% 8
    THEN OUT_Extend(tpmPCRValue(reset),TPM_SUCCESS)			% 8a
    ELSE OUT_Extend(tpmPCRValue(extend(s`pcrs(pcrNum),inDigest)),
			TPM_SUCCESS)					% 9a
    ENDIF    

  pcrReadState(s:tpmAbsState,ind:PCRINDEX) : tpmAbsState  =
    IF ind > 23 OR ind < 0
    THEN s								% 1
    ELSE LET p=s`pcrs IN 						% 2
    	 s WITH [`outData:=cons(tpmPCRValue(p(ind)),outData(s))]	% 3
    ENDIF

  % Output PCR of given index
  pcrReadOut(s:tpmAbsState,ind:PCRINDEX) : tpmAbsOutput = 
    IF ind > 23 OR ind < 0
    THEN OUT_Error(TPM_BADINDEX)					% 1
    ELSE LET p=s`pcrs IN 						% 2
    	 OUT_PCRRead(tpmPCRValue(p(ind)),TPM_SUCCESS)			% 3
    ENDIF

  % Output PCRs from a state as quote
  quote?(k:(tpmKey?)) : bool = 
    signing?(keyUsage(k)) OR identity?(keyUsage(k)) OR legacy?(keyUsage(k))

  quoteState(s:tpmAbsState,k:(tpmKey?),extDat:(tpmNonce?),p:PCR_SELECTION,
  	i:authIn) : tpmAbsState =
    IF not quote?(k)
    THEN s
    ELSIF not(member(private(k),vals(s`keys)))
    THEN s
    ELSE %Validate p is valid PCR_SELECTION structure			% 4
         LET H1=tpmCompositeHash(tpmPCRComposite(p,s`pcrs)),		% 5
%             pcrData=getPCRs(s`pcrs,p) IN				
             pcrData=tpmPCRComposite(p,s`pcrs) IN				
	     %TODO: add pcrData !!
	 s WITH [`outData:=cons(sign(tpmQuote(H1,			% 6c
			    		extDat),			% 6d
			  		private(k),s`keys),		% 7,8
				cons(pcrData,outData(s)))]
    ENDIF;

  quoteOut(s:tpmAbsState,k:(tpmKey?),extDat:(tpmNonce?),p:PCR_SELECTION,
  	i:authIn) : tpmAbsOutput =
    % Validate AuthData to use key pointed to by k			% 1
    % IF not(SHA1?(sigScheme(k))) OR not(INFO?(sigScheme(k)))		% 2
    % THEN OUT_Error(TPM_INAPPROPRIATE_SIG)
    IF not quote?(k)
    THEN OUT_Error(TPM_INVALID_KEYUSAGE)
    ELSIF not(member(private(k),vals(s`keys)))
    THEN OUT_CPUError(CPU_SIGN_ERROR)
    ELSE %Validate p is valid PCR_SELECTION structure			% 4
         LET H1=tpmCompositeHash(tpmPCRComposite(p,s`pcrs)),		% 5
%             pcrData=getPCRs(s`pcrs,p) IN				
             pcrData=tpmPCRComposite(p,s`pcrs) IN				
	 OUT_Quote(pcrData,
		   sign(tpmQuote(H1,					% 6c
			    extDat),					% 6d
			  private(k),s`keys),				% 7,8
		  (#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#),
		  TPM_SUCCESS)
    ENDIF;


  validatePCRVals(s:tpmAbsState,pcrSelect:PCR_SELECTION) : RECURSIVE nat =
    LET L1=s`stanyFlags`localityModifier,				% 2
    	sum:nat=0 IN
    CASES pcrSelect OF
    	  null : 0,
	  cons(x,xs) : 
	      IF not pcrReset(s`permData`pcrAttrib(x))
	      THEN 1							% 3a
	      ELSIF not member(L1,pcrResetLocal(s`permData`pcrAttrib(x)))
	      THEN 2							% 3b
	      ELSE validatePCRVals(s,xs)
	      ENDIF
    ENDCASES		  
    measure pcrSelect by <<

  % induct on select, grind
  validatePCRs : LEMMA
    FORALL (s:tpmAbsState,select:PCR_SELECTION) : 
    LET a=validatePCRVals(s,select) IN
	a=0 OR a=1 or a=2

  check_validatePcrs: THEOREM
  FORALL (state:tpmAbsState) : 
  LET s:tpmAbsState=tpmStartup(state) WITH 
      		[`permData(pcrAttrib)(6):=(#pcrReset:=true
					   ,pcrResetLocal:=cons(2,null)
					   ,pcrExtendLocal:=allLocs#)],
      p:PCR_SELECTION=cons(5,cons(6,null)) IN
      validatePCRVals(s,p)=2;

  pcrResetState(s:tpmAbsState,pcrSelect:PCR_SELECTION) : tpmAbsState  =
    IF null?(pcrSelect)							% 1b
    THEN s								% 1c
    ELSE LET num=validatePCRVals(s,pcrSelect) IN
      	 COND
      	 num=0 -> s WITH [`pcrs:=pcrsResetSelection(s`pcrs,pcrSelect)],	% 4a
      	 ELSE -> s
      	 ENDCOND
    ENDIF;

  pcrResetOut(s:tpmAbsState,pcrSelect:PCR_SELECTION) : tpmAbsOutput = 
    IF null?(pcrSelect)							% 1b
    THEN OUT_Error(TPM_INVALID_PCR_INFO)				% 1c
    ELSE LET num=validatePCRVals(s,pcrSelect) IN
      	 COND
      	 num=0 -> OUT_PCR_Reset(TPM_SUCCESS),				% 
      	 num=1 -> OUT_Error(TPM_NOTRESETABLE),				% 3a
      	 num=2 -> OUT_Error(TPM_NOTLOCAL),				% 3b
	 ELSE -> OUT_Error(TPM_SUCCESS)
      	 ENDCOND
    ENDIF;
  
  changeAuthOut2(s,d:(tpmSecret?),i:authIn) : (tpmSecret?) = 
    % TODO: Validate the command using ownerAuth(i)			% 10b
    d % IF valid, return d, else ?
    
  changeAuthState(s:tpmAbsState,p:(tpmKey?),newA:(tpmEncAuth?),d:(encrypted?),
	i1,i2:authIn) : tpmAbsState = 
    IF tpmKey?(d) OR tpmStoredData?(d) 	      	   			% 5
    THEN LET decryptAuth=decryptADIP(newA,authHandle(i1)) IN		% 6
    	 % VALIDATE command using authdata in ownerAuth(i1)		% 7
	 IF not storage?(keyUsage(p))	   
	 THEN s								% 8
	 ELSE LET b1=decrypt(d,private(p),s`keys) IN			% 9
	      CASES b1 OF	       					% 10
	      tpmStoreAsymkey(u,m,v,k) : 
		s WITH [`outData:=cons(encrypt(tpmStoreAsymkey(
					changeAuthOut2(u,decryptAuth,i2),% 10,11
					m,v,k),
				  key(p)),outData(s))],			% 12
	      tpmSealedData(a,f,e,d) : 
		s WITH [`outData:=cons(encrypt(tpmSealedData(
					changeAuthOut2(a,decryptAuth,i2),% 10,11
					f,e,d),
				  key(p)),outData(s))]			% 12
%	      ELSE s							% 10a
	      ENDCASES

	 ENDIF
    ELSE s							% TODO: check
    ENDIF;

  changeAuthOut(s:tpmAbsState,p:(tpmKey?),newA:(tpmEncAuth?),d:(encrypted?),
	i1,i2:authIn) : tpmAbsOutput = 
    %IF not (DATA?(et) OR KEY?(et)) THEN OUT_Error(TPM_WRONG_ENTITYTYPE) % 1
    %IF not OSAP?(sessType(i1`authHandle) THEN OUT_Error(TPM_BAD_MODE)	 % 2
    %IF not OIAP?(sessType(i2`authHandle) THEN OUT_Error(TPM_BAD_MODE)	 % 3
    %IF not ACDP?(pi) THEN OUT_Error(TPM_BAD_PARAMETER)			 % 4
    IF tpmKey?(d) OR tpmStoredData?(d) 	      	   			% 5
    THEN LET decryptAuth=decryptADIP(newA,authHandle(i1)) IN		% 6
    	 % VALIDATE command using authdata in ownerAuth(i1)		% 7
	 IF not storage?(keyUsage(p))	   
	 THEN OUT_Error(TPM_INVALID_KEYUSAGE)				% 8
	 ELSE LET b1=decrypt(d,private(p),s`keys),			% 9
	      	  o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=usageAuth(encData(encDat(p)))#),
	      	  o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=ownerAuth(i2)#) IN
	      CASES b1 OF	       					% 10
	      tpmStoreAsymkey(u,m,v,k) : 
		OUT_ChangeAuth(encrypt(tpmStoreAsymkey(
					changeAuthOut2(u,decryptAuth,i2),% 10,11
					m,v,k),
				  key(p)),		% 12
				o1,o2,TPM_SUCCESS),
	      tpmSealedData(a,f,s,d) : 
		OUT_ChangeAuth(encrypt(tpmSealedData(
					changeAuthOut2(a,decryptAuth,i2),% 10,11
					f,s,d),
				  key(p)),		% 12
				o1,o2,TPM_SUCCESS)
	      ELSE OUT_Error(TPM_INVALID_STRUCTURE)			% 10a
	      ENDCASES
	 ENDIF
    ELSE OUT_Error(TPM_INVALID_STRUCTURE)			% TODO: check
    ENDIF
    % TODO: THe TPM MUST enforce the destruction of authHandle(i1) and 
    %  authHandle(i2) sessions						% 13

  OIAPState(s:tpmAbsState) : tpmAbsState
    

  OIAPOut(s:tpmAbsState) : tpmAbsOutput
%   oiapOut(s:tpmAbsState) : tpmAbsOutput =
%     % Verify the authorization session handle (H) referenced in the command(?) 
%     %  points to a valid session. if not OUT_Error(TPM_INVALID_AUTHHANDLE)  % 1
%     % Retrieve the latest version of caller's nonce (nonceOdd) and 
%     %  continueAuthSession flag from input parameter list, store it in internal 
%     %  tpm memory with authSession 'H' 	   	     	   	       % 2
%     % Retrieve the latest version of TPM's nonce stored with auth sess H 
%     %  (authLastNonceEven) computed during previously executed command. % 3
%     % Retrieve secret AuthData (SecretE) of target entity. Entity and secret 
%     %  must have been previously loaded into TPM.	   	      	% 4
%     % IF command using OIAP session requires owner authorization      	% 4a
%     LET secretE=
%     	IF s`stclearData`ownerReference=key(TPM_KH_OWNER)		% 4aii
% 	THEN s`permData`ownerAuth
% 	ELSE LET R1=s`stclearData`ownerReference IN			% 4aii1
% 	     LET D1=s`permData`delegateTable`delRow(R1) IN		% 4aii2
% 	     authValue(D1)						% 4aii3
% 	     % TODO: VALIDATE Stuff					% 4aii4
% 	ENDIF IN

  validate(H:(tpmAuthData?)) : bool

%   validateOIAPSession(s:tpmAbsState,targetEntity:authIn) : tpmAbsOutput = 
%     % Validate the authoirzation session handle H referenced in the command 
%     % 	       points to a valid session. Else TPM_INVALID_AUTHHANDLE	% 1
%     IF not validate(targetEntity`authHandle)
%     THEN OUT_Error(TPM_INVALID_AUTHHANDLE)
%     % The TPM shall retrieve the latest version of the caller's nonce (nonceOdd)
%     % 	  and continueAuthSession flag from the input param list, and store it 
%     %	  in internal tpm memory with authSession H   	    	        % 2
%     ELSE LET a=targetEntity`nonceOdd,
%     	     b=targetEntity`contAuthSess,
% 	     c=targetEntity`authHandle IN %TODO: store in internal TPM memory?
%     % The TPM shall retrieve the latest version of the TPM's nonce stored with 
%     % 	  the authorization session H (authLastNonceEven) computed during the 
%     % 	  previously executed command   	      	  	   	% 3
      
    % The TPM must retrieve the secret AuthData (SecretE) of the target entity.
    % 	   The entity and its secret must have been previously loaded into the 
    %	   TPM.       	      	     	       	    	       	      	% 4
    % If the command using the OIAP session requires owner authorization% a
    % IF s`stclearData`ownerReference = TPM_KH_OWNER, 
    % THEN LET SecretE=s`permData`ownerAuth				% 4ai
    % ELSIF s`stclearData`ownerReference -> delegate row		% 4aii
    % THEN LET R1:rowIndex:=s`stclearData`ownerReference IN		% 4aii1
    % 	   LET D1:delegate_table_row:=s`permData`delegateTable`delRow[R1]%4aii2
    % 	   LET SecretE:=D1`authValue IN					% 4aii3
    %	   Validate D1`pub`permissions based on command ordinal		% 4aii4a
    %	   	    D1`pub`pcrInfo based on PCR values			% 4aii4b
    % HMAC Calculation per Part 1 Object-Independent Authorization Protocol? % 5
    %  	   entity secret data
    %      ordinal
    %	   input command parameters
    %	   authorization parameters
    % IF HM/=AuthData value received in input params
    % THEN IF authorization is first session THEN OUT_Error(TPM_AUTHFAIL) 
    %  	   ELSIF authorization is second session THEN OUT_ERROR(TPM_AUTH2FAIL)
    % ELSE TPM executes command which produces an output that requires authentication.			% 6
    % generate nonceEven	% 7
    % HMAC digest to authenticate Per Part 1 Object-Independent-Authorization Protocol
    %  	   return code		      	     				% 8
    % 	   return values
    % 	   authorization parametersto the same entity secret
    % Return return code, output parameters, authorization parameters, and authorization session digest			% 9
    % If continueUse=FALSE then TPM shall terminate the session. Future references to H will return error.		% 10
    % Ecah time access to entity is authorized using OIAP, the TPM must validate that the TPM_PCR_Info_xxx ...AtRelease values if specified for entity  % 11
    % The TPM should validate the values before using the shared secret to validate the command parameters. this prevents dictionary attack on the shared secret when the values are invalid for the entity.        % 11 a
  
  OSAPState(s:tpmAbsState,oOSAP:(tpmNonce?)) : tpmAbsState

  OSAPOut(s:tpmAbsState) : tpmAbsOutput

  flushSpecificState(s:tpmAbsState,d:tpmData) : tpmAbsState 

  flushSpecificOut(s:tpmAbsState,d:tpmData) : tpmAbsOutput
  
  dataBindOut(s:tpmAbsState,k:(tpmKey?),d:tpmData) : tpmAbsOutput = 
    OUT_Data_Bind(encrypt(tpmBoundData(d),key(k)),CPU_SUCCESS);

  buildQuoteFromMem?(s:tpmAbsState,q,i:nat) : bool = 
    LET theMem = memory(s) IN
    OUT_Quote?(theMem(q)) AND tpmQuote?(signData(sigD(theMem(q))))
       AND OUT_MakeIdentity?(theMem(i))

  buildQuoteFromMemState(s:tpmAbsState,q,i:nat) : tpmAbsState =
    IF buildQuoteFromMem?(s,q,i)
    THEN LET theMem = memory(s) IN
    	 s WITH [`outData:=cons(signData(sigD(theMem(q))),
			cons(idBinding(theMem(i)),outData(s)))]
    ELSE s
    ENDIF

  buildQuoteFromMemOut(s:tpmAbsState,q,i:nat) : tpmAbsOutput = 
    IF buildQuoteFromMem?(s,q,i)
    THEN LET theMem = memory(s) IN 
    	 OUT_FullQuote(signData(sigD(theMem(q))),
		idBinding(theMem(i)),
		CPU_SUCCESS)
    ELSE OUT_CPUError(CPU_QUOTE_ERROR) %% TODO: Incorrect?
    ENDIF;


  certify?(aik:(tpmKey?),certReq:(signed?)) : bool = 
    LET d=checkSig?(key(aik),certReq) IN
      d AND tpmIdContents?(signData(certReq))
      AND tpmDigest?(digest(signData(certReq)))
  
  %% TODO: should this be able to affect state? i don't think so. CHANGE
%   certState(aik:(tpmKey?),certReq:(signed?)) : tpmAbsState=
%     IF certify?(aik,certReq)
%     THEN genKeyState(s) WITH 
%     	 	[`outData:=cons(aik,
% 			   cons(encrypt(tpmAsymCAContents(
% 				tpmSessKey(initSessKeyVal),
% 					digest(signData(certReq))),
% 				   key(ekVal)),outData(s)))]
%     ELSE s
%     ENDIF
  
  % Generate a certified AIK from an AIK.  Certification assumes that the
  % EK really does belong to the TPM.  We're abstracting away that check.
  certOut(aik:(tpmKey?),certReq:(signed?)) : tpmAbsOutput =
    IF certify?(aik,certReq)
    THEN OUT_Certify(aik,encrypt(tpmAsymCAContents(tpmSessKey(initSessKeyVal),
					digest(signData(certReq))),
				   inverse(sigkey(certReq))), %TODO: ENCRYPTED WITH EK?
		CPU_SUCCESS)
    ELSE OUT_CPUError(CPU_CERTIFY_ERROR)
    ENDIF
  
  % Read a value and output
  readOut(s:tpmAbsState,i:nat) : tpmAbsOutput = 
    s`memory(i);

  %% Revoke key operation on TPM state
  revokeKeyState(s:tpmAbsState,k:(tpmKey?)) : tpmAbsState =
    s WITH [`keys := revokeKey(k,keys(s))];


  restoreState(s:tpmAbsState) : tpmAbsState =
    IF valid?(restore(s))
    THEN LET rs=restore(s) IN
    % TODO: Sessions based off of TPM_GetCapability			% 3b
    % TODO: PCRs     	       	  					% 3c
    % TODO: auditDigest							% 3d
         s WITH[`memory := memory(s)
	       ,`ek := ek(rs)
	       ,`srk := srk(rs)
	       ,`pcrs := pcrs(rs)
	       ,`keys := keys(rs)					% 3f
	       ,`keyGenCnt:=keyGenCnt(rs)
	       ,`locality := 3
	       ,`permFlags := permFlags(rs)
	       ,`permData := permData(rs)
	       ,`stanyFlags := stanyFlags(rs) WITH [`postInitialize:=FALSE] % 6
	       ,`stanyData := stanyData(rs)
	       ,`stclearFlags := stclearFlags(rs)			% 3eii
	       ,`stclearData := stclearData(rs)				% 3ei
	       ,`restore := tpmRestoreUnknown %TODO			% 5
	       ,`outData := null]
    ELSE s WITH [`stanyFlags(postInitialize):=FALSE			% 6
    	   	,restore:=tpmRestoreUnknown]				% 5
    ENDIF;

  restoreOut(s:tpmAbsState) : tpmAbsOutput = 
    IF valid?(restore(s))
    THEN OUT_Startup(TPM_SUCCESS) %TODO: check?
    ELSE OUT_Startup(TPM_FAILEDSELFTEST)				% 3a
    	 % TODO: Returns TPM_FAILEDSELFTEST to all commands...
    ENDIF;


  % deactivate by going back to init.  Not sure this is correct.
  deactivateState(s:tpmAbsState) : tpmAbsState  =
    s WITH [%TODO invalidate sessions					% 4a
      	    `stclearFlags:=stclearFlagsDefault WITH [`deactivated:=TRUE]% 4b,c
	   ,`restore:=tpmRestoreUnknown %TODO  	    			% 5
      	   ,`stanyFlags(postInitialize):=FALSE %TODO: INCORRECT?	% 6
	   ];

  % save a value to external memory
  saveToMemState(s:tpmAbsState,i:nat,v:tpmAbsOutput) : tpmAbsState =
    s WITH [`memory := updateLoc(memory(s),i,v)];

  %% What we want to generate with each command is a pair of type
  %% [tpmAbsOut,tpmAbsState].  executeCom generates the the state
  %% from a TPM state and command while the upcoming outputCom
  %% generates the corresponding output.  Thus, to execute any
  %% operation, both executeCom and outputCom must be used

  %% Run if TPM_Init has run but TPM_Startup has not
  executeComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsState =
    CASES c OF
      ABS_Startup(t) : CASES t OF 
      		        TPM_ST_CLEAR : tpmStartup(s),
    			TPM_ST_STATE : restoreState(s),
    			TPM_ST_DEACTIVATED : deactivateState(s)
                       ENDCASES
      ELSE s
    ENDCASES;

  %% Run if ABS_Startup has run after TPM_Init
  executeComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsState = 
    CASES c OF
      ABS_Init : tpmPostInit,
      ABS_SaveState : saveState(s),
      ABS_SetOwnerInstall(state) : setOwnerInstallState(s,state),
      ABS_OwnerSetDisable(d,i) : ownerSetDisableState(s,d,i),
      ABS_PhysicalEnable : physicalEnableState(s),
      ABS_PhysicalDisable : physicalDisableState(s),
      ABS_PhysicalSetDeactivated(st) : physicalSetDeactivatedState(s,st),
      ABS_SetTempDeactivated(i) : setTempDeactivatedState(s,i),
      ABS_SetOperatorAuth(opAuth) : setOperatorAuthState(s,opAuth),
      ABS_TakeOwnership(oA,sA,srk,a) : takeOwnershipState(s,oA,sA,srk,a),
      ABS_OwnerClear(a): ownerClearState(s,a),
      ABS_ForceClear: forceClearState(s),
      ABS_DisableOwnerClear(a): disableOwnerClearState(s,a),
      ABS_DisableForceClear: disableForceClearState(s),
      ABS_PhysicalPresence(p): physicalPresenceState(s,p),
      ABS_ResetEstablishmentBit: resetEstablishmentBitState(s),
      ABS_Seal(k,e,p,i,a) : sealState(s,k,e,p,i,a),
      ABS_Unseal(p,i,a,d) : unsealState(s,p,i,a,d),
      ABS_UnBind(k,i,a) : unBindState(s,k,i,a),
      ABS_CreateWrapKey(p,k,u,m,a) : createWrapKeyState(s,p,k,u,m,a),
      ABS_LoadKey2(p,k,a): loadKey2State(s,p,k,a), 
      ABS_GetPubKey(k,a) : getPubKeyState(s,k,a),
%       ABS_Sealx(k,e,p,i,a) : sealxState(s,k,e,p,i,a),
      ABS_CreateMigrationBlob(p,m,k,e,a,i) : createMigBlobState(s,p,m,k,e,a,i),
      ABS_ConvertMigrationBlob(p,i,r,a) : convertMigBlobState(s,p,i,r,a),
      ABS_AuthorizeMigrationKey(k,m,a) : authorizeMigKeyState(s,k,m,a),
      ABS_MigrateKey(m,p,i,a) : migrateKeyState(s,m,p,i,a),
      ABS_CMK_SetRestrictions(r,i) : CMKSetRestrState(s,r,i),
      ABS_CMK_ApproveMA(m,i) : CMKApproveMAState(s,m,i),
      ABS_CMK_CreateKey(p,d,k,m,a,i) : CMKCreateKeyState(s,p,d,k,m,a,i),
      ABS_CMK_CreateTicket(v,sd,g,i) : CMKCreateTicketState(s,v,sd,g,i),
      ABS_CMK_CreateBlob(p,t,m,k,l,r,st,e,i) : 
      		CMKCreateBlobState(s,p,t,m,k,l,r,st,e,i),
      ABS_CMK_ConvertMigration(p,r,st,m,l,ra,i) : 
      		CMKConvertMigrationState(s,p,r,st,m,l,ra,i),
      ABS_SHA1Complete(h) : SHA1CompleteState(s,h),
      ABS_SHA1CompleteExtend(p,hd) : SHA1CompleteExtendState(s,p,hd),
      ABS_Sign(k,a) : signState(s,k,a),
      ABS_GetRandom : getRandomState(s),
      ABS_StirRandom(i) : stirRandomState(s,i),
      ABS_CertifyKey(c,k,n,i1,i2) : certifyKeyState(s,c,k,n,i1,i2),
      ABS_CreateEndorsementKeyPair(n,k) : createEKPairState(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKState(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustState(s,r),
      ABS_OwnerReadInternalPub(k,a) : ownerReadInternalPubState(s,k,a),
      ABS_MakeIdentity(e,d,k,a1,a2) : makeIdentityState(s,e,d,k,a1,a2), 
      ABS_ActivateIdentity(a,b,a1,a2): activateIdentityState(s,a,b,a1,a2),
      ABS_Extend(n,d) : extendState(s,n,d),
      ABS_PCRRead(i) : pcrReadState(s,i),
      ABS_Quote(a,n,p,i) : quoteState(s,a,n,p,i),
      ABS_PCR_Reset(p) : pcrResetState(s,p),
      ABS_ChangeAuth(p,n,d,i1,i2) : changeAuthState(s,p,n,d,i1,i2),
%       ABS_OIAP : OIAPState(s),
%       ABS_OSAP(oa) : OSAPState(s,oa),
%       ABS_FlushSpecific(h) : flushSpecificState(s,h),
      ABS_buildQuoteFromMem(q,i) : buildQuoteFromMemState(s,q,i),
      ABS_senter : 
        changeLocalityState(extendState(pcrsResetSenterState(s),0,sinitHash)),
      ABS_sinit : changeLocalityState(extendState(s,0,mleHash)),
      ABS_save(i,v) : saveToMemState(s,i,v)
      ELSE s
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  executeCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsState =
    IF afterInit?(s)
    THEN executeComPostInit(s,c)
    ELSE executeComStartup(s,c)
    ENDIF;

  %% Run if TPM_Init has run but TPM_Startup has not
  outputComPostInit(s:(afterInit?),c:tpmAbsInput) : tpmAbsOutput =
    OUT_Error(TPM_INVALID_POSTINIT);

  %% Generate output from a command and state 
  %% Run if ABS_Startup has run after TPM_Init
  outputComStartup(s:(afterStartup?),c:tpmAbsInput) : tpmAbsOutput = 
    CASES c OF
      ABS_SetOwnerInstall(state) : setOwnerInstallOut(s,state),
      ABS_OwnerSetDisable(d,i) : ownerSetDisableOut(s,d,i),
      ABS_PhysicalEnable : physicalEnableOut(s),
      ABS_PhysicalDisable : physicalDisableOut(s),
      ABS_PhysicalSetDeactivated(st) : physicalSetDeactivatedOut(s,st),
      ABS_SetTempDeactivated(i) : setTempDeactivatedOut(s,i),
      ABS_SetOperatorAuth(opAuth) : setOperatorAuthOut(s,opAuth),
      ABS_TakeOwnership(oA,sA,srk,a) : takeOwnershipOut(s,oA,sA,srk,a),
      ABS_OwnerClear(a) : ownerClearOut(s,a),
      ABS_ForceClear : forceClearOut(s),
      ABS_DisableOwnerClear(a) : disableOwnerClearOut(s,a),
      ABS_DisableForceClear : disableForceClearOut(s),
      ABS_PhysicalPresence(p) : physicalPresenceOut(s,p),
      ABS_ResetEstablishmentBit : resetEstablishmentBitOut(s),
      ABS_Seal(k,e,p,data,a) : sealOut(s,k,e,p,data,a),
      ABS_Unseal(d,k,pa,da) : unsealOut(s,d,k,pa,da),
      ABS_UnBind(k,d,a) : unBindOut(s,k,d,a),
      ABS_Data_Bind(k,d) : dataBindOut(s,k,d),
      ABS_CreateWrapKey(parent,k,u,m,a) : createWrapKeyOut(s,parent,k,u,m,a),
      ABS_LoadKey2(p,k,a) : loadKey2Out(s,p,k,a),
      ABS_GetPubKey(k,a): getPubKeyOut(s,k,a), 
      ABS_CreateMigrationBlob(pk,m,migKAuth,encData,a1,a2) : 
      		createMigBlobOut(s,pk,m,migKAuth,encData,a1,a2),
      ABS_ConvertMigrationBlob(p,d,r,a) : convertMigBlobOut(s,p,d,r,a),
      ABS_AuthorizeMigrationKey(mk,ms,a) : authorizeMigKeyOut(s,mk,ms,a),
      ABS_MigrateKey(mk,pubKey,data,a) : migrateKeyOut(s,mk,pubKey,data,a),
      ABS_CMK_SetRestrictions(r,i) : CMKSetRestrOut(s,r,i),
      ABS_CMK_ApproveMA(m,i) : CMKApproveMAOut(s,m,i),
      ABS_CMK_CreateKey(p,d,k,m,a,i) : CMKCreateKeyOut(s,p,d,k,m,a,i),
      ABS_CMK_CreateTicket(k,a,v,i) : CMKCreateTicketOut(s,k,a,v,i),
      ABS_CMK_CreateBlob(p,t,m,k,l,r,d,e,i) : 
      		CMKCreateBlobOut(s,p,t,m,k,l,r,d,e,i),
      ABS_CMK_ConvertMigration(p,r,t,k,l,d,i) : 
    		CMKConvertMigrationOut(s,p,r,t,k,l,d,i),
      ABS_SHA1Complete(hd) : SHA1CompleteOut(hd),
      ABS_SHA1CompleteExtend(p,hd) : SHA1CompleteExtendOut(s,p,hd),
      ABS_Sign(k,a) : signOut(s,k,a),
      ABS_GetRandom : getRandomOut(s),
      ABS_StirRandom(i) : stirRandomOut(s,i),
      ABS_CertifyKey(c,k,n,i1,i2) : certifyKeyOut(s,c,k,n,i1,i2),
      ABS_CreateEndorsementKeyPair(n,k) : createEKPairOut(s,n,k),
      ABS_CreateRevocableEK(r,k,g,i) : createRevEKOut(s,r,k,g,i),
      ABS_RevokeTrust(r) : revokeTrustOut(s,r),
      ABS_ReadPubek(n) : readPubekOut(s,n),
      ABS_OwnerReadInternalPub(k,a) : ownerReadInternalPubOut(s,k,a),
      ABS_MakeIdentity(e,d,k,a1,a2) : makeIdentityOut(s,e,d,k,a1,a2),
      ABS_ActivateIdentity(i,b,a1,a2) : activateIdentityOut(s,i,b,a1,a2),
      ABS_Extend(n,d) : extendOut(s,n,d),
      ABS_PCRRead(ind) : pcrReadOut(s,ind),
      ABS_Quote(k,n,pm,i) : quoteOut(s,k,n,pm,i),
      ABS_PCR_Reset(p) : pcrResetOut(s,p),
      ABS_ChangeAuth(p,n,d,i1,i2) : changeAuthOut(s,p,n,d,i1,i2),
      %ABS_OIAP : oiapOut(s),
%       ABS_FlushSpecific(h) : flushSpecificOut(s,h),
      ABS_buildQuoteFromMem(q,i) : buildQuoteFromMemOut(s,q,i),
      ABS_certify(aik,cr) : certOut(aik,cr),
      ABS_read(i) : readOut(s,i)
    ELSE OUT_Error(TPM_SUCCESS)
  ENDCASES;
  
  %% Execute a command on state generating a new state.  Commands execution
  %% should be blocked if startup has not run and postInitialize=true.
  outputCom(s:tpmAbsState,c:tpmAbsInput) : tpmAbsOutput =
    IF afterInit?(s)
       THEN outputComPostInit(s,c)
       ELSE outputComStartup(s,c)
    ENDIF;


  %% CPU Command Definitions

  %% Requires use of bind
  CPU_saveOutput(i:nat) : [tpmAbsOutput -> State] =
      useOutputStateOutput(
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    executeCom(s,ABS_save(i,a)))),
               (LAMBDA (a:tpmAbsOutput):
                  (LAMBDA (s:tpmAbsState):
		    a)));

  CPU_read(i:nat) : State =
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_read(i)));

  %% Call SENTER 
  CPU_senter : State =
    modify(OUT_Error(TPM_SUCCESS),
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_senter)));

  %% Reset the TPM by senter call - depreciated - DO NOT USE
  %senterResetTPM : State = put(OUT_Error(TPM_SUCCESS),tpmStartup);

  %% Measure sinit by senter call - depreciated - DO NOT USE
  %senterHashSinitTPM : State = TPM_Extend(hash(sinit),0);

  %% Call sinit for initial measurements
  CPU_sinit : State =
    modify(OUT_Error(TPM_SUCCESS),
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_sinit)));
 
  CPU_BuildQuoteFromMem(q,idcont:nat):State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,ABS_buildQuoteFromMem(q,idcont))),
	(LAMBDA (s:tpmAbsState):outputCom(s,ABS_buildQuoteFromMem(q,idcont))));

  gen_quote : THEOREM
   FORALL (state:(afterStartup?),x,y:nat) :
    LET (a,s) = runState(CPU_BuildQuoteFromMem(x,y))(state) IN
    IF OUT_Quote?(state`memory(x)) AND 
       OUT_MakeIdentity?(state`memory(y)) 
       THEN a=OUT_FullQuote(signData(sigD(state`memory(x))),
			idBinding(state`memory(y)),
			CPU_SUCCESS) AND
       	    s=state WITH [`outData:=cons(signData(sigD(state`memory(x))),
					cons(idBinding(state`memory(y)),
					outData(state)))]
       ELSE a=OUT_CPUError(CPU_QUOTE_ERROR) AND 
       	    s=state
    ENDIF;


  %% CA Command Definitions
  %% Invoke the certification authority
  CA_certify(aik:(tpmKey?),cr:(signed?)) : State =
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_certify(aik,cr))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_certify(aik,cr))));

  %% Assure the CA generates an appropriate cert from the AIK and Ek
  %% proved - Wed Jul 11 13:14:11 EDT 2012
  gen_cert: THEOREM 
   FORALL (state:(afterStartup?),aik:(tpmKey?),id:(signed?)) :
    LET (a,s) = runState(CA_certify(aik,id))(state) IN
    IF certify?(aik,id)
    THEN a=OUT_Certify(aik,
		encrypted(tpmAsymCAContents(
				tpmSessKey(initSessKeyVal),
				digest(signData(id))),
			inverse(sigkey(id))),
		CPU_SUCCESS)
    ELSE a=OUT_CPUError(CPU_CERTIFY_ERROR) 
    ENDIF
    AND s=state;
	
  %% TPM Command Definitions - Note that all commands used by the TPM
  %% have the TPM suffix to distinguish from operations on tpm state.
  %% Commands thus far are defined as state transforming or output
  %% generating.  This does not exclude the eventuality of doing both.

  %% No-op - not a real TPM command
  TPM_Noop : [tpmAbsOutput -> State] =
    (LAMBDA (a:tpmAbsOutput): state((LAMBDA(s:tpmAbsState) : (a,s))));

  %% TPM is off - not a real TPM command
  TPM_Off : State = put(OUT_Nothing,tpmUnknown);


  %% 3. Admin Startup And State

  %% 3.1 TPM_Init
  %% TPM_Init is a physical method of initializing a TPM. There is no TPM_Init 
  %%  ordinal as this is a platform message sent on the platform internals to 
  %%  the TPM. On a PC this command arrives at the TPM via the LPC bus and 
  %%  informs the TPM that the platform is performing a boot process.
  %% TPM_Init puts the TPM into a state where it waits for the command 
  %%  TPM_Startup (which specifies the type of initialization that is required.)
  TPM_Init : State = put(OUT_Init(TPM_SUCCESS),tpmPostInit);

  init_post : THEOREM
    FORALL (state:tpmAbsState) :
      LET (a,s) = runState(TPM_Init)(state) IN
       	  a=OUT_Init(TPM_SUCCESS) AND
       	  s=tpmPostInit

  %% 3.2 TPM_Startup
  %% TPM_Startup is always preceded by TPM_Init, which is the physical 
  %%  indication (a system- wide reset) that TPM initialization is necessary.
  %% There are many events on a platform that can cause a reset and the response
  %%  to these events can require different operations to occur on the TPM. The
  %%  mere reset indication does not contain sufficient information to inform 
  %%  the TPM as to what type of reset is occurring. Additional information 
  %%  known by the platform initialization code needs transmitting to the TPM. 
  %%  The TPM_Startup command provides the mechanism to transmit the information
  %% The TPM can startup in three different modes:
  %%  A “clear” start where all variables go back to their default or 
  %%   non-volatile set state
  %%  A “save” start where the TPM recovers appropriate information and restores
  %%   various values based on a prior TPM_SaveState. This recovery requires an 
  %%   invocation of TPM_Init to be successful.
  %%  A failing "save" start must shut down the TPM. The CRTM cannot leave the 
  %%   TPM in a state where an untrusted upper software layer could issue a 
  %%   "clear" and then extend PCR's and thus mimic the CRTM.
  %%  A “deactivated” start where the TPM turns itself off and requires another
  %%   TPM_Init before the TPM will execute in a fully operational state.
  TPM_Startup(st:TPM_STARTUP_TYPE) : State =
    modify(OUT_Startup(TPM_SUCCESS),
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Startup(st))));

  %% TPM_Startup post condition covering three major cases: clear, restore
  %% state and deactivate.
  %% proved - Sat Sep 15 09:58:36 CDT 2012
  startup_post : THEOREM 
    FORALL (s0:(afterInit?), startup:TPM_STARTUP_TYPE) : 
      LET (a,s) = runState(TPM_Startup(startup))(s0) IN
       LET save = restore(s) IN
        CASES startup OF
          TPM_ST_CLEAR : s=tpmStartup(s0),
	  TPM_ST_STATE : valid?(save) AND wellFormedRestore?(save) =>
	  	       	      save=tpmRestoreUnknown
	                      AND keys(s) = keys(restore(s0))
			      AND ek(s) = ek(restore(s0))
			      AND srk(s) = srk(restore(s0))
% 			      TODO: not sure where this came from...
% 				 FORALL (i:PCRINDEX) : 
% 	      		      	    IF pcrReset(pcrAttrib(permData(save))(i))
% 	         		    THEN pcrs(save)(i) = resetOne
% 		 		    ELSE pcrs(save)(i) = pcrs(s)(i)
% 	      			    ENDIF
			      AND permFlags(s) = permFlags(restore(s0))
			      AND permData(s) = permData(restore(s0)) 
			      AND s`stanyFlags`postInitialize=FALSE,
	  TPM_ST_DEACTIVATED : s=deactivateState(s)
        ENDCASES
	AND a=OUT_Startup(TPM_SUCCESS)
 	AND s`stanyFlags`postInitialize=FALSE

  %% Prove that the only command that can run and do anyting folling a
  %% TPM_Init is TPM_Startup.  If anything else tries to run, nothing happens. 
  %% Note the use of an "anything" command in the first command sequence.
  startup_after_init: THEOREM 
    FORALL (s:tpmAbsState,a:tpmAbsOutput,c:tpmAbsInput) :
      NOT ABS_Startup?(c) =>
        LET (a0,s0) = runState(TPM_Init 
	    	      >> state(LAMBDA (s:tpmAbsState) : 
		      	 	      	(a,executeCom(s,c))))(s) IN
          LET (a1,s1) = runState(TPM_Init)(s) IN
	      s0=s1


  %% Prove that senter after power up results in reset PCRs followed by sinit
  %% measurement.
  %% proved - Tue Jun 12 15:31:12 CDT 2012
   resetMonad: THEOREM 
    FORALL (hv:HV, state:tpmAbsState) :
      LET (a,s) = runState(
      	          TPM_Init
      		  >> TPM_Startup(TPM_ST_CLEAR)
      		  >> CPU_senter
      		  >> CPU_sinit
      		  )(state) IN
      s=changeLocalityState(
               changeLocalityState(
                 extendState(
                   extendState(pcrsResetSenterState(
				tpmStartup(
				  tpmDefault WITH [
					`stanyFlags`postInitialize:=TRUE])),
				0,sinitHash),
			0,mleHash))) AND 
     a=OUT_Error(TPM_SUCCESS)

  %% 3.3 TPM_SaveState
  %% This warns a TPM to save some state information.
  %% If the relevant shielded storage is non-volatile, this command need have no
  %%  effect.
  %% If the relevant shielded storage is volatile and the TPM alone is unable to
  %%  detect the loss of external power in time to move data to non-volatile 
  %%  memory, this command should be presented before the TPM enters a low or no
  %%  power state.
  %% Resettable PCRs are tied to platform state that does not survive a sleep 
  %%  state. If the PCRs did not reset, they would falsely indicate that the 
  %%  platform state was already present when it came out of sleep. Since some 
  %%  setup is required first, there would be a gap where PCRs indicated the 
  %%  wrong state. Therefore, the PCRs must be recreated.
  %% Any loaded keys may be preserved. Keys with parentPCRStatus TRUE are not 
  %%  given priority because of security concerns. Rather, since the key might 
  %%  be part of a storage tree that requires PCR value transitions, it might 
  %%  not be directly loadable after TPM_Startup(ST_STATE). For a TPM 
  %%  implementation that does not save all loaded keys, the platform should 
  %%  issue a TPM_SaveContext / TPM_LoadContext sequence for those loaded keys.
  %%  contextNonceKey will be restored, guaranteeing that the saved key context 
  %%  can be restored.
  TPM_SaveState : State =
    modify(OUT_SaveState(TPM_SUCCESS),
            (LAMBDA (s:tpmAbsState):executeCom(s,ABS_SaveState)))
  
  %% Save state actually saves the correct information.
  %% proved - Fri Sep 14 11:20:25 CDT 2012
  save_state_post : THEOREM
    FORALL (s0:(afterStartup?)) : 
      LET (a,s) = runState(TPM_SaveState)(s0) IN
       LET save = restore(s) IN
        valid?(save)
	AND keys(save) = keys(s0)
	AND ek(save) = ek(s0)
	AND srk(save) = srk(s0)
	AND FORALL (i:PCRINDEX) : 
	      IF pcrReset(pcrAttrib(permData(save))(i))
	         THEN pcrs(save)(i) = resetOne
		 ELSE pcrs(save)(i) = pcrs(s0)(i)
	      ENDIF
	AND permFlags(save) = permFlags(s0)
	AND permData(save) = permData(s0)
	AND a=OUT_SaveState(TPM_SUCCESS)

  %% 4. Admin Testing
  %% 4.1 TPM_SelfTestFull
  %% 4.2 TPM_ContinueSelfTest
  %% 4.3 TPM_GetTestResult

  %% 5. Admin Opt-in
  %% 5.1 TPM_SetOwnerInstall
  %% When enabled but without an owner this command sets the PERMANENT flag that
  %%  allows or disallows the ability to insert an owner.
  TPM_SetOwnerInstall(state:bool) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_SetOwnerInstall(state))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_SetOwnerInstall(state))));

  set_owner_install_post: THEOREM FORALL (state:(afterStartup?),b:bool) :
    LET (a,s) = runState(TPM_SetOwnerInstall(b))(state) IN
    IF not(invalidAuth?(s`permData`ownerAuth)) 
    THEN a=OUT_SetOwnerInstall(TPM_SUCCESS) AND s=state
    ELSIF state`stclearFlags`physicalPresence
    THEN a=OUT_SetOwnerInstall(TPM_SUCCESS) AND 
    	 s=state WITH [`permFlags`ownership:=b]
    ELSE a=OUT_Error(TPM_INSTALL_DISABLED) AND s=state
    ENDIF;

  %% 5.2 TPM_OwnerSetDisable
  %% The TPM owner sets the PERMANENT disable flag to TRUE or FALSE.  
  TPM_OwnerSetDisable(d:bool,i:authIn) : State = 
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_OwnerSetDisable(d,i))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerSetDisable(d,i))));

  owner_set_disable_post:THEOREM FORALL (state:(afterStartup?),b:bool,i:authIn):
    LET (a,s) = runState(TPM_OwnerSetDisable(b,i))(state) IN
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
    	a=OUT_OwnerSetDisable(o1,TPM_SUCCESS) AND 
    	s=state WITH [`permFlags`disable:=b]

  %% 5.3 TPM_PhysicalEnable
  %% Sets the PERMANENT disable flag to FALSE using physical presence as 
  %%  authorization.
  TPM_PhysicalEnable : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalEnable)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalEnable)));

  physical_enable_post: THEOREM FORALL (state:(afterStartup?)) :
    LET (a,s) = runState(TPM_PhysicalEnable)(state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_PhysicalEnable(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags`disable:=FALSE]
    ENDIF;

  %% 5.4 TPM_PhysicalDisable
  %% Sets the PERMANENT disable flag to TRUE using physical presence as 
  %%  authorization.
  TPM_PhysicalDisable : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalDisable)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalDisable)));

  physical_disable_post: THEOREM FORALL (state:(afterStartup?)) :
    LET (a,s) = runState(TPM_PhysicalDisable)(state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_PhysicalDisable(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags`disable:=TRUE]
    ENDIF;

  %% 5.5 TPM_PhysicalSetDeactivated
  %% Changes the TPM persistant deactivated flag using physical presence as 
  %%  authorization.
  %% This command is not available when the TPM is disabled.
  TPM_PhysicalSetDeactivated(st:bool) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalSetDeactivated(st))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalSetDeactivated(st))));

  physical_set_deactivated_post:THEOREM FORALL (state:(afterStartup?),st:bool) :
    LET (a,s) = runState(TPM_PhysicalSetDeactivated(st))(state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_PhysicalSetDeactivated(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags`disable:=st]
    ENDIF;


  %% 5.6 TPM_SetTempDeactivated
  %% This command allows the operator of the platform to deactivate the TPM 
  %%  until the next boot of the platform.
  %% This command requires operator authentication. The operator can provide the
  %%  authentication by either the assertion of physical presence or presenting 
  %%  the operator AuthData value.
  TPM_SetTempDeactivated(i:authIn) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_SetTempDeactivated(i))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_SetTempDeactivated(i))));

  set_temp_deactivated_post: THEOREM FORALL (state:(afterStartup?),i:authIn) :
    LET (a,s) = runState(TPM_SetTempDeactivated(i))(state) IN
    IF not state`permFlags`operator
    THEN a=OUT_Error(TPM_NOOPERATOR) AND s=state
    ELSIF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=ownerAuth(i)#) IN
    	a=OUT_SetTempDeactivated(o1,TPM_SUCCESS) AND
    	s=state WITH [`stclearFlags`deactivated:=TRUE]
    ENDIF;

  %% 5.7 TPM_SetOperatorAuth
  %% This command allows the setting of the operator AuthData value.
  %% There is no confidentiality applied to the operator authentication as the
  %%  value is sent under the assumption of being local to the platform. If 
  %%  there is a concern regarding the path between the TPM and the keyboard 
  %%  then unless the keyboard is using encryption and a secure channel an 
  %%  attacker can read the values.
  TPM_SetOperatorAuth(opAuth:(tpmSecret?)) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_SetOperatorAuth(opAuth))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_SetOperatorAuth(opAuth))));

  set_operator_auth_post:THEOREM FORALL(state:(afterStartup?),op:(tpmSecret?)) :
    LET (a,s) = runState(TPM_SetOperatorAuth(op))(state) IN
    IF not state`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_PRESENCE) AND s=state
    ELSE a=OUT_SetOperatorAuth(TPM_SUCCESS) AND
    	 s=state WITH [`permData`operatorAuth:=op
	 	      ,`permFlags`operator:=TRUE]
    ENDIF;

  %% 6. Admin Ownership
  %% 6.1 TPM_TakeOwnership
  %% This command inserts the TPM Ownership value into the TPM.
  TPM_TakeOwnership(ownerA,srkA:(encrypted?),srk:(tpmKey?),a:authIn) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : 
			executeCom(s,ABS_TakeOwnership(ownerA,srkA,srk,a))),
	(LAMBDA (s:tpmAbsState) : 
			outputCom(s,ABS_TakeOwnership(ownerA,srkA,srk,a))));
	 
  take_ownership_post: THEOREM FORALL (state:(afterStartup?),srk:(tpmKey?),
  	eOA,eSA:(encrypted?),aIn:authIn) : 
    LET (a,s) = runState(TPM_TakeOwnership(eOA,eSA,srk,aIn))(state) IN
    IF takeOwnership?(state,srk,eOA,eSA) 
    THEN LET A2=decrypt(eSA,private(state`ek),state`keys),
    	     A1=decrypt(eOA,private(state`ek),state`keys) IN
	 LET asymkey=tpmStoreAsymkey(A2,
				migrationAuth(encData(encDat(srk))),
				pubDataDigest(encData(encDat(srk))),
				private(srk)) IN
	 LET K1=tpmKey(key(srk),keyUsage(srk),keyFlags(srk),
			authDataUsage(srk),algoParms(srk),
		      	PCRInfo(srk),encrypt(asymkey,0)),
	     aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=TRUE,resAuth:=A1#) IN
   	 a=OUT_TakeOwnership(K1,aOut,TPM_SUCCESS) AND 
     	 s=state WITH [`srk:=K1
		      ,`permData(ownerAuth):=A1
	 	      ,`permData(tpmProof):=tpmSecret(n(RNG(state`randCnt)))
		      ,`permFlags(readPubek):=FALSE
		      ,`randCnt:=randCnt(state)+1
		      ,`outData:=cons(K1,outData(state))]
    ELSIF i(state`permData`ownerAuth)/=INVALIDAUTH 
    THEN a=OUT_Error(TPM_OWNER_SET) AND s=state
    ELSIF not state`permFlags`ownership 
    THEN a=OUT_Error(TPM_INSTALL_DISABLED) AND s=state 
    ELSIF not goodkey?(key(state`ek)) 
    THEN a=OUT_Error(TPM_NO_ENDORSEMENT) AND s=state 
    ELSIF not storage?(keyUsage(srk)) 
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(srk)) 
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF not RSA?(algoId(algoParms(srk))) 
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state 
    ELSIF not SHA1_MGF1?(encScheme(algoParms(srk))) 
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
    ELSIF not none?(sigScheme(algoParms(srk))) 
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
    ELSIF s`permFlags`FIPS AND never?(authDataUsage(srk)) 
    THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
%     ELSIF not(tpmSecret?(decrypt(eSA,private(state`ek),state`keys)) AND 
%     	      tpmSecret?(decrypt(eOA,private(state`ek),state`keys)))
% %DECRYPT CHECK
%     	  THEN a=OUT_CPUError(CPU_DECRYPT_ERROR) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;

  take_ownership_post2: THEOREM FORALL (state:(afterStartup?),srk:(tpmKey?),
  	eOA,eSA:(encrypted?),aIn:authIn) : 
    LET (a,s) = runState(TPM_TakeOwnership(eOA,eSA,srk,aIn))(state) IN
    not (takeOwnership?(state,srk,eOA,eSA)) =>
    not a=OUT_Error(TPM_SUCCESS)


  % To be used with commands that use clear command: 
  %  TPM_OwnerClear, TPM_ForceClear, TPM_RevokeTrust
  clear_post(s,state:(afterStartup?),a,af,at:tpmAbsOutput,p:bool) : bool = 
        % 4. The TPM MUST NOT modify the following TPM_PERMANENT_DATA items
    %s`permData`endorsementKey = state`permData`endorsementKey AND	% 4a
    %s`permData`revMajor = state`permData`revMajor AND	       		% 4b
    %s`permData`revMinor = state`permData`revMinor AND			% 4c
    %s`permData`manuMaintPub = state`permData`manuMaintPub AND		% 4d
    %s`permData`auditMonotonicCounter = state`permData`auditMonotonicCounter AND
    %s`permData`monotonicCounter = state`permData`monotonicCounter AND	% 4f
    s`permData`pcrAttrib = state`permData`pcrAttrib AND		   	% 4g
    %s`permData`rngState = state`permData`rngState AND			% 4h
    s`permData`ekReset = state`permData`ekReset	   			% 4i
    %s`permData`lastFamilyID = state`permData`lastFamilyID AND		% 4j
    %s`permData`tpmDAASeed = state`permData`tpmDAASeed AND 		% 4k
    %s`permData`authDIR[0] = state`permData`authDIR[0] AND		% 4l
    %s`permData`daaProof = state`permData`daaProof AND 			% 4m
    %s`permData`daaBlobKey = state`permData`daaBlobKEY;			% 4n
    AND
    	 IF p
    	 THEN a=at AND s=state
	 ELSE a=af AND 
	      keys(s) = (#vals:=emptyset,keys:=emptyset#) AND		% 3
	      s`permData`ownerAuth = tpmSecret(INVALIDAUTH) AND		% 5a
    	      %s`permData`srk =  AND 			  		% 5b
	      %s`permData`delegateKey =  AND				% 5c
	      %s`permData`delegateTable =  AND				% 5d
	      %s`permData`contextKey =  AND				% 5e
	      s`permData`tpmProof = tpmSecret(INVALIDPROOF) AND		% 5f
	      s`permData`operatorAuth = tpmSecret(INVALIDAUTH) AND	% 5g
	      s`permFlags = state`permFlags WITH
    		  [`disable:=disableDef					% 9a
		  ,`deactivated:=deactivatedDef				% 9b
		  ,`readPubek:=readPubekDef				% 9c
		  ,`disableOwnerClear:=disableOwnerClearDef		% 9d
		  ,`disableFullDALogicInfo:=disableFullDALogicInfoDef	% 9e
		  ,`allowMaintenance:=allowMaintenanceDef		% 9f
		  ,`readSRKPub:=readSRKPubDef				% 9g
		  ,`ownership:=TRUE					% 10a
		  ,`operator:=FALSE					% 10b
		  ,`maintenanceDone:=FALSE]				% 10b
	      %% TODO: AND LOTS MORE STUFF!
	 ENDIF
    % TODO: TPM_OwnerClear 3,6-8,11-14

  %% 6.2 TPM_OwnerClear
  %% The TPM_OwnerClear command performs the clear operation under Owner 
  %%  authentication. This command is available until the Owner executes the 
  %%  TPM_DisableOwnerClear, at which time any further invocation of this 
  %%  command returns TPM_CLEAR_DISABLED.
  TPM_OwnerClear(a:authIn) : State = 
     modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_OwnerClear(a))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerClear(a))));

  owner_clear_post: THEOREM FORALL (state:(afterStartup?),a:authIn) : 
    LET(a,s) = runState(TPM_OwnerClear(a))(state) IN   
%     IF k=private(srk(s))
%     THEN 
      LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
			contAuthSess:=FALSE,resAuth:=ownerAuth(a)#) IN
      clear_post(s,state,
		 a,OUT_OwnerClear(a1,TPM_SUCCESS),OUT_Error(TPM_CLEAR_DISABLED),
		 state`permFlags`disableOwnerClear);
%     ELSE a=OUT_Error(TPM_AUTHFAIL) AND keys(s)=keys(state)
%     ENDIF


  %% 6.3 TPM_ForceClear
  %% The TPM_ForceClear command performs the Clear operation under physical 
  %%  access. This command is available until the execution of the
  %%  TPM_DisableForceClear, at which time any further invocation of this 
  %%  command returns TPM_CLEAR_DISABLED.
  %% TPM_ForceClear can succeed even if no owner is installed. In that case, it
  %%  does whatever TPM_OwnerClear actions that it can.
  TPM_ForceClear : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_ForceClear)),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ForceClear)));

  force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(TPM_ForceClear)(state) IN
    IF s`stclearFlags`physicalPresence
    THEN clear_post(s,state,
	       a,OUT_ForceClear(TPM_SUCCESS),OUT_Error(TPM_CLEAR_DISABLED),
	       state`stclearFlags`disableForceClear)
    ELSE a=OUT_Error(TPM_BAD_PRESENCE) and s=state
    ENDIF;


  %% 6.4 TPM_DisableOwnerClear
  %% The TPM_DisableOwnerClear command disables the ability to execute the 
  %%  TPM_OwnerClear command permanently. Once invoked the only method of 
  %%  clearing the TPM will require physical access to the TPM.
  %% After the execution of TPM_ForceClear, ownerClear is re-enabled and must be
  %%  explicitly disabled again by the new TPM Owner.
  TPM_DisableOwnerClear(a:authIn) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableOwnerClear(a))),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_DisableOwnerClear(a))));

  disable_owner_clear_post: THEOREM FORALL (state:(afterStartup?),a:authIn) : 
    LET(a,s) = runState(TPM_DisableOwnerClear(a))(state) IN
      s=state with [`permFlags`disableOwnerClear:=TRUE] AND
      LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		       contAuthSess:=TRUE,resAuth:=ownerAuth(a)#) IN
      	  a=OUT_DisableOwnerClear(a1,TPM_SUCCESS);


  %% 6.5 TPM_DisableForceClear
  %% The TPM_DisableForceClear command disables the execution of the 
  %%  TPM_ForceClear command until the next startup cycle. Once this command is 
  %%  executed, TPM_ForceClear is disabled until another startup cycle is run.
  TPM_DisableForceClear : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_DisableForceClear)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_DisableForceClear)));

  disable_force_clear_post: THEOREM FORALL (state:(afterStartup?)) : 
    LET(a,s) = runState(TPM_DisableForceClear)(state) IN
      s`stclearFlags`disableForceClear = TRUE
      AND a = OUT_DisableForceClear(TPM_SUCCESS);


  %% 6.6 TSC_PhysicalPresence
  %% Some TPM operations require the indication of a human’s physical presence 
  %%  at the platform. The presence of the human either provides another 
  %%  indication of platform ownership or a mechanism to ensure that the 
  %%  execution of the command is not the result of a remote software process.
  %% This command allows a process on the platform to indicate the assertion of 
  %%  physical presence. As this command is executable by software there must be
  %%   protections against the improper invocation of this command.
  %% The physicalPresenceHWEnable and physicalPresenceCMDEnable indicate the 
  %%  ability for either SW or HW to indicate physical presence. These flags can
  %%  be reset until the physicalPresenceLifetimeLock is set. The platform 
  %%  manufacturer should set these flags to indicate the capabilities of the 
  %%  platform the TPM is bound to.
  %% The command provides two sets of functionality. The first is to enable, 
  %%  permanently, either the HW or the SW ability to assert physical presence. 
  %%  The second is to allow SW, if enabled, to assert physical presence.
  TSC_PhysicalPresence(p:PHYSPRES) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PhysicalPresence(p))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PhysicalPresence(p))));

  physical_presence_post: THEOREM FORALL (state:(afterStartup?),p:PHYSPRES) : 
    LET(a,s) = runState(TSC_PhysicalPresence(p))(state) IN
    IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR member(CMD_ENABLE,p)
       OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
    THEN IF state`permFlags`physicalPresenceLifetimeLock
    	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2a
	 ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2b
	 ELSIF member(HW_ENABLE,p) AND member(HW_DISABLE,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2c
	 ELSIF member(CMD_ENABLE,p) AND member(CMD_DISABLE,p)		
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 2d
	 ELSE s=state WITH [`permFlags`physicalPresenceHWEnable:=
			IF member(HW_ENABLE,p) THEN TRUE		% 2e
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2f
			ELSE s`permFlags`physicalPresenceHWEnable ENDIF,
		      `permFlags`physicalPresenceCMDEnable:=
			IF member(CMD_ENABLE,p) THEN TRUE		% 2g
			ELSIF member(HW_DISABLE,p) THEN FALSE		% 2h
			ELSE s`permFlags`physicalPresenceCMDEnable ENDIF,
		      `permFlags`physicalPresenceLifetimeLock:=
			IF member(LIFETIME_LOCK,p) THEN TRUE		% 2i
			ELSE s`permFlags`physicalPresenceLifetimeLock ENDIF]
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 2j
	 ENDIF
    ELSIF member(LOCK,p) OR member(PRESENT,p) OR member(NOTPRESENT,p)
    THEN IF member(LIFETIME_LOCK,p) OR member(HW_ENABLE,p) OR 
    	    member(CMD_ENABLE,p)OR member(HW_DISABLE,p) OR member(CMD_DISABLE,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3a
	 ELSIF state`permFlags`physicalPresenceCMDEnable=FALSE		
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3b
	 ELSIF member(LOCK,p) AND member(PRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3c
	 ELSIF member(PRESENT,p) AND member(NOTPRESENT,p)
	 THEN s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3d
	 ELSIF state`stclearFlags`physicalPresenceLock
	 THEN  s=state AND a=OUT_Error(TPM_BAD_PARAMETER)		% 3e
	 ELSIF member(LOCK,p)						% 3f
	 THEN s=state WITH [`stclearFlags`physicalPresence:=FALSE	% 3fi
	      	     ,`stclearFlags`physicalPresenceLock:=TRUE]		% 3fii
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
    	 ELSIF member(PRESENT,p)					% 3g
	 THEN s=state WITH [`stclearFlags`physicalPresence:=TRUE]	% 3gi
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
	 ELSIF member(NOTPRESENT,p)					% 3h
	 THEN s=state WITH [`stclearFlags`physicalPresence:=FALSE]	% 3hi
	      AND a=OUT_PhysicalPresence(TPM_SUCCESS)			% 3i
	 ELSE s=state AND a=OUT_Error(TPM_BAD_PARAMETER) % should never get here
    	 ENDIF
    ELSE s=state AND a=OUT_Error(TPM_BAD_PARAMETER)			% 4
    ENDIF;

  %% 6.7 TSC_ResetEstablishmentBit
  %% The PC TPM Interface Specification (TIS) specifies setting tpmEstablished 
  %%  to TRUE upon execution of the HASH_START sequence. The setting implies the
  %%  creation of a Trusted Operating System on the platform. Platforms will use
  %%  the value of tpmEstablished to determine if operations necessary to 
  %%  maintain the security perimeter are necessary.
  %% The tpmEstablished bit provides a non-volatile, secure reporting that a 
  %%  HASH_START was previously run on the platform. When a platform makes use 
  %%  of the tpmEstablished bit, the platform can reset tpmEstablished as the 
  %%  operation is no longer necessary.
  %% For example, a platform could use tpmEstablished to ensure that, if 
  %%  HASH_START had ever been, executed the platform could use the value to 
  %%  invoke special processing. Once the processing is complete the platform 
  %%  will wish to reset tpmEstablished to avoid invoking the special process 
  %%  again.
  %% The TPM_PERMANENT_FLAGS -> tpmEstablished bit described in the TPM 
  %%  specifications uses positive logic. The TPM_ACCESS register uses negative 
  %%  logic, so that TRUE is reflected as a 0.
  TSC_ResetEstablishmentBit : State = 
    modifyOutput(
	(LAMBDA (s:tpmAbsState): executeCom(s,ABS_ResetEstablishmentBit)),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ResetEstablishmentBit)));

  reset_establishment_post: THEOREM
    FORALL (state:(afterStartup?)) :
      LET (a,s) = runState(TSC_ResetEstablishmentBit)(state) IN
    IF resetEstablishment?(state) 
    THEN a=OUT_ResetEstablishmentBit(TPM_SUCCESS) AND
    	 s=state WITH [`permFlags(tpmEstablished):=FALSE]
    ELSE a=OUT_Error(TPM_BAD_LOCALITY) AND s=state
    ENDIF;

  %% 7. Capability Commands TODO
  %% 8. Auditing   TODO
  %% 9. Administrative Functions - Management TODO

  %% 10. Storage Functions
  %% 10.1 TPM_Seal
  %% TODO: info
  %% Seal and output a blob (should be binary or data)
  TPM_Seal(k:(tpmKey?),encAuth:(tpmEncAuth?),pcrInfo:(tpmPCRInfoLong?),
	inData:tpmData,a:authIn) : State = %encAuth:(tpmSecret?)
     modifyOutput(
	(LAMBDA (s:tpmAbsState): executeCom(s,ABS_Seal(k,encAuth,pcrInfo,
						inData,a))),
	(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Seal(k,encAuth,pcrInfo,
						inData,a))));

  %% Seal a secret successfully
  seal_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),e:(tpmEncAuth?),%e:(tpmSecret?),
    	   p:(tpmPCRInfoLong?),d:tpmData,aIn:authIn) :
      LET (a,s) = runState(TPM_Seal(k,e,p,d,aIn))(state) IN
      LET sealInfo=tpmPCRInfoLong(state`stanyFlags`localityModifier,
				locAtRelease(p),
				creationPCRSelect(p),
				releasePCRSelect(p),
				tpmCompositeHash(
					tpmPCRComposite(creationPCRSelect(p),
						   state`pcrs)),
				digAtRelease(p)),
	  a1=decryptADIP(e,authHandle(aIn)) IN
      IF not(storage?(keyUsage(k)) AND not(migratable(keyFlags(k))))
      THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND
      	   s=state
      ELSE a=OUT_Seal(tpmStoredData(sealInfo,
				encrypted(tpmSealedData(a1,
						state`permData`tpmProof,
						SHA1(tpmStoredData(sealInfo,
							tpmNull)),
				d),
				key(k))),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
		  resAuth:=usageAuth(encData(encDat(k)))#),
		TPM_SUCCESS) AND 
	   s=state WITH [`outData:=cons(tpmStoredData(sealInfo,
					encrypted(tpmSealedData(a1,
							state`permData`tpmProof,
							SHA1(tpmStoredData(
								sealInfo,
								tpmNull)),
							d),
						key(k))),
					outData(state))]
      ENDIF;
 

  %% 10.2 TPM_Unseal
  %% The TPM_Unseal operation will reveal TPM_Seal’ed data only if it was 
  %%  encrypted on this platform and the current configuration (as defined by 
  %%  the named PCR contents) is the one named as qualified to decrypt it. 
  %%  Internally, TPM_Unseal accepts a data blob generated by a TPM_Seal 
  %%  operation. TPM_Unseal decrypts the structure internally, checks the 
  %%  integrity of the resulting data, and checks that the PCR named has the 
  %%  value named during TPM_Seal. Additionally, the caller must supply 
  %%  appropriate AuthData for blob and for the key that was used to seal that 
  %%  data.
  %% If the integrity, platform configuration and authorization checks succeed, 
  %%  sealed data is returned to the caller; otherwise, an error is generated.
  TPM_Unseal(p:(tpmKey?),d:(tpmStoredData?),pa,da:authIn) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState): executeCom(s,ABS_Unseal(p,d,pa,da))),
	(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Unseal(p,d,pa,da))));

  unseal_post: THEOREM
    FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmStoredData?),pa,da:authIn) :
      LET (a,s) = runState(TPM_Unseal(p,d,pa,da))(state) IN
      LET D1=decrypt(encrData(d),private(p),state`keys),
      	  S2=tpmStoredData(sealInfo(d),tpmNull),
      	  H2=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(sealInfo(d)),
				s`pcrs)) IN
      IF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))))
      THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
      ELSIF not tpmSealedData?(D1)
      THEN a=OUT_Error(TPM_NOTSEALED_BLOB) AND
      	   s=state
      ELSIF not(tpmProof(D1)=s`permData`tpmProof AND 
	    storedDigest(D1)=SHA1(S2))
      THEN a=OUT_Error(TPM_NOTSEALED_BLOB) AND
      	   s=state
      ELSIF not(locAtRelease(sealInfo(S2))=s`stanyFlags`localityModifier)
      THEN a=OUT_Error(TPM_BAD_LOCALITY) AND
      	   s=state
      ELSIF not(H2=digAtRelease(sealInfo(S2)))
      THEN a=OUT_Error(TPM_WRONGPCRVAL) AND
      	   s=state
      ELSE LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(p)))#) IN
    	   a=OUT_Unseal(sealedData(D1),b,b,TPM_SUCCESS) AND
	   s=state WITH [`outData:=cons(sealedData(D1),outData(state))]
      ENDIF

  unseal_prev_post: THEOREM
    FORALL (state:(afterStartup?),j,k:(tpmKey?),e:(tpmEncAuth?),%e:(tpmSecret?),
    	   p:(tpmPCRInfoLong?),d:tpmData,a,ap,ad:authIn,x:nat) :
      LET (a,s) = runState(
      	  	  TPM_Seal(k,e,p,d,a)
		  >>= CPU_saveOutput(x)
		  >>= (LAMBDA (a:tpmAbsOutput) : 
		       CASES a OF
		         OUT_Seal(sd,ao,m) : TPM_Unseal(j,sd,ap,ad) 
			 ELSE TPM_Noop(a)
		       ENDCASES))
		  (state) IN  
        OUT_Seal?(s`memory(x)) AND
	seal?(k) AND 
	unseal?(state,j,sealedData(s`memory(x))) AND 
	key(j)=private(k) AND 
	member(private(k),vals(state`keys)) AND 
	member(private(j),vals(state`keys)) AND
    	d/=badData
%	locAtRelease(p)=localityModifier(state`stanyFlags) AND
%	digAtRelease(p)=tpmCompositeHash(tpmPCRComposite(releasePCRSelect(p),
%						state`pcrs))
	   => LET b:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=usageAuth(encData(encDat(j)))#) IN 
	a=OUT_Unseal(d,b,b,TPM_SUCCESS) AND 
	s=state WITH [`memory:=s`memory
		     ,`outData:=cons(d,cons(sealedData(s`memory(x)),
					outData(state)))]

  %% 10.3 TPM_UnBind
  %% TPM_UnBind takes the data blob that is the result of a Tspi_Data_Bind 
  %%  command and decrypts it for export to the User. The caller must authorize 
  %%  the use of the key that will decrypt the incoming blob.
  %% TPM_UnBind operates on a block-by-block basis, and has no notion of any 
  %%  relation between one block and another.
  TPM_UnBind(keyHandle:(tpmKey?),inData:(encrypted?),a:authIn) : State = 
     modifyOutput(
     (LAMBDA (s:tpmAbsState):executeCom(s,ABS_UnBind(keyHandle,inData,a))),
     (LAMBDA (s:tpmAbsState):outputCom(s,ABS_UnBind(keyHandle,inData,a))));

  %% UnBind an encrypted blob successfully
  unBind_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),d:(encrypted?),ai:authIn) : 
      LET (a,s) = runState(TPM_UnBind(k,d,ai))(state) IN
      LET d1=decrypt(d,private(k),state`keys),
      	  a1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#) IN 
      IF not(legacy?(keyUsage(k)) OR bind?(keyUsage(k)))
      THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND 
      	   s=state
      ELSIF not tpmBoundData?(d1) OR
            (not SHA1_MGF1?(encScheme(algoParms(k))) AND
	       legacy?(keyUsage(k)))
      THEN a=OUT_UnBind(d1,a1,TPM_SUCCESS) AND
	   s=state WITH [`outData:=cons(d1,outData(state))]
      ELSE a=OUT_UnBind(payloadData(d1),a1,TPM_SUCCESS) AND 
	   s=state WITH [`outData:=cons(payloadData(d1),outData(state))]
      ENDIF;

  %% TODO: info?
  Tspi_Data_Bind(k:(tpmKey?),d:tpmData) : State = 
     output(LAMBDA (s:tpmAbsState): outputCom(s,ABS_Data_Bind(k,d)));

  data_bind_post : THEOREM
    FORALL(state:(afterStartup?),d:tpmData,k:(tpmKey?)) :
      LET (a,s) = runState(Tspi_Data_Bind(k,d))(state) IN
    a=OUT_Data_Bind(encrypt(tpmBoundData(d),key(k)),CPU_SUCCESS) AND
    s=state;
		  

  %% UnBind an encrypted blob successfully
  unBind_prev_post: THEOREM 
    FORALL (state:(afterStartup?),d:tpmData,k:(tpmKey?),a:authIn) : 
      LET (a,s) = runState(
		  Tspi_Data_Bind(k,d)
		  >>= LAMBDA (a:tpmAbsOutput) : 
		      CASES a OF
		        OUT_Data_Bind(d1,m) : TPM_UnBind(k,d1,a) 
			ELSE TPM_Noop(a) 
		      ENDCASES)
 		  (state) IN 
    (bind?(keyUsage(k)) OR 
    	legacy?(keyUsage(k)) AND SHA1_MGF1?(encScheme(algoParms(k)))) AND
    d/=badData AND 
    member(private(k),vals(state`keys)) => 
      LET b=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#) IN 
      a=OUT_UnBind(d,b,TPM_SUCCESS) AND
      s=state WITH [`outData:=cons(d,outData(state))]

  %% 10.4 TPM_CreateWrapKey
  %% The TPM_CreateWrapKey command both generates and creates a secure storage 
  %%  bundle for asymmetric keys.
  %% The newly created key can be locked to a specific PCR value by specifying a
  %%  set of PCR registers.
  %% The key blob does not have a protected identifier. On a platform that does 
  %%  not prevent unauthorized access to data, a key blob can be exchanged by a 
  %%  lower layer without detection. The upper layer software must take 
  %%  additional measures to protect the relation between its identifier of the 
  %%  key blob and the blob itself.
  TPM_CreateWrapKey(p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),a:authIn) : State = 
     modifyOutput(
	  (LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_CreateWrapKey(p,k,dUA,dMA,a))),
          (LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateWrapKey(p,k,dUA,dMA,a)))
	      );

  create_wrap_key_post: THEOREM 
    FORALL (state:(afterStartup?),p,k:(tpmKey?),dUA,dMA:(tpmEncAuth?),
    	   a:authIn) : 
      LET (a,s) = runState(TPM_CreateWrapKey(p,k,dUA,dMA,a))(state) IN
    IF not storage?(keyUsage(p)) 
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(p)) AND not(migratable(keyFlags(k)))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF identity?(keyUsage(k)) or authChange?(keyUsage(k))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migrateAuthority(keyFlags(k))
       THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF state`permFlags`FIPS AND
    	  (never?(authDataUsage(k)) OR legacy?(keyUsage(k)))
       THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSIF (storage?(keyUsage(k)) OR migrate?(keyUsage(k))) AND
    	  not(RSA?(algoId(algoParms(k))))
       THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
    ELSE LET DU1:(tpmSecret?)=decryptADIP(dUA,authHandle(a)),
    	     DM1:(tpmSecret?)=decryptADIP(dMA,authHandle(a)),
    	     b=(#nonceEven:=EVEN,nonceOdd:=ODD,
		 contAuthSess:=FALSE,resAuth:=usageAuth(encData(encDat(p)))#),
	     migAuth:(tpmSecret?)=IF migratable(keyFlags(k)) 
	     			  THEN DM1 ELSE state`permData`tpmProof ENDIF,
	     h=tpmCompositeHash(tpmPCRComposite(creationPCRSelect(PCRInfo(k)),
					state`pcrs)) IN
	 LET encData=encrypted(tpmStoreAsymkey(DU1,migAuth,
				pubDataDigest(encData(encDat(k))),
				inverse(state`keyGenCnt)),
			key(p)),
	     pcrs=tpmPCRInfoLong(state`locality,
				locAtRelease(PCRInfo(k)),
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				h,digAtRelease(PCRInfo(k))) IN
	     a=OUT_CreateWrapKey(tpmKey(state`keyGenCnt,
					keyUsage(k),
					keyFlags(k),
					authDataUsage(k),
					algoParms(k),
					pcrs,
					encData),
				b,TPM_SUCCESS)
      	 AND s=state WITH [`keyGenCnt:=keyGenCnt(state)+1
	     	     	  ,`outData:=cons(tpmKey(state`keyGenCnt,keyUsage(k),
						keyFlags(k),authDataUsage(k),
						algoParms(k),pcrs,encData),
					outData(state))]
    ENDIF


  %% 10.5 TPM_LoadKey2
  %% TODO: info
  TPM_LoadKey2(p,k:(tpmKey?),a:authIn):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_LoadKey2(p,k,a))),
	   (LAMBDA (s:tpmAbsState):outputCom(s,ABS_LoadKey2(p,k,a))));

  % A key is installed if it is wrapped with SRK
  % TODO: loadKey2State
  load_key_post: THEOREM 
    FORALL (state:(afterStartup?),p,k:(tpmKey?),i:authIn) :
      LET (a,s) = runState(TPM_LoadKey2(p,k,i))(state) IN
    IF not storage?(keyUsage(p)) 
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) %AND s=state
    ELSE LET aOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		   	resAuth:=ownerAuth(i)#),
	     e=decrypt(encDat(k),private(p),state`keys) IN
    	 CASES keyUsage(k) OF
	 identity: IF migratable(keyFlags(k))=FALSE
	 	   THEN IF migratable(keyFlags(k))=0 AND 
		   	   migrationAuth(e)/=tpmProof(permData(state))
			THEN a=OUT_Error(TPM_FAIL) AND s=state
			ELSIF not validateEncrSigSchemes(k)
			THEN a=OUT_Error(TPM_FAIL) AND s=state
			ELSIF FIPS(permFlags(state)) AND
			      (never?(authDataUsage(k)) OR legacy?(keyUsage(k)))
			THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
			ELSIF not checkKeyUsage(k)			
			THEN a=OUT_Error(TPM_FAIL) AND s=state
			ELSE a=OUT_LoadKey2(k,aOut,TPM_SUCCESS) AND
		   	     s=state WITH [`keys:=loadKey(k,p,
						state`keys,state`pcrs)
					  ,`outData:=cons(k,outData(state))]
			ENDIF
	 	   ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE) 
			AND s=state
	 	   ENDIF,
	 authChange: a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
	 ELSE IF migratable(keyFlags(k))=0 AND 
		 migrationAuth(e)/=tpmProof(permData(state))
	      THEN a=OUT_Error(TPM_FAIL) AND s=state   
	      ELSIF not validateEncrSigSchemes(k)
	      THEN a=OUT_Error(TPM_FAIL) %AND s=state
	      ELSIF FIPS(permFlags(state)) AND (never?(authDataUsage(k)) OR 
	      	    			   legacy?(keyUsage(k)))
	      THEN a=OUT_Error(TPM_NOTFIPS) %AND s=state
	      ELSIF not checkKeyUsage(k)
	      THEN a=OUT_Error(TPM_FAIL) %AND s=state
	      ELSE a=OUT_LoadKey2(k,aOut,TPM_SUCCESS) AND
	      	   s=state with [`keys:=loadKey(k,p,state`keys,
					state`pcrs)
				,`outData:=cons(k,outData(state))]
	      ENDIF
	 ENDCASES
    ENDIF;

  load_key_pred_test: THEOREM
   FORALL (state:(afterStartup?),p,k:(tpmKey?),aIn:authIn) :
     LET (a,s) = runState(TPM_LoadKey2(p,k,aIn))(state) IN
    IF loadKey2?(state,p,k)
    THEN LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		       contAuthSess:=TRUE,resAuth:=ownerAuth(aIn)#) IN
	 a=OUT_LoadKey2(k,aOut,TPM_SUCCESS) AND 
	      IF key(p)=key(TPM_KH_SRK) OR member(private(p),vals(state`keys))
	      THEN s=state WITH [`keys:=(#vals:=add(private(k),vals(state`keys))
					 ,keys:=add(k,keys(state`keys))#)
				,`outData:=cons(k,outData(state))]
	      ELSE s=state WITH [`outData:=cons(k,outData(state))]
	      ENDIF
    ELSE IF not storage?(keyUsage(p))  
	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
	 ELSIF identity?(keyUsage(k)) AND migratable(keyFlags(k))
	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
	 ELSIF authChange?(keyUsage(k))
	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE)
	 ELSIF migratable(keyFlags(k))=0 AND 
	       LET e=decrypt(encDat(k),private(p),state`keys) IN
	     	   migrationAuth(e)/=tpmProof(permData(state))
	 THEN a=OUT_Error(TPM_FAIL)
	 ELSIF not validateEncrSigSchemes(k)
	 THEN a=OUT_Error(TPM_FAIL)
	 ELSIF FIPS(permFlags(state)) AND (never?(authDataUsage(k)) OR
	       legacy?(keyUsage(k)))
	 THEN a=OUT_Error(TPM_NOTFIPS)
	 ELSIF not checkKeyUsage(k)
	 THEN a=OUT_Error(TPM_FAIL)
	 ELSE a=OUT_Error(TPM_SUCCESS)
	 ENDIF 
	 AND s=state
    ENDIF

  load_key_post2: THEOREM
    FORALL (state:(afterStartup?),p,k:(tpmKey?),aIn:authIn) :
      LET (a,s) = runState(TPM_LoadKey2(p,k,aIn))(state) IN
    not (loadKey2?(state,p,k)) =>
    not (a=OUT_Error(TPM_SUCCESS))

  %% A key is installed if it is wrapped with an installed key
  %% proved - Tue Jun 12 15:38:22 CDT 2012
%   % TODO:
%   load_key_post3: THEOREM 
%     FORALL (state:(afterStartup?),j,k:(tpmKey?),i1,i2:authIn) :
%       LET (a,s) = runState(
%       	  	  TPM_LoadKey2(srk(state),k,i1)
% 		  >> TPM_LoadKey2(k,j,i2))
% 		  (state) IN
% 	loadKey2?(state,srk(state),k) AND loadKey2?(state,k,j) 
% 	AND srk(state)=TPM_KH_SRK AND member(private(TPM_KH_SRK),vals(s`keys))
% 	AND isParent?(srk(state),k)
% 	AND isParent?(k,j)
% 		=> OUT_LoadKey2?(a)%member(private(j),s`keys); 
		   

  load_key_prev_post: THEOREM 
    FORALL (state:(afterStartup?),k,p:(tpmKey?),x:nat,dUA,dMA:(tpmEncAuth?),
    	   i:authIn,d:PCRVALUES) :
      LET (a,s) = runState(
      	  	  TPM_CreateWrapKey(p,k,dUA,dMA,i)
		  >>= CPU_saveOutput(x)
		  >>= (LAMBDA (a:tpmAbsOutput) :
		         CASES a OF
		         OUT_CreateWrapKey(wk,a,m) : TPM_LoadKey2(p,wk,i)
			 ELSE TPM_Noop(a)
			 ENDCASES))
		  (state) IN
      member(private(p),vals(state`keys)) AND 
      OUT_CreateWrapKey?(s`memory(x)) AND
      createWrapKey?(p,k) AND loadKey2?(state,p,wrappedKey(s`memory(x))) =>
      LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,
		       contAuthSess:=TRUE,resAuth:=ownerAuth(i)#) IN
      a=OUT_LoadKey2(wrappedKey(s`memory(x)),aOut,TPM_SUCCESS) 
%     TODO
%       AND 
%       s=state WITH[`keyGenCnt:=state`keyGenCnt+1
%       	      	  ,`keys:=IF member(private(p),state`keys) OR
% 		  	     key(p)=key(TPM_KH_SRK)
%       	     	   	  THEN addKey(wrappedKey(s`memory(x)),
% 					state`keys)
% 	     		  ELSE state`keys
% 	     		  ENDIF
%       	      	  ,`memory:=s`memory]

  %% 10.6 TPM_GetPubKey
  %% The owner of a key may wish to obtain the public key value from a loaded 
  %%  key. This information may have privacy concerns so the command must have 
  %%  authorization from the key owner.
  TPM_GetPubKey(k:(tpmKey?),a:authIn):State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,ABS_GetPubKey(k,a))),
	(LAMBDA (s:tpmAbsState):outputCom(s,ABS_GetPubKey(k,a))));

  get_pub_key_post: THEOREM
   FORALL (state:(afterStartup?),k:(tpmKey?),a:authIn) :
    LET (a,s) = runState(TPM_GetPubKey(k,a))(state) IN
    IF getPubKey?(state,k)
    THEN LET aOut:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		       resAuth:=usageAuth(encData(encDat(k)))#) IN
	a=OUT_GetPubKey(tpmPubkey(algoParms(k),key(k)),aOut,TPM_SUCCESS) AND 
    	s=state WITH [`outData:=cons(tpmPubkey(algoParms(k),key(k)),
					outData(state))]
    ELSIF not never?(authDataUsage(k)) 
    THEN a=OUT_Error(TPM_AUTHFAIL) AND 
    	 s=state
    ELSIF s`permFlags`readSRKPub=FALSE
    THEN a=OUT_Error(TPM_INVALID_KEYHANDLE) AND 
    	 s=state
    ELSIF pcrIgnoredOnRead(keyFlags(k))=FALSE
    	  AND dig(digAtRelease(PCRInfo(k)))/=
    	      tpmPCRComposite(select(dig(digAtRelease(PCRInfo(k)))),s`pcrs)
    THEN a=OUT_Error(TPM_WRONGPCRVAL) AND 
    	 s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND 
    	 s=state
    ENDIF

  get_pub_key_post2: THEOREM
   FORALL (state:(afterStartup?),k:(tpmKey?),a:authIn) :
    LET (a,s) = runState(TPM_GetPubKey(k,a))(state) IN
    not getPubKey?(state,k) =>
      not (a=OUT_Error(TPM_SUCCESS))

  %% 10.7 TPM_Sealx
  %% TODO

  %% 11. Migration
  %% The migration of a key from one TPM to another is a vital aspect to many 
  %%  use models of the TPM. The migration commands are the commands that allow 
  %%  this operation to occur.
  %% There are two types of migratable keys, the version 1.1 migratable keys and
  %%  the version 1.2 certifiable migratable keys.
  
  %% 11.1 TPM_CreateMigrationBlob
  %% The TPM_CreateMigrationBlob command implements the first step in the 
  %%  process of moving a migratable key to a new parent or platform. Execution 
  %%  of this command requires knowledge of the migrationAuth field of the key 
  %%  to be migrated.
  %% Migrate mode is generally used to migrate keys from one TPM to another for 
  %%  backup, upgrade or to clone a key on another platform. To do this, the TPM
  %%  needs to create a data blob that another TPM can deal with. This is done 
  %%  by loading in a backup public key that will be used by the TPM to create a
  %%  new data blob for a migratable key.
  %%  The TPM Owner does the selection and authorization of migration public 
  %%  keys at any time prior to the execution of TPM_CreateMigrationBlob by 
  %%  performing the TPM_AuthorizeMigrationKey command.
  %% IReWrap mode is used directly to move the key to a new parent (on either 
  %%  this platform or another). The TPM simply re-encrypts the key using a new 
  %%  parent, and outputs a normal encrypted element that can be subsequently 
  %%  used by a TPM_LoadKey command.
  %% TPM_CreateMigrationBlob implicitly cannot be used to migrate non-migratory 
  %%  key. No explicit check is required. Only the TPM knows tpmProof.Therefore,
  %%  it is impossible for the caller to submit an AuthData value equal to 
  %%  tpmProof and migrate a non-migratory key.
  TPM_CreateMigrationBlob(pk:(tpmKey?),m:(tpmMigScheme?),mka:(tpmMigKeyAuth?),
	d:(encrypted?),a1,a2:authIn) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_CreateMigrationBlob(pk,m,mka,d,a1,a2))),
	(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_CreateMigrationBlob(pk,m,mka,d,a1,a2))));

  create_mig_blob_post: THEOREM 
   FORALL (state:(afterStartup?),pk:(tpmKey?),m:(tpmMigScheme?),
		mka:(tpmMigKeyAuth?),d:(encrypted?),a1,a2:authIn) : 
    LET(a,s) = runState(TPM_CreateMigrationBlob(pk,m,mka,d,a1,a2))(state) IN
    LET a1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=usageAuth(encData(encDat(pk)))#),
    	a2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=usageAuth(encData(encDat(key(mka))))#),
    	d1=decrypt(d,private(pk),state`keys) IN 
    IF createMigBlob?(state,pk,m,mka,d)
    THEN CASES migScheme(m) OF
	 migrate : a=OUT_CreateMigrationBlob(RNG(state`randCnt),
			encrypted(tpmXOR(OAEP(tpmMigrateAsymkey(
						usageAuth(d1),
						pubDataDigest(d1),
						privKey(d1)),
					    migrationAuth(d1),
					    privKey(d1)),
					 RNG(state`randCnt))
				,key(key(mka))),
			a1,a2,TPM_SUCCESS) AND
		     s=state WITH 
		     	[`outData:=cons(RNG(state`randCnt),
				   cons(encrypted(tpmXOR(OAEP(tpmMigrateAsymkey(
							    usageAuth(d1),
							    pubDataDigest(d1),
							    privKey(d1)),
					    		migrationAuth(d1),
					    		privKey(d1)),
					 	RNG(state`randCnt)),
					     key(key(mka))),
				   outData(state)))
			,`randCnt:=randCnt(state)+1],
	 rewrap  : a=OUT_CreateMigrationBlob(RNG(0),encrypted(d1,key(key(mka))),
		     		a1,a2,TPM_SUCCESS) AND 
		   s=state WITH [`outData:=cons(encrypted(d1,key(key(mka))),
						cons(RNG(0),outData(state)))]
	 ELSE a=OUT_Error(TPM_BAD_PARAMETER) AND s=state
	 ENDCASES
    ELSIF not storage?(keyUsage(pk))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state 
    ELSIF not tpmStoreAsymkey?(d1) 
    THEN a=OUT_Error(TPM_BAD_MIGRATION) AND s=state
    ELSIF not checkMigKeyAuth?(s,mka)
    THEN a=OUT_Error(TPM_AUTHFAIL) AND s=state
%     ELSIF not(tpmStoreAsymkey?(decrypt(d,private(pk),state`keys)))
%     THEN a=OUT_CPUError(CPU_DECRYPT_ERROR)AND s=state
    ELSE a=OUT_Error(TPM_BAD_PARAMETER) AND s=state
    ENDIF
    

  %% 11.2 TPM_ConvertMigrationBlob
  %% This command takes a migration blob and creates a normal wrapped blob. The 
  %%  migrated blob must be loaded into TPM using normal TPM_LoadKey function.
  %% Note that the command migrates private keys, only. The migration of the 
  %%  associated public keys is not specified by TPM because they are not 
  %%  security sensitive. Migration of the associated public keys may be 
  %%  specified in a platform specific specification. A TPM_KEY structure must 
  %%  be recreated before the migrated key can be used by the target TPM in a 
  %%  TPM_LoadKey command.
  TPM_ConvertMigrationBlob(p:(tpmKey?),inData:(encrypted?),r:(RNG?),
	a:authIn) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_ConvertMigrationBlob(p,inData,r,a))),
	(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_ConvertMigrationBlob(p,inData,r,a))));

  convert_mig_blob_post: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),d:(encrypted?),%(tpmMigraAsymkey?)
		r:(RNG?),a:authIn) :
    LET (a,s) = runState(TPM_ConvertMigrationBlob(p,d,r,a))(state) IN
    LET d1=decrypt(d,private(p),state`keys),    	 
	a1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(p)))#) IN 
    IF not storage?(keyUsage(p))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSE LET o1=unXOR(d1,r) IN 
    	 LET m1=OAEPdecode(o1),
	     pHash=tpmSecret(1) IN
    	 LET k1=partPrivKey(m1) IN
    	 LET d2=encrypted(tpmStoreAsymkey(usageAuth(m1),pHash,
				pubDataDigest(m1),k1),
			key(p)) IN
	 IF not tpmMigrateAsymkey?(m1)
	 THEN a=OUT_Error(TPM_BAD_MIGRATION) AND s=state 
	 ELSE a=OUT_ConvertMigrationBlob(d2,a1,TPM_SUCCESS) AND
	      s=state WITH [`outData:=cons(d2,outData(state))]
         ENDIF
    ENDIF;

  convert_mig_blob_pred_test : THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),d:(encrypted?),%(tpmMigraAsymkey?)
		r:(RNG?),a:authIn) :
    LET (a,s) = runState(TPM_ConvertMigrationBlob(p,d,r,a))(state) IN
    LET d1=decrypt(d,private(p),state`keys),    	 
	a1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(p)))#) IN 
    convertMigBlob?(state,p,d,r) => OUT_ConvertMigrationBlob?(a);
  
  %% 11.3 TPM_AuthorizeMigrationKey
  %% This command creates an authorization blob, to allow the TPM owner to 
  %%  specify which migration facility they will use and allow users to migrate 
  %%  information without further involvement with the TPM owner.
  %% It is the responsibility of the TPM Owner to determine whether migrationKey
  %%  is appropriate for migration. The TPM checks just the cryptographic 
  %%  strength of migrationKey.
  TPM_AuthorizeMigrationKey(migKey:(tpmKey?),migScheme:(tpmMigScheme?),
	a:authIn) : State=
     modifyOutput(
	(LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_AuthorizeMigrationKey(migKey,migScheme,a))),
	(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_AuthorizeMigrationKey(migKey,migScheme,a))));

  authorize_migration_key_post: THEOREM 
   FORALL (state:(afterStartup?),k:(tpmKey?),scheme:(tpmMigScheme?),ai:authIn):
    LET(a,s) = runState(TPM_AuthorizeMigrationKey(k,scheme,ai))(state) IN
      a=OUT_AuthorizeMigrationKey(
		tpmMigKeyAuth(k,scheme,
			SHA1(concat(k,concat(scheme,s`permData`tpmProof)))),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(ai)#),
		TPM_SUCCESS) AND
      s=state WITH [`outData:=cons(tpmMigKeyAuth(k,scheme,
			SHA1(concat(k,concat(scheme,s`permData`tpmProof)))),
			outData(state))]


  %% 11.4 TPM_MigrateKey
  %% The TPM_MigrateKey command performs the function of a migration authority.
  %% The command is relatively simple; it just decrypts the input packet (coming
  %%  from TPM_CreateMigrationBlob or TPM_CMK_CreateBlob)and then re-encrypts it
  %%  with the input public key.The output of this command would then be sent to
  %%  TPM_ConvertMigrationBlob or TPM_CMK_ConvertMigration on the target TPM.
  %% TPM_MigrateKey does not make ANY assumptions about the contents of the 
  %%  encrypted blob. Since it does not have the XOR string, it cannot actually
  %%  determine much about the key that is being migrated.
  %% This command exists to permit the TPM to be a migration authority. If used
  %%  in this way, it is expected that the physical security of the system
  %%  containing the TPM and the AuthData value for the MA key would be tightly
  %%  controlled.
  %% To prevent the execution of this command using any other key as a parent
  %%  key,this command works only if keyUsage for maKeyHandle is TPM_KEY_MIGRATE
  TPM_MigrateKey(migKey,pubKey:(tpmKey?),data:(encrypted?),a:authIn) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) :
	      executeCom(s,ABS_MigrateKey(migKey,pubKey,data,a))),
	(LAMBDA (s:tpmAbsState) :
	      outputCom(s,ABS_MigrateKey(migKey,pubKey,data,a))));

  migrate_key_post: THEOREM 
   FORALL (state:(afterStartup?),mk,k:(tpmKey?),d:(encrypted?),ai:authIn) : 
    LET(a,s) = runState(TPM_MigrateKey(mk,k,d,ai))(state) IN
    LET d1=decrypt(d,private(mk),state`keys) IN
    IF migrateKey?(mk)
    THEN a=OUT_MigrateKey(encrypted(d1,key(k)),
			(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=usageAuth(encData(encDat(mk)))#),
			TPM_SUCCESS) AND 
	 s=state WITH [`outData:=cons(encrypted(d1,key(k)),outData(state))]
    ELSE a=OUT_Error(TPM_INAPPROPRIATE_ENC) OR
    	 a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ENDIF

  %% 11.5 TPM_CMK_SetRestrictions
  %% This command is used by the Owner to dictate the usage of a certified-
  %%  migration key with delegated authorization (authorization other than
  %%  actual owner authorization).
  %% This command is provided for privacy reasons and must not itself be
  %%  delegated, because a certified-migration-key may involve a contractual
  %%  relationship between the Owner and an external entity.
  %% Since restrictions are validated at DSAP session use, there is no need to
  %%  invalidate DSAP sessions when the restriction value changes.
  TPM_CMK_SetRestrictions(r:(tpmCMKDelegate?),i:authIn) : State = 
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_CMK_SetRestrictions(r,i))),
	   (LAMBDA (s:tpmAbsState):outputCom(s,ABS_CMK_SetRestrictions(r,i))));

  cmk_set_restr_post: THEOREM
   FORALL (state:(afterStartup?),r:(tpmCMKDelegate?),i:authIn) : 
    LET(a,s) = runState(TPM_CMK_SetRestrictions(r,i))(state) IN
   IF CMKSetRestr?(state,r,i)
   THEN LET a=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i)#) IN
        a=OUT_CMK_SetRestrictions(a,TPM_SUCCESS) AND
   	s=state WITH [`permData(restrictDelegate):=r]
   ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE) AND
   	s=state
   ENDIF;

  %% 11.6 TPM_CMK_ApproveMA
  %% This command creates an authorization ticket, to allow the TPM owner to
  %%  specify which Migration Authorities they approve and allow users to create
  %%  certified-migration-keys without further involvement with the TPM owner.
  %% It is the responsibility of the TPM Owner to determine whether a particular
  %%  Migration Authority is suitable to control migration
  TPM_CMK_ApproveMA(m:(tpmDigest?),i:authIn) : State = 
    modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_CMK_ApproveMA(m,i))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_CMK_ApproveMA(m,i))));

  cmk_approve_ma_post: THEOREM
   FORALL (state:(afterStartup?),migAuth:(tpmDigest?),i:authIn) : 
    LET(a,s) = runState(TPM_CMK_ApproveMA(migAuth,i))(state) IN
    a=OUT_CMK_ApproveMA(
	tpmHMAC(tpmCMKMAApproval(migAuth),state`permData`tpmProof),
	(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(i)#),
	TPM_SUCCESS) AND
    s=state WITH [`outData:=cons(tpmHMAC(tpmCMKMAApproval(migAuth),
					state`permData`tpmProof),
				outData(state))]

  %% 11.7 TPM_CMK_CreateKey
  %% The TPM_CMK_CreateKey command both generates and creates a secure storage
  %%  bundle for asymmetric keys whose migration is controlled by a migration 
  %%  authority.
  %% TPM_CMK_CreateKey is very similar to TPM_CreateWrapKey, but: (1) the
  %%  resultant key must be a migratable key and can be migrated only by
  %%  TPM_CMK_CreateBlob; (2) the command is Owner authorized via a ticket.
  %% TPM_CMK_CreateKey creates an otherwise normal migratable key except that
  %%  (1) migrationAuth is an HMAC of the migration authority and the new key’s
  %%  public key, signed by tpmProof (instead of being tpmProof); (2) the
  %%  migrationAuthority bit is set TRUE; (3) the payload type is
  %%  TPM_PT_MIGRATE_RESTRICTED.
  %% The migration-selection/migration authority is specified by passing in a
  %%  public key (actually the digests of one or more public keys, so more than
  %%  one migration authority can be specified).
  TPM_CMK_CreateKey(p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),a:(tpmDigest?),
	m:(tpmDigest?),i:authIn) : State = 
    modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,ABS_CMK_CreateKey(p,d,k,a,m,i))),
	(LAMBDA (s:tpmAbsState):outputCom(s,ABS_CMK_CreateKey(p,d,k,a,m,i))));

  cmk_create_key_post: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
   	  b:(tpmDigest?),m:(tpmDigest?),i:authIn) : 
    LET(a,s) = runState(TPM_CMK_CreateKey(p,d,k,b,m,i))(state) IN
    IF CMKCreateKey?(state,p,k,m,b) 
    THEN LET DU1=decryptADIP(d,authHandle(i)),				% 14
    	     ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,	% 15
			resAuth:=usageAuth(encData(encDat(p)))#),
	     pcr=tpmPCRInfoLong(s`stanyFlags`localityModifier,		% 18d
				locAtRelease(PCRInfo(k)), 
				creationPCRSelect(PCRInfo(k)),
				releasePCRSelect(PCRInfo(k)),
				tpmCompositeHash(
				  tpmPCRComposite(creationPCRSelect(PCRInfo(k)),
					s`pcrs)),			% 18c
				digAtRelease(PCRInfo(k))),
	     M2=tpmCMKMigAuth(m,					% 17di
             		      SHA1(tpmPubkey(algoParms(k),key(k)))) IN	% 17dii
	 LET enc=encrypted(tpmStoreAsymkey(DU1,			    	% 17a
%	     			 tpmHMAC(M2,s`permData`tpmProof),	% 17e
 				 tpmSecret(1),
% 				 %TODO: FIX THIS ^^^^ IT AIN'T RIGHT!
				 pubDataDigest(encData(encDat(k))),
				 private(k))
			,key(p)) IN		% 19
    	 LET wrappedKey=tpmKey(key(k),					% 13,17
	     		       keyUsage(k),
			       keyFlags(k),
			       authDataUsage(k),
			       algoParms(k),
			       pcr,					% 18
			       enc) IN
	 a=OUT_CMK_CreateKey(wrappedKey,ao,TPM_SUCCESS) AND
	 s=state WITH [`outData:=cons(wrappedKey,outData(state))]
    ELSIF not(storage?(keyUsage(p)) AND not(migratable(keyFlags(p))) AND
    	  migratable(keyFlags(k)) AND migrateAuthority(keyFlags(k)))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF not(validateMigrateAuthority?(s,m,b))
    THEN a=OUT_Error(TPM_MA_AUTHORITY) AND s=state
    ELSIF not(validateKeyParams?(k))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state		
    ELSIF not(checkFIPS?(s,k))
    THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSIF not(checkKey?(k))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF

  cmk_create_key_post2: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),d:(tpmEncAuth?),k:(tpmKey?),
   	  b:(tpmDigest?),m:(tpmDigest?),i:authIn) : 
    LET(a,s) = runState(TPM_CMK_CreateKey(p,d,k,b,m,i))(state) IN
    not CMKCreateKey?(state,p,k,m,b) =>
    not (a=OUT_Error(TPM_SUCCESS))

  %% 11.8 TPM_CMK_CreateTicket
  %% The TPM_CMK_CreateTicket command uses a public key to verify the signature 
  %%  over a digest.
  %% TPM_CMK_CreateTicket returns a ticket that can be used to prove the same
  %%  TPM that signature verification with a particular key was successful.
  TPM_CMK_CreateTicket(v:(tpmPubkey?),d:(tpmDigest?),l:tpmData,i:authIn):State=
    modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,ABS_CMK_CreateTicket(v,d,l,i))),
	(LAMBDA (s:tpmAbsState):outputCom(s,ABS_CMK_CreateTicket(v,d,l,i))));

  cmk_create_ticket_post: THEOREM
   FORALL (state:(afterStartup?),v:(tpmPubkey?),d:(tpmDigest?),l:tpmData,
   	  i:authIn) : 
    LET(a,s) = runState(TPM_CMK_CreateTicket(v,d,l,i))(state) IN
    IF CMKCreateTicket?(v,d)	
    THEN a=OUT_CMK_CreateTicket(tpmHMAC(tpmCMKSigTicket(SHA1(v),d)
				       ,state`permData`tpmProof),
			        (#nonceEven:=EVEN,nonceOdd:=ODD,
			          contAuthSess:=TRUE,resAuth:=ownerAuth(i)#),
			        TPM_SUCCESS)
    ELSIF not(validateKeyAlgo?(v))
    THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY)	
    ELSIF not(checkSig?(pubKey(v),d))
    THEN a=OUT_Error(TPM_BAD_SIGNATURE)
    ELSE a=OUT_Error(TPM_SUCCESS)
    ENDIF
    AND s=state;

  cmk_create_ticket_post2: THEOREM
   FORALL (state:(afterStartup?),v:(tpmPubkey?),d:(tpmDigest?),l:tpmData,
   	  i:authIn) : 
    LET(a,s) = runState(TPM_CMK_CreateTicket(v,d,l,i))(state) IN
    not CMKCreateTicket?(v,d) =>
    not (a=OUT_Error(TPM_SUCCESS));

  %% 11.9 TPM_CMK_CreateBlob
  %% TPM_CMK_CreateBlob command is very similar to TPM_CreateMigrationBlob,
  %%  except that it: (1) uses an extra ticket (restrictedKeyAuth) instead of a
  %%  migrationAuth authorization session; (2) uses the migration options
  %%  TPM_MS_RESTRICT_MIGRATE or TPM_MS_RESTRICT_APPROVE; (3) produces a
  %%  wrapped key blob whose migrationAuth is independent of tpmProof.
  %% If the destination (parent) public key is the MA, migration is implicitly
  %%  permitted. Further checks are required if the MA is not the destination
  %%  (parent) public key, and merely selects a migration destination: (1)
  %%  sigTicket must prove that restrictTicket was signed by the MA; (2)
  %%  restrictTicket must vouch that the target public key is approved for
  %%  migration to the destination (parent) public key. (Obviously, this more
  %%  complex method may also be used by an MA to approve migration to that MA.)
  %%  In both cases, the MA must be one of the MAs implicitly listed in the
  %%  migrationAuth of the target key-to-be-migrated.
  %% When the migrationType is TPM_MS_RESTRICT_MIGRATE, restrictTicket and
  %%  sigTicket are unused. The TPM may test that the corresponding sizes are
  %%  zero, so the caller should set them to zero for interoperability.
  TPM_CMK_CreateBlob(p:(tpmKey?),t:(tpmMigScheme?),m:(tpmMigKeyAuth?),
	k:(tpmDigest?),l:(tpmMSAComposite?),r:(tpmCMKAuth?),d:(tpmDigest?),
	e:(encrypted?),i:authIn):State=
    modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,
			ABS_CMK_CreateBlob(p,t,m,k,l,r,d,e,i))),
	(LAMBDA (s:tpmAbsState):outputCom(s,
			ABS_CMK_CreateBlob(p,t,m,k,l,r,d,e,i))));

  cmk_create_blob_post: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),t:(tpmMigScheme?),
   	  m:(tpmMigKeyAuth?),k:(tpmDigest?),l:(tpmMSAComposite?),
	  r:(tpmCMKAuth?),d:(tpmDigest?),e:(encrypted?),i:authIn) : 
    LET(a,s) = runState(TPM_CMK_CreateBlob(p,t,m,k,l,r,d,e,i))(state) IN
    IF CMKCreateBlob?(state,p,t,m,k,l,e)
    THEN OUT_CMK_CreateBlob?(a) AND
    	 s=state WITH [`outData:=cons(random(a),cons(data(a),outData(state)))]
    ELSE OUT_Error?(a) AND s=state
    ENDIF;

  cmk_create_blob_post2: THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),t:(tpmMigScheme?),
   	  m:(tpmMigKeyAuth?),k:(tpmDigest?),l:(tpmMSAComposite?),
	  r:(tpmCMKAuth?),d:(tpmDigest?),e:(encrypted?),i:authIn) : 
    LET(a,s) = runState(TPM_CMK_CreateBlob(p,t,m,k,l,r,d,e,i))(state) IN
    checkDecrypt?(e,private(p),state`keys) =>
    LET d1=decrypt(e,private(p),state`keys) IN
    tpmStoreAsymkey?(d1) AND
    not CMKCreateBlob?(state,p,t,m,k,l,e) =>
    not a=OUT_Error(TPM_SUCCESS);

  %% 11.10 TPM_CMK_ConvertMigration
  %% TPM_CMK_ConvertMigration completes the migration of certified mig blobs
  %% This command takes a certified migration blob and creates a normal wrapped
  %%  blob with payload type TPM_PT_MIGRATE_EXTERNAL. The migrated blob must be
  %%  loaded into the TPM using the normal TPM_LoadKey function.
  %% Note that the command migrates private keys, only. The migration of the
  %%  associated public keys is not specified by TPM because they are not
  %%  security sensitive. Migration of the associated public keys may be
  %%  specified in a platform specific specification. A TPM_KEY structure must
  %%  be recreated before the migrated key can be used by the target TPM in a
  %%  TPM_LoadKey command.
  %% TPM_CMK_ConvertMigration checks that one of the MAs implicitly listed in
  %%  the migrationAuth of the target key has approved migration of the target
  %%  key to the destination (parent) key, and that the settings (flags etc.)
  %%  in the target key are those of a CMK.
  TPM_CMK_ConvertMigration(p:(tpmKey?),r:(tpmCMKAuth?),t:(tpmDigest?),
	m:(tpmKey?),l:(tpmMSAComposite?),n:(RNG?),i:authIn) : State =
    modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,
			ABS_CMK_ConvertMigration(p,r,t,m,l,n,i))),
	(LAMBDA (s:tpmAbsState):outputCom(s,
			ABS_CMK_ConvertMigration(p,r,t,m,l,n,i))));
 
  cmk_convert_migration_post : THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),r:(tpmCMKAuth?),t:(tpmDigest?),
   	   m:(tpmKey?),l:(tpmMSAComposite?),n:(RNG?),i:authIn) :
    LET (a,s) = runState(TPM_CMK_ConvertMigration(p,r,t,m,l,n,i))(state) IN
    LET d1=decrypt(encDat(m),private(p),state`keys) IN
    LET o1=unXOR(d1,n) IN
    LET m1=OAEPdecode(o1),
	migratedPubKey=tpmPubkey(algoParms(m),key(m)) IN
    LET k1=partPrivKey(m1),
        M2=tpmCMKMigAuth(SHA1(l),SHA1(migratedPubKey)) IN
    LET d2=encrypted(tpmStoreAsymkey(usageAuth(m1),
				tpmSecret(1),
		% 		tpmHMAC(M2,state`permData`tpmProof),
				pubDataDigest(m1),k1),
			key(p)) IN
    LET parentPubKey=tpmPubkey(algoParms(p),key(p)) IN
    	 IF CMKConvertMigration?(state,p,r,m,l,o1) 
    	 THEN LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		  resAuth:=usageAuth(encData(encDat(p)))#) IN
    	      a=OUT_CMK_ConvertMigration(d2,ao,TPM_SUCCESS) AND
	      s=state WITH [`outData:=cons(d2,outData(state))]
    	 ELSIF not(storage?(keyUsage(p)))
    	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    	 ELSIF pHash(o1)/=SHA1(concat(SHA1(l),SHA1(migratedPubKey)))
    	 THEN a=OUT_Error(TPM_SHA_ERROR) AND s=state
    	 ELSIF migratable(keyFlags(p)) 
    	 THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
	 ELSIF not tpmMigrateAsymkey?(m1)
	 THEN a=OUT_Error(TPM_BAD_MIGRATION) AND s=state
    	 ELSIF destKey(r)/=SHA1(parentPubKey)
    	 THEN a=OUT_Error(TPM_MA_DESTINATION) AND s=state
    	 ELSIF not(private(m)=privKey(encData(d2)) AND
    	      pubDataDigest(encData(encDat(m)))=pubDataDigest(encData(d2)) AND
	      usageAuth(encData(encDat(m)))=usageAuth(encData(d2)))
    	 THEN a=OUT_Error(TPM_BAD_KEY_PROPERTY) AND s=state
    	 ELSIF not(migratable(keyFlags(m))) OR
    	       not(migrateAuthority(keyFlags(m)))
    	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    	 ELSIF sourceKey(r)/=SHA1(migratedPubKey)
    	 THEN a=OUT_Error(TPM_MA_SOURCE) AND s=state
    	 ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    	 ENDIF;

  cmk_convert_migration_post2 : THEOREM
   FORALL (state:(afterStartup?),p:(tpmKey?),r:(tpmCMKAuth?),t:(tpmDigest?),
   	   m:(tpmKey?),l:(tpmMSAComposite?),n:(RNG?),i:authIn) :
    LET (a,s) = runState(TPM_CMK_ConvertMigration(p,r,t,m,l,n,i))(state) IN
    checkDecrypt?(encDat(m),private(p),state`keys) =>
    LET d1=decrypt(encDat(m),private(p),state`keys) IN
    tpmXOR?(d1) =>
    LET o1:(OAEP?)=unXOR(d1,n) IN
    not (CMKConvertMigration?(state,p,r,m,l,o1)) =>
    not (a=OUT_Error(TPM_SUCCESS));

  %% 12. Maintenance Functions (optional) TODO
  
  %% 13. Cryptographic Functions
  %% 13.1 TPM_SHA1Start  TODO
  %% 13.2 TPM_SHA1Update  TODO
  %% 13.3 TPM_SHA1Complete  TODO
  %% 13.4 TPM_SHA1CompleteExtend  TODO

  %% 13.5 TPM_Sign
  %% The Sign command signs data and returns the resulting digital signature.
  %% The TPM does not allow TPM_Sign with a TPM_KEY_IDENTITY (AIK) because
  %%  TPM_Sign can sign arbitrary data and could be used to fake a quote. (This 
  %%  could have been relaxed to allow TPM_Sign with an AIK if the signature 
  %%  scheme is _INFO For an _INFO key, the metadata prevents TPM_Sign from 
  %%  faking a quote.)
  TPM_Sign(k:(tpmKey?),areaToSign:tpmData) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_Sign(k,areaToSign))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Sign(k,areaToSign))));
	   
  sign_post: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),b:tpmData) :
      LET(a,s) = runState(TPM_Sign(k,b))(state) IN
	IF legacy?(keyUsage(k)) or signing?(keyUsage(k))
	THEN IF not(member(private(k),vals(s`keys))) OR cryptoError?(b)
	     THEN a=OUT_CPUError(CPU_SIGN_ERROR) AND s=state
	     ELSE a=OUT_Sign(signed(b,private(k)),TPM_SUCCESS) AND
	     	  s=state WITH [`outData:=
				    cons(signed(b,private(k)),outData(state))]
	     ENDIF
	ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
	ENDIF;

  sign_pred_test : THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),b:tpmData) :
      LET(a,s) = runState(TPM_Sign(k,b))(state) IN
	IF sign?(state,k,b)
	THEN IF not(member(private(k),vals(s`keys))) or cryptoError?(b)
	     THEN a=OUT_CPUError(CPU_SIGN_ERROR) AND s=state
	     ELSE a=OUT_Sign(signed(b,private(k)),TPM_SUCCESS) AND 
	     	  s=state WITH [`outData:=cons(signed(b,private(k)),
						outData(state))]
	     ENDIF
	ELSE a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
	ENDIF
	
  %% 13.6 TPM_GetRandom
  %% TPM_GetRandom returns the next bytesRequested bytes from the random number
  %%  generator to the caller.
  %% It is recommended that a TPM implement the RNG in a manner that would allow
  %%  it to return RNG bytes such that the frequency of bytesRequested being
  %%  more than the number of bytes available is an infrequent occurrence.
  TPM_GetRandom : State =
     modifyOutput(
	(LAMBDA(s:tpmAbsState):executeCom(s,ABS_GetRandom)),
        (LAMBDA(s:tpmAbsState):outputCom(s,ABS_GetRandom)));

  %% 13.7 TPM_StirRandom
  %% TPM_StirRandom adds entropy to the RNG state.
  TPM_StirRandom(i:nat) : State =
     modifyOutput(
	(LAMBDA(s:tpmAbsState):executeCom(s,ABS_StirRandom(i))),
        (LAMBDA(s:tpmAbsState):outputCom(s,ABS_StirRandom(i))));

  %% 13.8 TPM_CertifyKey
  %% TODO: info
  TPM_CertifyKey(c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) : State =
     modifyOutput(
	(LAMBDA(s:tpmAbsState):executeCom(s,ABS_CertifyKey(c,k,n,i1,i2))),
        (LAMBDA(s:tpmAbsState):outputCom(s,ABS_CertifyKey(c,k,n,i1,i2))));

  certify_key_post: THEOREM
   FORALL (state:(afterStartup?),c,k:(tpmKey?),n:(tpmNonce?),i1,i2:authIn) : 
    LET (a,s) = runState(TPM_CertifyKey(c,k,n,i1,i2))(state) IN
    IF certifyKey?(state,c,k) 
    THEN LET c1=tpmCertifyInfo(keyUsage(k),keyFlags(k),authDataUsage(k),
			algoParms(k),SHA1(k),n,FALSE,PCRInfo(k)),
             o1:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(c)))#),
             o2:authOut=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#) IN 
	 a=OUT_CertifyKey(c1,signed(SHA1(c1),private(c)),o1,o2,TPM_SUCCESS) AND
	 s=state WITH [`outData:=cons(c1,cons(signed(SHA1(c1),private(c)),
					outData(state)))]
    ELSE OUT_Error?(a) AND    %TODO: SPECIFICS
	 s=state
    ENDIF;  

  %% 13.9 TPM_CertifyKey2 TODO

  %% 14. Endorsement Key Handling
  %% There are two create EK commands. The first matches the 1.1 functionality.
  %%  The second provides the mechanism to enable revokeEK.
  %% The TPM and platform manufacturer decide on the inclusion or exclusion of
  %%  the ability to execute revokeEK.
  %% The restriction to have the TPM generate the EK does not remove the
  %%  manufacturing option to “squirt” the EK. During manufacturing, the TPM
  %%  does not enforce all protections or requirements; hence, the restriction
  %%  on only TPM generation of the EK is also not in force.

  %% A TPM SHALL NOT install an EK unless generated on the TPM by execution of
  %%  TPM_CreateEndorsementKeyPair or TPM_CreateRevocableEK

  %% 14.1 TPM_CreateEndorsementKeyPair
  %% This command creates the TPM endorsement key. It returns a failure code if
  %%  an endorsement key already exists.
  TPM_CreateEndorsementKeyPair(n:(tpmNonce?),k:(tpmKey?)) : State =
     %% TODO: Perm Data stuff with RNG
     modifyOutput(
	(LAMBDA(s:tpmAbsState):executeCom(s,ABS_CreateEndorsementKeyPair(n,k))),
        (LAMBDA(s:tpmAbsState):outputCom(s,ABS_CreateEndorsementKeyPair(n,k))));

  create_endorsement_key_pair_post: THEOREM
   FORALL (state:(afterStartup?),k:(tpmKey?),n:(tpmNonce?)) : 
    LET (a,s) = runState(TPM_CreateEndorsementKeyPair(n,k))(state) IN
    IF key(ek(state))=badkey 
    THEN a=OUT_CreateEndorsementKeyPair(k,
		SHA1(concat(k,n)),TPM_SUCCESS) AND
	 s=state WITH [`ek := k
      	     	      ,`permFlags(CEKPUsed) := TRUE
		      ,`permFlags(enableRevokeEK) := FALSE
		      ,`outData:=cons(k,cons(SHA1(concat(k,n)),outData(state)))]
    ELSE a=OUT_Error(TPM_DISABLED_CMD) AND 
	 s=state
    ENDIF;

  %% 14.2 TPM_CreateRevocableEK
  %% TODO: info
  TPM_CreateRevocableEK(a:(tpmNonce?),k:(tpmKey?),g:bool,i:(tpmNonce?)) :State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_CreateRevocableEK(a,k,g,i))),
        (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_CreateRevocableEK(a,k,g,i))));

  create_revocable_ek_post: THEOREM
   FORALL (state:(afterStartup?),a,i:(tpmNonce?),k:(tpmKey?),g:bool) : 
    LET (a,s) = runState(TPM_CreateRevocableEK(a,k,g,i))(state) IN
    IF key(ek(state)) = badkey
    THEN a=OUT_CreateRevocableEK(tpmPubkey(algoParms(k),key(k)),
				SHA1(concat(k,a)),
				s`permData`ekReset,
				TPM_SUCCESS) AND
	 s=state WITH [`ek := k
      	     	      ,`permFlags(CEKPUsed) := TRUE
		      ,`permFlags(enableRevokeEK) := TRUE
		      ,`permData(ekReset):=IF g 
		      			   THEN tpmNonce(n(RNG(state`randCnt)))
					   ELSE i ENDIF 
		      ,`outData:=cons(tpmPubkey(algoParms(k),key(k)),
					cons(SHA1(concat(k,a)),
						cons(s`permData`ekReset,
						outData(state))))
		      ,`randCnt:=randCnt(state)+1]
    ELSE a=OUT_Error(TPM_DISABLED_CMD) AND 
	 s=state
    ENDIF;

  %% 14.3 TPM_RevokeTrust
  %% This command clears the EK and sets the TPM back to a pure default state.
  %%  The generation of the AuthData value occurs during the generation of the
  %%  EK. It is the responsibility of the EK generator to properly protect and
  %%  disseminate the RevokeTrust AuthData.
  TPM_RevokeTrust(r:(tpmNonce?)) : State = 
    modifyOutput(
            (LAMBDA (s:tpmAbsState) : executeCom(s,ABS_RevokeTrust(r))),
            (LAMBDA (s:tpmAbsState) : outputCom(s,ABS_RevokeTrust(r)))
	    );
	    
  revoke_trust_post : THEOREM
   FORALL (state:(afterStartup?),EKReset:(tpmNonce?)) : 
    LET (a,s) = runState(TPM_RevokeTrust(EKReset))(state) IN
    IF revokeTrust?(state,EKReset)
    THEN a=OUT_RevokeTrust(TPM_SUCCESS) AND
	 LET s1=clear(state) IN
	     s=s1 WITH [`permFlags(nvLocked):=FALSE,
	     	        `ek:=tpmKey(0,keyUsage(s`ek),keyFlags(s`ek),
				authDataUsage(s`ek),algoParms(s`ek),
			      	PCRInfo(s`ek),encDat(s`ek))]
    ELSIF not state`permFlags`enableRevokeEK
    THEN a=OUT_Error(TPM_PERMANENTEK) AND s=state
    ELSIF state`permData`ekReset/=EKReset
    THEN a=OUT_Error(TPM_AUTHFAIL) AND s=state
    ELSIF not s`stclearFlags`physicalPresence
    THEN a=OUT_Error(TPM_BAD_MODE) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;

  revoke_trust_post2 : THEOREM
   FORALL (state:(afterStartup?),EKReset:(tpmNonce?)) : 
    LET (a,s) = runState(TPM_RevokeTrust(EKReset))(state) IN
    not revokeTrust?(state,EKReset) =>
    not a=OUT_Error(TPM_SUCCESS)

  %% 14.4 TPM_ReadPubek
  %% Return the endorsement key public portion. This value should have controls
  %%  placed upon access, as it is a privacy sensitive value.
  %% The readPubek flag is set to FALSE by TPM_TakeOwnership and set to TRUE by
  %%  TPM_OwnerClear, thus mirroring if a TPM Owner is present.
  TPM_ReadPubek(n:(tpmNonce?)) : State =
     output(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_ReadPubek(n)));

  read_pub_ek_post: THEOREM
    FORALL (state:(afterStartup?),n:(tpmNonce?)) : 
      LET (a,s) = runState(TPM_ReadPubek(n))(state) IN
    a=IF readPubek?(state,n)
      THEN LET pubEndoK=ek(state) IN
      	   OUT_ReadPubek(pubEndoK,
		SHA1(concat(pubEndoK,n)),
		TPM_SUCCESS)
      ELSIF not state`permFlags`readPubek
      THEN OUT_Error(TPM_DISABLED_CMD)
      ELSIF not goodkey?(key(ek(state)))
      THEN OUT_Error(TPM_NO_ENDORSEMENT)
      ELSE OUT_Error(TPM_SUCCESS)
      ENDIF
    AND s=state;

  read_pub_ek_post2: THEOREM
    FORALL (state:(afterStartup?),n:(tpmNonce?)) : 
      LET (a,s) = runState(TPM_ReadPubek(n))(state) IN
    not readPubek?(state,n) =>
    not a=OUT_Error(TPM_SUCCESS);

  read_pub_ek_take_ownership: THEOREM
    FORALL (state:(afterStartup?),n:(tpmNonce?),srk:(tpmKey?),
  	eOA,eSA:(encrypted?),i:authIn) :  
      LET (a,s) = runState(
      	  	  TPM_TakeOwnership(eOA,eSA,srk,i)
		  >> TPM_ReadPubek(n))
		  (state) IN
    checkDecrypt?(eOA,private(s`ek),state`keys) AND 
    tpmSecret?(encData(eOA)) AND
    checkDecrypt?(eSA,private(s`ek),state`keys) AND
    tpmSecret?(encData(eSA)) AND
    takeOwnership?(state,srk,eOA,eSA) =>
      a=OUT_Error(TPM_DISABLED_CMD);

  %% 14.5 TPM_OwnerReadInternalPub
  %% A TPM Owner authorized command that returns public portion of the EK or SRK
  %% The keyHandle parameter is included in incoming session authorization to
  %%  prevent alteration of the value, causing a different key to be read.
  %%  Unlike most key handles, which can be mapped by higher layer software,
  %%  this key handle has only two fixed values.
  TPM_OwnerReadInternalPub(k:(tpmKey?),a:authIn) : State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_OwnerReadInternalPub(k,a))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_OwnerReadInternalPub(k,a))));

  owner_read_internal_pub_post: THEOREM
    FORALL (state:(afterStartup?),k:(tpmKey?),ai:authIn) : 
      LET (a,s) = runState(TPM_OwnerReadInternalPub(k,ai))(state) IN
      LET ao=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
		resAuth:=ownerAuth(ai)#) IN
      IF key(k)=ekKeyVal OR key(k)=srkKeyVal 
      THEN a=OUT_OwnerReadInternalPub(tpmPubkey(algoParms(k),key(k)),ao,
			TPM_SUCCESS) AND 
	   s=state WITH [`outData:=cons(tpmPubkey(algoParms(k),key(k)),
					outData(state))]
      ELSE a=OUT_Error(TPM_BAD_PARAMETER) AND s=state
      ENDIF;
      
  %% 15. Identity Creation and Activation
  %% 15.1 TPM_MakeIdentity
  %% Generate a new Attestation Identity Key (AIK)
  %% labelPrivCADigest identifies the privacy CA that the owner expects to be
  %%  the target CA for 2912the AIK. The selection is not enforced by the TPM.
  %%  It is advisory only. It is included because the TSS cannot be trusted to
  %%  send the AIK to the correct privacy CA. The privacy CA can use this
  %%  parameter to validate that it is the target privacy CA and label intended
  %%  by the TPM owner at the time the key was created. The label can be used to
  %%  indicate an application purpose.
  TPM_MakeIdentity(e:(tpmEncAuth?),d:(tpmDigest?),k:(tpmKey?),a1,a2:authIn) : 
  	State =
     modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,ABS_MakeIdentity(e,d,k,a1,a2))),
        (LAMBDA (s:tpmAbsState):outputCom(s,ABS_MakeIdentity(e,d,k,a1,a2))));

  make_identity_post: THEOREM 
   FORALL (state:(afterStartup?),e:(tpmEncAuth?),d:(tpmDigest?),k:(tpmKey?),
		i1,i2:authIn) :
    LET (a,s) = runState(TPM_MakeIdentity(e,d,k,i1,i2))(state) IN
    IF makeIdentity?(state,k)
    THEN LET A1=decryptADIP(e,authHandle(i2)),
    	     o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=usageAuth(encData(encDat(state`srk)))#),
	     o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=ownerAuth(i2)#) IN
      	 LET pcr=tpmPCRInfoLong(makeIdentityLocality,
			locAtRelease(PCRInfo(k)),
			creationPCRSelect(PCRInfo(k)),
			releasePCRSelect(PCRInfo(k)),
			tpmCompositeHash(
			    tpmPCRComposite(creationPCRSelect(PCRInfo(k)),
					pcrs(state))),
			digAtRelease(PCRInfo(k))),
	     encData=encrypted(tpmStoreAsymkey(A1,
				s`permData`tpmProof,
				pubDataDigest(encData(encDat(k))),
				private(k)),
			key(state`srk)) IN
         LET waik=tpmKey(keyGenCnt(state),
			keyUsage(k),
			keyFlags(k),
			authDataUsage(k),
			algoParms(k),
			pcr,
			encData) IN
	 IF not(member(private(k),vals(state`keys)))
	 THEN a=OUT_CPUError(CPU_SIGN_ERROR) AND
	      s=state
	 ELSE LET idBind=signed(tpmIdContents(d,waik),private(waik)) IN
	      a=OUT_MakeIdentity(waik,idBind,o1,o2,TPM_SUCCESS) AND
	      s=state WITH [`keyGenCnt := keyGenCnt(state)+1
	      	      	   ,`outData:=cons(waik,cons(idBind,outData(state)))]
	 ENDIF
    ELSIF state`permFlags`FIPS AND never?(authDataUsage(k))
    THEN a=OUT_Error(TPM_NOTFIPS) AND s=state
    ELSIF not identity?(keyUsage(k))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSIF migratable(keyFlags(k))
    THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;
      
  make_identity_post2 : THEOREM
   FORALL (state:(afterStartup?),e:(tpmEncAuth?),d:(tpmDigest?),k:(tpmKey?),
		i1,i2:authIn) :
    LET (a,s) = runState(TPM_MakeIdentity(e,d,k,i1,i2))(state) IN
    not makeIdentity?(state,k) =>
     not a=OUT_Error(TPM_SUCCESS)


  %% 15.2 TPM_ActivateIdentity
  %% The purpose of TPM_ActivateIdentity is to twofold. The first purpose is to
  %%  obtain assurance that the credential in the TPM_SYM_CA_ATTESTATION is for
  %%  this TPM. The second purpose is to obtain the session key used to encrypt
  %%  the TPM_IDENTITY_CREDENTIAL.
  %% This is an extension to the 1.1 functionality of TPM_ActivateIdentity. The
  %%  blob sent to from the CA can be in the 1.1 format or the 1.2 format. The
  %%  TPM determines the type from the size or version information in the blob.
  %% TPM_ActivateIdentity checks that the symmetric session key corresponds to a
  %%  TPM-identity before releasing that session key.
  %% Only the Owner of the TPM has the privilege of activating a TPM identity.
  %%  The Owner is required to authorize the TPM_ActivateIdentity command. The
  %%  owner may authorize the command using either the TPM_OIAP or TPM_OSAP
  %%  authorization protocols.
  %% The creator of the ActivateIdentity package can specify if any PCR values
  %%  are to be checked before releasing the session key.
  TPM_ActivateIdentity(a:(tpmKey?),b:(encrypted?),
	a1,a2:authIn) : State =
     modifyOutput(
        (LAMBDA (s:tpmAbsState): executeCom(s,ABS_ActivateIdentity(a,b,a1,a2))),
        (LAMBDA (s:tpmAbsState): outputCom(s,ABS_ActivateIdentity(a,b,a1,a2))));

  %% Assure that activate idenity installs its AIK and returns K if AIK can
  %% be installed.
  activate_identity_post: THEOREM 
   FORALL (state:(afterStartup?),aik:(tpmKey?),blob:(encrypted?),
		i1,i2:authIn) :
    LET (a,s) = runState(TPM_ActivateIdentity(aik,blob,i1,i2))(state) IN     
    LET o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(aik)))#),
	o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=ownerAuth(i2)#),
     	h1=tpmDigest(cons(tpmPubkey(algoParms(aik),key(aik)),null)),
    	b1=decrypt(blob,private(state`ek),state`keys) IN
    IF not identity?(keyUsage(aik))
    THEN a=OUT_Error(TPM_BAD_PARAMETER) AND s=state
    ELSE IF activateIdentity?(state,aik,blob)
    	 THEN CASES b1 OF
    	        tpmEKBlob(b):CASES b OF
	   		     tpmEKBlobActivate(s0,d0,p0) : 
			     	a=OUT_ActivateIdentity(s0,o1,o2,TPM_SUCCESS) AND
	 	     		s=state WITH [`outData:=cons(s0,outData(state))]
	   		       ELSE a=OUT_Error(TPM_BAD_TYPE) AND s=state
	   		       ENDCASES,
    	        tpmAsymCAContents(k,d):
			a=OUT_ActivateIdentity(k,o1,o2,TPM_SUCCESS) AND
			s=state WITH [`outData:=cons(k,outData(state))]
                ELSE a=OUT_ActivateIdentity(badData,
				o1 WITH [`resAuth:=badData],o2,TPM_SUCCESS) AND
	 	     s=state WITH [`outData:=cons(badData,outData(state))]
    	        ENDCASES
    	 ELSE CASES b1 OF
                tpmEKBlob(b) : CASES b OF
			        tpmEKBlobActivate(k,d,p) : 
			        LET C1=tpmCompositeHash(
						tpmPCRComposite(pcrSelect(p),
				  	  	  pcrs(state))) IN
			        IF h1/=d
			        THEN a=OUT_Error(TPM_BAD_PARAMETER) AND 
				     s=state
			        ELSIF not(null?(pcrSelect(p))) AND 
			   	      C1/=digAtRelease(p)
			        THEN a=OUT_Error(TPM_WRONGPCRVAL) AND s=state
			        ELSIF not member(state`locality,locAtRelease(p))
			        THEN a=OUT_Error(TPM_BAD_LOCALITY) AND s=state
			        ELSE a=OUT_ActivateIdentity(sKey(b),o1,o2,
							TPM_SUCCESS) AND 
				     s=state WITH [`outData:=cons(sKey(b),
							        outData(state))]
			        ENDIF
			        ELSE a=OUT_Error(TPM_BAD_TYPE) AND s=state
			       ENDCASES,
                tpmAsymCAContents(k,d) : a=OUT_Error(TPM_BAD_PARAMETER) AND
	      			       	 s=state
              ENDCASES
              ENDIF
   ENDIF;

  activate_identity_pred_test: THEOREM 
   FORALL (state:(afterStartup?),aik:(tpmKey?),blob:(encrypted?),
		i1,i2:authIn) :
    LET (a,s) = runState(TPM_ActivateIdentity(aik,blob,i1,i2))(state) IN     
    LET b1=decrypt(blob,private(state`ek),state`keys) IN
    IF activateIdentity?(state,aik,blob)
    THEN OUT_ActivateIdentity?(a) AND 
    	 CASES b1 OF
	   tpmEKBlob(blob) : 
	     CASES blob OF
	     tpmEKBlobActivate(k,d,p) : 
	     	s=state WITH [`outData:=cons(k,outData(state))] 
	     ELSE s=state
	     ENDCASES,
    	   tpmAsymCAContents(k,d) :
	   	s=state WITH [`outData:=cons(k,outData(state))] 
    	   ELSE s=state WITH [`outData:=cons(badData,outData(state))]
	   ENDCASES
    ELSE OUT_Error?(a) AND s=state
    ENDIF;

  activate_identity_post2 : THEOREM
   FORALL (state:(afterStartup?),aik:(tpmKey?),blob:(encrypted?),
		i1,i2:authIn) :
    LET (a,s) = runState(TPM_ActivateIdentity(aik,blob,i1,i2))(state) IN
    not activateIdentity?(state,aik,blob) =>
     not a=OUT_Error(TPM_SUCCESS)

  %% 16. Integrity Collection and Reporting
  %% This section deals with what commands have direct access to the PCR.

  %% 16.1 TPM_Extend
  %% This adds a new measurement to a PCR
  TPM_Extend(n:PCRINDEX,h:HV):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_Extend(n,h))),
           (LAMBDA (s:tpmAbsState):outputCom(s,ABS_Extend(n,h))));
  
  extend_post : THEOREM
   FORALL (state:(afterStartup?),h:HV,n:PCRINDEX) : 
    LET (a,s) = runState(TPM_Extend(n,h))(state) IN
    LET L1=s`stanyFlags`localityModifier,
    	P1=pcrExtendLocal(state`permData`pcrAttrib(n)),
	H1=pcrsExtend(state`pcrs,n,h) IN
    IF extend?(state,n,h)
    THEN IF state`permFlags`disable OR state`stclearFlags`deactivated
    	 THEN a=OUT_Extend(tpmPCRValue(reset),TPM_SUCCESS) AND 
    	      s=state WITH [`pcrs:=H1]
    	 ELSE a=OUT_Extend(tpmPCRValue(extend(state`pcrs(n),h)),TPM_SUCCESS) AND
    	      s=state WITH [`pcrs:=H1
	      	      	   ,`outData:=cons(tpmPCRValue(extend(state`pcrs(n),h)),
						state`outData)]
	 ENDIF
    ELSIF n>23 OR n<0
    THEN a=OUT_Error(TPM_BADINDEX) AND
    	 s=state
    ELSIF not member(L1,P1)
    THEN a=OUT_Error(TPM_BAD_LOCALITY) AND
    	 s=state 
    ELSE a=OUT_Error(TPM_SUCCESS) AND s=state
    ENDIF;

  extend_post2 : THEOREM
   FORALL (state:(afterStartup?),h:HV,n:PCRINDEX) : 
    LET (a,s) = runState(TPM_Extend(n,h))(state) IN
    LET L1=s`stanyFlags`localityModifier,
    	P1=pcrExtendLocal(state`permData`pcrAttrib(n)),
	H1=pcrsExtend(state`pcrs,n,h) IN
    not extend?(state,n,h) =>
    not a=OUT_Error(TPM_SUCCESS)
  

  %% Extend is antisymmetric if the hash values used for extension are
  %% not equal.  In this example we use the LET form to define
  %% commands directly with monad functions defined in StateMonad.pvs
  antisymmetryMonad: THEOREM 
   FORALL (state:(afterStartup?),hv0,hv1:HV,n:PCRINDEX) :
    LET f1:State =
        modify(OUT_Nothing,
               (LAMBDA (s:tpmAbsState):
		 s WITH [`pcrs:=pcrsExtend(pcrs(s),n,hv0)])),
      	f2:State =
        modify(OUT_Nothing,
               (LAMBDA (s:tpmAbsState):
		 s WITH [`pcrs:=pcrsExtend(pcrs(s),n,hv1)])) IN
    hv0/=hv1 =>
      runState(f2 >>= (LAMBDA (x:tpmAbsOutput): f1))(tpmStartup(state))
      /=
      runState(f1 >>= (LAMBDA (x:tpmAbsOutput): f2))(tpmStartup(state));

  %% Extending a reset PCR is antisymmetric if the two values are not equal
  %% Let form used to defined commands for bind.  Will use command forms
  %% later in antisymmetryMonad3
  antisymmetryMonad2: THEOREM 
   FORALL (state:(afterStartup?),hv0,hv1:HV,n:PCRINDEX) :
    LET f1:State=TPM_Extend(n,hv0),
      	f2:State=TPM_Extend(n,hv1) IN
    extend?(state,n,hv0) AND extend?(state,n,hv1) AND
    not(state`stclearFlags`deactivated OR state`permFlags`disable) AND
    %IF flags are set, the result will be same (OUT_Extend(reset,TPM_SUCCESS))
    hv0/=hv1 =>
      runState(f2 >> f1)(state)
      /=
      runState(f1 >> f2)(state)

  %% Extending a reset PCR is antisymmetric if the two values are not equal.
  %% No let form - commands appear directly in bind
  %% Theorem is now false when PCRs other than PCR0 are included.
  antisymmetryMonad3: THEOREM 
   FORALL (state:(afterStartup?),hv0,hv1:HV,n:PCRINDEX) :
    extend?(state,n,hv0) AND extend?(state,n,hv1) AND
    not(state`stclearFlags`deactivated OR state`permFlags`disable) AND
    %IF flags are set, the result will be same (OUT_Extend(reset,TPM_SUCCESS))
    hv0/=hv1 =>
       runState(TPM_Extend(n,hv1)
	     >> TPM_Extend(n,hv0))
	     (state)
     /=
       runState(TPM_Extend(n,hv0)
	     >> TPM_Extend(n,hv1))
	     (state)


  %% 16.2 TPM_PCRRead
  %% The TPM_PCRRead operation provides non-cryptographic reporting of the 
  %%  contents of a named PCR.
  TPM_PCRRead(i:PCRINDEX) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_PCRRead(i))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_PCRRead(i))));

  pcr_read_post: THEOREM
    FORALL (state:(afterStartup?),i:PCRINDEX) : 
      LET(a,s) = runState(TPM_PCRRead(i))(state) IN
    IF i > 23 OR i < 0
    THEN a=OUT_Error(TPM_BADINDEX) AND 
    	 s=state
    ELSE a=OUT_PCRRead(tpmPCRValue(state`pcrs(i)),TPM_SUCCESS) AND
    	 s=state WITH [`outData:=cons(tpmPCRValue(state`pcrs(i)),state`outData)]
    ENDIF


  %% 16.3 TPM_Quote
  %% The TPM_Quote operation provides cryptographic reporting of PCR values. A
  %%  loaded key is required for operation. TPM_Quote uses a key to sign a
  %%  statement that names the current value of a chosen PCR and externally
  %%  supplied data (which may be a nonce supplied by a Challenger).
  %% The term "ExternalData" is used because an important use of TPM_Quote is to
  %%  provide a digital signature on arbitrary data where the signature includes
  %%  the PCR values of the platform at time of signing.Hence the "ExternalData"
  %%  is not just for anti-replay purposes, although it is (of course) used for
  %%  that purpose in an integrity challenge.
  %% TPM_Quote should not use a TPM_KEY_SIGNING, because there is no way for the
  %%  remote party to tell whether TPM_Quote or TPM_Sign created the signature.
  %%  The exception is a TPM_KEY_SIGNING key with the _INFO signature scheme,
  %%  because the metadata differentiates TPM_Sign from TPM_Quote.
  TPM_Quote(k:(tpmKey?),n:(tpmNonce?),pm:PCR_SELECTION,i:authIn) : State = 
     modifyOutput(
	(LAMBDA (s:tpmAbsState) : executeCom(s,ABS_Quote(k,n,pm,i))),
	(LAMBDA (s:tpmAbsState) : outputCom(s,ABS_Quote(k,n,pm,i))));

  %% Prove that quote generation returns the correct PCR.  This theorem
  %% needs to be updated with something cleaner.
  %% proven - Wed Jul 11 10:40:28 EDT 2012
  quote_post: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),n:(tpmNonce?),p:PCR_SELECTION,
		i:authIn) :
        LET (a,s) = runState(TPM_Quote(k,n,p,i))(state) IN 
	IF not quote?(k)
	THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND 
	     s=state
	ELSIF not(member(private(k),vals(state`keys)))
	THEN a=OUT_CPUError(CPU_SIGN_ERROR) AND 
	     s=state
	ELSE LET H1=tpmCompositeHash(tpmPCRComposite(p,s`pcrs)),
	     	 pcrData=tpmPCRComposite(p,s`pcrs) IN
             a=OUT_Quote(pcrData,
			signed(tpmQuote(H1,n),private(k)),
		    	(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
				resAuth:=usageAuth(encData(encDat(k)))#),
		    	TPM_SUCCESS) AND 
	     s=state WITH [`outData:=cons(signed(tpmQuote(H1,n),private(k)),
					cons(pcrData,outData(state)))]
	ENDIF;

  %% If nonces don't match, quotes don't match.  We don't care about this
  %% if the a quote cannot be produced.
  %% proved - Fri Jun 22 16:55:16 CDT 2012
  bad_nonce: THEOREM
    FORALL (s:(afterStartup?),k:(tpmKey?),n1,n2:(tpmNonce?),pm:PCR_SELECTION,
		i:authIn) :
      n1/=n2 AND quote?(k) AND member(private(k),vals(s`keys))
      =>
       runState(TPM_Quote(k,n1,pm,i))(s)
       /=
       runState(TPM_Quote(k,n2,pm,i))(s);


  %% Bad Signing Key - Man in the Middle Attack - we don't care about this
  %% if either key won't produce a quote.
  %% proved - Fri Jun 22 16:55:56 CDT 2012
  bad_signing_key: THEOREM
    FORALL (s:(afterStartup?),n:(tpmNonce?),pm:PCR_SELECTION,k0,k1:(tpmKey?),
		i:authIn) :
          private(k0) /= private(k1) AND
	  quote?(k0) AND quote?(k1) AND
	  member(private(k0),vals(s`keys)) AND member(private(k1),vals(s`keys))
          =>
      runState(TPM_Quote(k0,n,pm,i))(s)
      /= runState(TPM_Quote(k1,n,pm,i))(s);

  %% Bad PCRs - If different pcrs selected, different quote is output
  bad_pcrs: THEOREM
    FORALL (s:(afterStartup?),n:(tpmNonce?),p0,p1:PCR_SELECTION,k:(tpmKey?),
		i:authIn) :
      quote?(k) AND p0/=p1 AND member(private(k),vals(s`keys))
      =>
      runState(TPM_Quote(k,n,p0,i))(s)
      /=
      runState(TPM_Quote(k,n,p1,i))(s) 

     
  %% Output after going through tpm commands is same as grabbing pcrs
  %% proved - Fri Jun 22 16:56:08 CDT 2012
  %% TODO: problem: quote isn't getting correct pcrs input since that's saved in intermediate state. somehow update this or add as param to TPM_Extend?
  check_PCRS: THEOREM 
    FORALL (state:(afterStartup?),k:(tpmKey?),hv:HV,pm:PCR_SELECTION,
		n:(tpmNonce?),ind:PCRINDEX,i:authIn) :
      LET (a,s)=runState(
        	TPM_Extend(ind,hv) 
		>> TPM_Quote(k,n,pm,i))
		(state) IN
    extend?(state,ind,hv) AND quote?(k) AND 
    member(private(k),vals(state`keys)) =>
    a=OUT_Quote(tpmPCRComposite(pm,s`pcrs),
		signed(tpmQuote(tpmCompositeHash(
					tpmPCRComposite(pm,s`pcrs)),
			   	%pcrValue:=pcrsExtend(state`pcrs,ind,hv)#)),
			 	n),
		       private(k)),
		(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(k)))#),
		TPM_SUCCESS) AND 
    IF s`permFlags`disable OR s`stclearFlags`deactivated
    THEN s=state WITH [`pcrs:=pcrsExtend(state`pcrs,ind,hv)
		      ,`outData:=cons(tpmPCRComposite(pm,s`pcrs),
			         cons(signed(tpmQuote(tpmCompositeHash(
						tpmPCRComposite(pm,s`pcrs)),n),
				   	private(k)),
			         state`outData))]
    ELSE s=state WITH [`pcrs:=pcrsExtend(state`pcrs,ind,hv)
		      ,`outData:=cons(tpmPCRValue(extend(state`pcrs(ind),hv)),
			    cons(tpmPCRComposite(pm,s`pcrs),
			    cons(signed(tpmQuote(tpmCompositeHash(
					tpmPCRComposite(pm,s`pcrs)),n),
				   private(k)),
				state`outData)))]
    ENDIF;


  % (rewrite-msg-off)      
  quote_with_prev_key: THEOREM
   FORALL (state:(afterStartup?),pk,k:(tpmKey?),n:(tpmNonce?),pm:PCR_SELECTION,
    	   dUA,dMA:(tpmEncAuth?),i1,i2:authIn,x:nat) :
    LET (a,s) = runState(
		TPM_CreateWrapKey(pk,k,dUA,dMA,i1)
		>>=CPU_saveOutput(x)
		>>= (LAMBDA (a:tpmAbsOutput) : 
		     CASES a OF 
		       OUT_CreateWrapKey(wk,a,m) : TPM_Quote(wk,n,pm,i2) 
		       ELSE TPM_Noop(a) 
		     ENDCASES))
		(state) IN
    OUT_CreateWrapKey?(s`memory(x)) => 
      LET key=wrappedKey(s`memory(x)) IN
 	createWrapKey?(pk,k) AND quote?(key) AND 
	member(private(key),vals(state`keys))
	 => 
        a=OUT_Quote(tpmPCRComposite(pm,s`pcrs),
	            signed(tpmQuote(tpmCompositeHash(
					tpmPCRComposite(pm,s`pcrs)),
			     	    n),
			   private(key)),
		    (#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=TRUE,
			resAuth:=usageAuth(encData(encDat(key)))#),
		    TPM_SUCCESS)
	

  %% Prove that skipping SENTER is detectable by showing the quote following
  %% a command differs when SENTER is excluded.
  %% proved - Tue Jun 12 15:34:24 CDT 2012
  no_senter: THEOREM 
    FORALL (state:tpmAbsState,k:(tpmKey?),hv:HV,n:(tpmNonce?),
		pm:PCR_SELECTION,ind:PCRINDEX,i:authIn) :
      runState(
	TPM_Init
      	>> TPM_Startup(TPM_ST_CLEAR)
      	>> CPU_senter
      	>> CPU_sinit
      	>> TPM_Extend(ind,hv)
      	>> TPM_Quote(k,n,pm,i))
      	(state)
      /=
      runState(
	TPM_Init
	>> TPM_Extend(ind,hv)
	>> TPM_Quote(k,n,pm,i))
	(state)

  %% TPMs will not lie about who they are.  If the AIK cannot be installed
  %% then no quote will be generated
  %% proved - Wed Jul 11 11:28:46 EDT 2012
%   aik_binding: THEOREM
%     FORALL (aik:(tpmKey?),b:(tpmNonce?),pm:PCR_SELECTION,state:tpmAbsState) :
%       LET (a,s) = runState(
%                   TPM_Init
% 		  >> TPM_Startup(TPM_ST_CLEAR)
% 		  >> CPU_senter
% 		  >> CPU_sinit
% 		  >> TPM_Quote(aik,b,pm))
% 		  (state) IN
%        NOT checkKeyRoot(aik,srk(s)) => 
%        a=OUT_Error(TPM_INVALID_KEYUSAGE);


  %% 16.4 TPM_PCR_Reset
  %% For PCR with the pcrReset attribute set to TRUE, this command resets the
  %%  PCR back to the default value, this mimics the actions of TPM_Init. The
  %%  PCR may have restrictions as to which locality can perform the reset
  %%  operation.
  %% Sending a null pcrSelection results in an error is due to the requirement
  %%  that the command actually do something. If pcrSelection is null there are
  %%  no PCR to reset and the command would then do nothing.
  %% For PCR that are resettable, the presence of a Trusted Operating System
  %%  (TOS) can change the behavior of TPM_PCR_Reset. The following pseudo code
  %%  shows how the behavior changes
  %% At TPM_Startup
  %%   If TPM_PCR_ATTRIBUTES->pcrReset is FALSE
  %%     Set PCR to 0x00...00 
  %%   Else Set PCR to 0xFF...FF 
  %% At TPM_PCR_Reset
  %%   If TPM_PCR_ATTRIBUTES->pcrReset is TRUE 
  %%     If TOSPresent
  %%       Set PCR to 0x00...00 
  %% 	   Else Set PCR to 0xFF...FF
  %%     Else Return error
  %% The above pseudocode is for example only, for the details of a specific
  %%  platform, the reader must review the platform specific specification. The
  %%  purpose of the above pseudocode is to show that both pcrReset and the
  %%  TOSPresent bit control the value in use to when the PCR resets.
  TPM_PCR_Reset(pcrSelection:PCR_SELECTION):State =
    modifyOutput(
           (LAMBDA (s:tpmAbsState):executeCom(s,ABS_PCR_Reset(pcrSelection))),
           (LAMBDA (s:tpmAbsState):outputCom(s,ABS_PCR_Reset(pcrSelection))));

  pcr_reset_post : THEOREM
   FORALL(state:(afterStartup?),select:PCR_SELECTION) :
    LET (a,s) = runState(TPM_PCR_Reset(select))(state) IN
    IF null?(select)							% 1b
    THEN a=OUT_Error(TPM_INVALID_PCR_INFO) AND				% 1c
    	 s=state
    ELSE LET num=validatePCRVals(state,select) IN
      	 COND
      	 num=0 -> a=OUT_PCR_Reset(TPM_SUCCESS) AND
	       	  s=state WITH [`pcrs:=pcrsResetSelection(state`pcrs,select)],
      	 num=1 -> a=OUT_Error(TPM_NOTRESETABLE) AND
	       	  s=state,
      	 num=2 -> a=OUT_Error(TPM_NOTLOCAL) AND
	       	  s=state,
	 ELSE -> a=OUT_Error(TPM_SUCCESS)
      	 ENDCOND
    ENDIF;

  % TODO: need validatePCRs theorem
  pcr_reset_post2 : THEOREM
   FORALL(state:(afterStartup?),select:PCR_SELECTION) :
    LET (a,s) = runState(TPM_PCR_Reset(select))(state) IN
    not null?(select) =>
    not a=OUT_Error(TPM_SUCCESS)

  %% 16.5 TPM_Quote2 TODO

  %% 17. Changing AuthData
  %% 17.1 TPM_ChangeAuth
  %% The TPM_ChangeAuth command allows the owner of an entity to change the
  %%  AuthData for the entity.
  %% This command cannot invalidate the old entity. Therefore, the authorization
  %%  change is only effective if the application can guarantee that the old
  %%  entity can be securely destroyed. If not, two valid entities will exist,
  %%  one with the old and one with the new authorization secret.
  %% If this command is delegated, the delegated party can expand its key use
  %%  privileges. That party can create a copy of the key with known
  %%  authorization, and it can then use the key w/out any ordinal restrictions.
  %% TPM_ChangeAuth requires the encryption of one parameter (“NewAuth”). For
  %%  the sake of uniformity with other commands that require the encryption of
  %%  more than one parameter, the parameters used for used encryption are 
  %%  generated from the authLastNonceEven (created during the OSAP session),
  %%  nonceOdd, and the session shared secret.
  %% The parameter list to this command must always include two authorization
  %%  sessions, regardless of the state of authDataUsage for the respective keys
  TPM_ChangeAuth(p:(tpmKey?),n:(tpmEncAuth?),d:(encrypted?),i1,i2:authIn):State=
    modifyOutput(
	(LAMBDA (s:tpmAbsState):executeCom(s,ABS_ChangeAuth(p,n,d,i1,i2))),
	(LAMBDA (s:tpmAbsState):outputCom(s,ABS_ChangeAuth(p,n,d,i1,i2))));

  change_auth_post : THEOREM
   FORALL(state:(afterStartup?),p:(tpmKey?),n:(tpmEncAuth?),d:(encrypted?),
		i1,i2:authIn):
    LET (a,s) = runState(TPM_ChangeAuth(p,n,d,i1,i2))(state) IN
    IF tpmKey?(d) OR tpmStoredData?(d)
    THEN LET decryptAuth=decryptADIP(n,authHandle(i1)) IN
	 IF not storage?(keyUsage(p))	   
	 THEN a=OUT_Error(TPM_INVALID_KEYUSAGE) AND s=state		% 8
	 ELSE LET b1=decrypt(d,private(p),state`keys),			% 9
	      	  o1=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=usageAuth(encData(encDat(p)))#),
	      	  o2=(#nonceEven:=EVEN,nonceOdd:=ODD,contAuthSess:=FALSE,
			resAuth:=ownerAuth(i2)#) IN
	      CASES b1 OF	       					% 10
	      tpmStoreAsymkey(u,m,v,k) : 
		a=OUT_ChangeAuth(encrypted(
				   tpmStoreAsymkey(
				      changeAuthOut2(u,decryptAuth,i2),	% 10,11
				      m,v,k)
				  ,key(p)),				% 12
				o1,o2,TPM_SUCCESS) AND
		s=state WITH [`outData:=cons(encrypted(tpmStoreAsymkey(
						changeAuthOut2(u,decryptAuth,i2)
						,m,v,k),key(p)),
					outData(state))],
	      tpmSealedData(a,f,s,d) : 
		a=OUT_ChangeAuth(encrypted(
				   tpmSealedData(
				      changeAuthOut2(a,decryptAuth,i2),	% 10,11
				      f,s,d),key(p)),			% 12
				o1,o2,TPM_SUCCESS) AND 
		s=state WITH [`outData:=cons(encrypted(tpmSealedData(
						changeAuthOut2(a,decryptAuth,i2)
						,f,s,d),key(p)),
					outData(state))]
	      ELSE a=OUT_Error(TPM_INVALID_STRUCTURE) AND s=state	% 10a
	      ENDCASES
	 ENDIF
    ELSE a=OUT_Error(TPM_INVALID_STRUCTURE) AND s=state		% TODO: check
    ENDIF
    
  %% 17.2 TPM_ChangeAuthOwner TODO
  
  %% 18. Authorization Sessions TODO
  %% 18.1 TPM_OIAP TODO
  %% 18.2 TPM_OSAP TODO
  %% 18.3 TPM_DSAP TODO
  %% 18.4 TPM_SetOwnerPointer TODO

  %% 19. Delegation Commands TODO
  %% 20. Non-volatile Storage TODO
  %% 21. Session Management TODO
  %% 22. Eviction TODO
  %% 23. Timing Ticks TODO
  %% 24. Transport Sessions TODO
  %% 25. Monotonic Counter TODO
  %% 26. DAA Commands TODO
  %% 27. Depreciated Commands TODO?
  %% 28. Deleted Commands TODO?
  
	   
END tpm

