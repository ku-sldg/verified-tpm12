\documentclass[10pt]{article}

%\usepackage{hyperref}
\usepackage{alltt}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{url}
\usepackage{fancyhdr}
\usepackage{trust}
\pagestyle{fancy}

\lhead{}
\rhead{}
\lfoot{\copyright The University of Kansas, 2012}
\cfoot{\thepage}


\newtheorem{conjecture}{Conjecture}
\newtheorem{obligation}{Obligation}
\newtheorem{definition}{Definition}


\usepackage{ifthen}
\newboolean{submission}  %%set to true for the submission version
\setboolean{submission}{false}
%\setboolean{submission}{true}
\ifthenelse
{\boolean{submission}}
{ \newcommand{\todo}[1]{ } } % hide todo
{ \newcommand{\todo}[1]{ % show todo
   \marginpar{\raggedright\footnotesize{#1}}
               }}

\parskip=\medskipamount
\parindent=0pt

\bibliographystyle{abbrvnat}

\title{TPM Specification Design}
\author{Perry Alexander \and Brigid Halling}

\begin{document}

\maketitle
\tableofcontents
\listoffigures
\listoftables

\begin{abstract}
  The abstract goes here...
\end{abstract}

\section{Introduction}

\section{Modeling Approach}

\subsection{TPM State Monad}

Figure~\ref{fig:tpm-abs-state} is the PVS record structure used to
represent the internal state of the TPM.

\begin{figure}
\begin{alltt}
  tpmAbsState : TYPE = [#
                       memory : mem,
                       postInit : bool,
                       srk : (asymKey?),
                       ek : (asymKey?),
                       keys : KEYSET,
                       pcrs : PCRS,
                       locality : LOCALITY
                       #];
\end{alltt}
\caption{Abstract TPM and system state record data structure.}
\label{fig:tpm-abs-state}
\end{figure}

\subsection{TPM Command Definitions}

Figure~\ref{fig:tpm-command} is the PVS data type used to represent
the abstract syntax of the TPM command set.

\begin{figure}
\begin{alltt}
  tpmInput : DATATYPE
  BEGIN
  %% Startup commands
    ABS_Init : ABS_Init? 
    ABS_Startup : ABS_Startup? % Only clear implemented
    ABS_SaveState : ABS_SaveState? % unimplemented
  %% PCRs, seals and keys
    ABS_Extend(h:HV,i:PCRINDEX) : ABS_Extend?
    ABS_Unseal(s:(sealBlob?),uk:(asymKey?)) : ABS_Unseal?   
    ABS_Seal(sk:(asymKey?),data:BLOB) : ABS_Seal?
    ABS_LoadKey2(lk:(wrapKey?)): ABS_LoadKey2? 
    ABS_CreateWrapKey(wk,parentk:(asymKey?)): ABS_CreateWrapKey?
  %% Quotes and Identities
    ABS_Quote(aik:(wrapKey?),nonce:BLOB,pm:PCRMASK) : ABS_Quote?
    ABS_MakeIdentity(naik:(asymKey?),k:(symKey?)) : ABS_MakeIdentity?
    ABS_ActivateIdentity(caik:(wrapKey?),k:(symKey?)) : ABS_ActivateIdentity?
  %% Ownership management
    ABS_TakeOwnership : ABS_TakeOwnership?
    ABS_OwnerClear : ABS_OwnerClear? % unimplemented
    ABS_ForceClear : ABS_ForceClear? % unimplemented
    ABS_DisableOwnerClear : ABS_DisabelOwnerClear? % unimplemented
  %% Software Commands
    ABS_senter : ABS_senter? % implemented all actions as one senter
    ABS_sinit : ABS_sinit? % partially implemented
    ABS_Save(i:nat,v:tpmAbsOutput) : ABS_Save?
    ABS_Read(i:nat) : ABS_Read?
  %% CA Commands
    ABS_certify(aik:(wrapKey?),ek:(asymKey?),freshk:(symKey?)) : ABS_certify?
  %% Invented, imaginary Commands
    noopCom : noopCom?
  END tpmInput;
\end{alltt}
\caption{TPM command data type.}
\label{fig:tpm-command}
\end{figure}

Table~\ref{tab:tpm-to-pvs} maps TPM concrete commands to their
abstract PVS representations.

\begin{table}[hbtp]
  \centering
  \begin{tabular}{lll}
    \hline
    \emph{TPM} & \emph{Abstract PVS} & \emph{Concrete PVS} \\
    \emph{Command} & \emph{Command} & \emph{Command} \\ \hline
    \textsf{TPM\_Init} & \verb+ABS_Init+ & \\ 
    \textsf{TPM\_Startup} & \verb+ABS_Startup+ & \\
    \textsf{TPM\_SaveState} & \verb+ABS_SaveState+ & \\
    \textsf{TPM\_CreateWrapKey} & \verb+ABS_CreateWrapKey(wk,parentk)+ & \\
    \textsf{TPM\_LoadKey2} & \verb+ABS_LoadKey2(k)+ & \\
    \textsf{TPM\_Seal} & \verb+ABS_Seal(sk,data)+& \\
    \textsf{TPM\_Unseal} & \verb+ABS_Unseal(s,uk)+ & \\
    \textsf{TPM\_Extend} & \verb+ABS_Extend(h,i)+ & \\
    \textsf{TPM\_Quote} & \verb+ABS_Quote(aik,b,pm)+ & \\
    \textsf{TPM\_MakeIdentity} & \verb+ABS_MakeIdentity(naik,k)+ & \\
    \textsf{TPM\_ActivateIdentity} & \verb+ABS_ActivateIdentity(caik,k)+ & \\
    \textsf{TPM\_TakeOwnership} & \verb+ABS_TakeOwnership+ & \\
    \textsf{TPM\_OwnerClear} & & \\
    \textsf{TPM\_ForceClear} & & \\ 
    \textsf{TPM\_DisableOwnerClear} & & \\
    \textsf{TPM\_Bind} & & \\
    \textsf{TPM\_Unbind} & & \\
    \hline
  \end{tabular}
  \caption{TPM command mapping to PVS command representation.}
  \label{tab:tpm-to-pvs}
\end{table}

Table~\ref{tab:commands-to-pvs} maps external commands that interact
with the TPM to their PVS representations.

\begin{table}[hbtp]
  \centering
  \begin{tabular}{lll}
    \hline
    \emph{External}& \emph{Abstract PVS} & \emph{Concrete PVS} \\
    \emph{Command} & \emph{Command} & \emph{Command} \\ \hline
    \textsf{senter} & \verb+ABS_senterCom+ & \\
    \textsf{sinit} & \verb+ABS_sinitCom+ & \\
    Save to memory & \verb+ABS_Save(i,v)+ & \\
    Read from memory & \verb+ABS_Read(i)+ & \\
    CA certification & \verb+ABS_certify(aik,ek,freshk)+ & \\
    Power On & \verb+powerCom+ & \\
    Power Off  & \verb+offCom+ & \\
    \hline
  \end{tabular}
  \caption{System commands interacting with TPM.}
  \label{tab:commands-to-pvs}
\end{table}


\section{Verification Approach}

The approach taken for verification is establishing a \emph{weak
  bisimulation}~\citep{Sangiorgi:12:Introduction-to} relation between
an abstract requirements model and a model derived from the TPM
specification as shown in figure~\ref{fig:bisimulation}.

\begin{figure}[hbtp]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/bisimulation.pdf}
  \caption{Weak bisimulation relation between an abstract transition
    system $A=(S,\Sigma,\Delta)$ and a concrete transition system
    $C=(s,\sigma,\delta)$.}
  \label{fig:bisimulation} 
\end{figure}

We say that $A=(S,\Sigma,\Delta)$ is an \emph{abstract model} where
$S$ is a set of abstract states, $\Sigma$ is a set of actions on
states and input, and $\Delta : S\times\Sigma\rightarrow\Sigma$ is a
transitions on state and action.  Similarly, we say that
$C=(s,\sigma,\delta)$ is a \emph{concrete state } where $s$ is a set
of concrete states, $\sigma$ is a set of actions on states and input,
and $\delta : s\times\sigma\rightarrow\sigma$ is a transition
function.

We relate the abstract and concrete models through an \emph{abstraction
function}, $\alpha:s\rightarrow S$, and \emph{concretization
function}, $\gamma:S\rightarrow 2^s$.  The abstraction and
concretization functions must form a Galois Connection such that:

\[s\in\gamma(\alpha(s))\]

\noindent Specifically, when making the result of an abstraction
concrete, the original state must be in the resulting set.  Note that
the concretization function may result in multiple states due to the
necessity of specifying unknown detail.

We say that $A$ and $C$ are weakly bisimilar ($A\sim C$) if when
$\alpha(s)=S$ then $\alpha(\delta^*(s))=\Delta(S)$ for all inputs to
$s$.

\begin{definition} 
  \[A\sim C \equiv \forall s_0:s \cdot \exists S_0:S \cdot
  \alpha(s_0)=S_0 \Rightarrow \alpha(\delta^*(s_0))=\Delta(S_0)\]
  \label{def:bisimulation}
\end{definition}

In the formal TPM model \texttt{tpmAbsState} defines $S$ while
\texttt{tpmConcState} defines $s$.

\appendix

\input{glossary}

%%\nocite{}

\bibliography{tpm-spec-design}

\end{document}
